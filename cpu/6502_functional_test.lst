AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page    1
---------------------------------------------------- 6502_functional_test.a65 ----------------------------------------------------

6102 lines read, no errors in pass 1.
                        ;
                        ; 6 5 0 2   F U N C T I O N A L   T E S T
                        ;
                        ; Copyright (C) 2012-2015  Klaus Dormann
                        ;
                        ; This program is free software: you can redistribute it and/or modify
                        ; it under the terms of the GNU General Public License as published by
                        ; the Free Software Foundation, either version 3 of the License, or
                        ; (at your option) any later version.
                        ;
                        ; This program is distributed in the hope that it will be useful,
                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        ; GNU General Public License for more details.
                        ;
                        ; You should have received a copy of the GNU General Public License
                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                        
                        
                        ; This program is designed to test all opcodes of a 6502 emulator using all
                        ; addressing modes with focus on propper setting of the processor status
                        ; register bits.
                        ;
                        ; version 04-dec-2017
                        ; contact info at http://2m5.de or email K@2m5.de
                        ;
                        ; assembled with AS65 from http://www.kingswood-consulting.co.uk/assemblers/
                        ; command line switches: -l -m -s2 -w -h0
                        ;                         |  |  |   |  no page headers in listing
                        ;                         |  |  |   wide listing (133 char/col)
                        ;                         |  |  write intel hex file instead of binary
                        ;                         |  expand macros in listing
                        ;                         generate pass2 listing
                        ;
                        ; No IO - should be run from a monitor with access to registers.
                        ; To run load intel hex image with a load command, than alter PC to 400 hex
                        ; (code_segment) and enter a go command.
                        ; Loop on program counter determines error or successful completion of test.
                        ; Check listing for relevant traps (jump/branch *).
                        ; Please note that in early tests some instructions will have to be used before
                        ; they are actually tested!
                        ;
                        ; RESET, NMI or IRQ should not occur and will be trapped if vectors are enabled.
                        ; Tests documented behavior of the original NMOS 6502 only! No unofficial
                        ; opcodes. Additional opcodes of newer versions of the CPU (65C02, 65816) will
                        ; not be tested. Decimal ops will only be tested with valid BCD operands and
                        ; N V Z flags will be ignored.
                        ;
                        ; Debugging hints:
                        ;     Most of the code is written sequentially. if you hit a trap, check the
                        ;   immediately preceeding code for the instruction to be tested. Results are
                        ;   tested first, flags are checked second by pushing them onto the stack and
                        ;   pulling them to the accumulator after the result was checked. The "real"
                        ;   flags are no longer valid for the tested instruction at this time!
                        ;     If the tested instruction was indexed, the relevant index (X or Y) must
                        ;   also be checked. Opposed to the flags, X and Y registers are still valid.
                        ;
                        ; versions:
                        ;   28-jul-2012  1st version distributed for testing
                        ;   29-jul-2012  fixed references to location 0, now #0
                        ;                added license - GPLv3
                        ;   30-jul-2012  added configuration options
                        ;   01-aug-2012  added trap macro to allow user to change error handling
                        ;   01-dec-2012  fixed trap in branch field must be a branch
                        ;   02-mar-2013  fixed PLA flags not tested
                        ;   19-jul-2013  allowed ROM vectors to be loaded when load_data_direct = 0
                        ;                added test sequence check to detect if tests jump their fence
                        ;   23-jul-2013  added RAM integrity check option
                        ;   16-aug-2013  added error report to standard output option
                        ;   13-dec-2014  added binary/decimal opcode table switch test
                        ;   14-dec-2014  improved relative address test
                        ;   23-aug-2015  added option to disable self modifying tests
                        ;   24-aug-2015  all self modifying immediate opcodes now execute in data RAM
                        ;                added small branch offset pretest
                        ;   21-oct-2015  added option to disable decimal mode ADC & SBC tests
                        ;   04-dec-2017  fixed BRK only tested with interrupts enabled
                        ;                added option to skip the remainder of a failing test
                        ;                in report.i65
                        
                        
                        ; C O N F I G U R A T I O N
                        
                        ;ROM_vectors writable (0=no, 1=yes)
                        ;if ROM vectors can not be used interrupts will not be trapped
                        ;as a consequence BRK can not be tested but will be emulated to test RTI
0001 =                  ROM_vectors = 1
                        
                        ;load_data_direct (0=move from code segment, 1=load directly)
                        ;loading directly is preferred but may not be supported by your platform
                        ;0 produces only consecutive object code, 1 is not suitable for a binary image
0001 =                  load_data_direct = 1
                        
                        ;I_flag behavior (0=force enabled, 1=force disabled, 2=prohibit change, 3=allow
                        ;change) 2 requires extra code and is not recommended. SEI & CLI can only be
                        ;tested if you allow changing the interrupt status (I_flag = 3)
0003 =                  I_flag = 3
                        
                        ;configure memory - try to stay away from memory used by the system
                        ;zero_page memory start address, $50 (80) consecutive Bytes required
                        ;                                add 2 if I_flag = 2
0000 =                  zero_page = $0
                        
                        ;data_segment memory start address, $6A (106) consecutive Bytes required
0200 =                  data_segment = $200
                            if (data_segment & $ff) != 0
                                ERROR ERROR ERROR low byte of data_segment MUST be $00 !!
                            endif
                        
                        ;code_segment memory start address, 13kB of consecutive space required
                        ;                                   add 2.5 kB if I_flag = 2
0800 =                  code_segment = $800
                        
                        ;self modifying code may be disabled to allow running in ROM
                        ;0=part of the code is self modifying and must reside in RAM
                        ;1=tests disabled: branch range
0000 =                  disable_selfmod = 0
                        
                        ;report errors through I/O channel (0=use standard self trap loops, 1=include
                        ;report.i65 as I/O channel, add 3.5 kB)
0000 =                  report = 0
                        
                        ;RAM integrity test option. Checks for undesired RAM writes.
                        ;set lowest non RAM or RAM mirror address page (-1=disable, 0=64k, $40=16k)
                        ;leave disabled if a monitor, OS or background interrupt is allowed to alter RAM
ffff =                  ram_top = -1
                        
                        ;disable test decimal mode ADC & SBC, 0=enable, 1=disable,
                        ;2=disable including decimal flag in processor status
0000 =                  disable_decimal = 0
                        
                                noopt       ;do not take shortcuts
                        
                        ;macros for error & success traps to allow user modification
                        ;example:
                        ;trap    macro
                        ;        jsr my_error_handler
                        ;        endm
                        ;trap_eq macro
                        ;        bne skip\?
                        ;        trap           ;failed equal (zero)
                        ;skip\?
                        ;        endm
                        ;
                        ; my_error_handler should pop the calling address from the stack and report it.
                        ; putting larger portions of code (more than 3 bytes) inside the trap macro
                        ; may lead to branch range problems for some tests.
                            if report = 0
                        trap    macro
                                jmp *           ;failed anyway
                                endm
                        trap_eq macro
                                beq *           ;failed equal (zero)
                                endm
                        trap_ne macro
                                bne *           ;failed not equal (non zero)
                                endm
                        trap_cs macro
                                bcs *           ;failed carry set
                                endm
                        trap_cc macro
                                bcc *           ;failed carry clear
                                endm
                        trap_mi macro
                                bmi *           ;failed minus (bit 7 set)
                                endm
                        trap_pl macro
                                bpl *           ;failed plus (bit 7 clear)
                                endm
                        trap_vs macro
                                bvs *           ;failed overflow set
                                endm
                        trap_vc macro
                                bvc *           ;failed overflow clear
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jmp *           ;test passed, no errors
                                endm
                            endif
                            if report = 1
                        trap    macro
                                jsr report_error
                                endm
                        trap_eq macro
                                bne skip\?
                                trap           ;failed equal (zero)
                        skip\?
                                endm
                        trap_ne macro
                                beq skip\?
                                trap            ;failed not equal (non zero)
                        skip\?
                                endm
                        trap_cs macro
                                bcc skip\?
                                trap            ;failed carry set
                        skip\?
                                endm
                        trap_cc macro
                                bcs skip\?
                                trap            ;failed carry clear
                        skip\?
                                endm
                        trap_mi macro
                                bpl skip\?
                                trap            ;failed minus (bit 7 set)
                        skip\?
                                endm
                        trap_pl macro
                                bmi skip\?
                                trap            ;failed plus (bit 7 clear)
                        skip\?
                                endm
                        trap_vs macro
                                bvc skip\?
                                trap            ;failed overflow set
                        skip\?
                                endm
                        trap_vc macro
                                bvs skip\?
                                trap            ;failed overflow clear
                        skip\?
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jsr report_success
                                endm
                            endif
                        
                        
0001 =                  carry   equ %00000001   ;flag bits in status
0002 =                  zero    equ %00000010
0004 =                  intdis  equ %00000100
0008 =                  decmode equ %00001000
0010 =                  break   equ %00010000
0020 =                  reserv  equ %00100000
0040 =                  overfl  equ %01000000
0080 =                  minus   equ %10000000
                        
0001 =                  fc      equ carry
0002 =                  fz      equ zero
0003 =                  fzc     equ carry+zero
0040 =                  fv      equ overfl
0042 =                  fvz     equ overfl+zero
0080 =                  fn      equ minus
0081 =                  fnc     equ minus+carry
0082 =                  fnz     equ minus+zero
0083 =                  fnzc    equ minus+zero+carry
00c0 =                  fnv     equ minus+overfl
                        
0030 =                  fao     equ break+reserv    ;bits always on after PHP, BRK
0034 =                  fai     equ fao+intdis      ;+ forced interrupt disable
0038 =                  faod    equ fao+decmode     ;+ ignore decimal
003c =                  faid    equ fai+decmode     ;+ ignore decimal
00ff =                  m8      equ $ff             ;8 bit mask
00fb =                  m8i     equ $ff&~intdis     ;8 bit mask - interrupt disable
                        
                        ;macros to allow masking of status bits.
                        ;masking test of decimal bit
                        ;masking of interrupt enable/disable on load and compare
                        ;masking of always on bits after PHP or BRK (unused & break) on compare
                            if disable_decimal < 2
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8i   ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fai)&m8    ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1|fai)       ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    cmp #(\1|fao)&m8i   ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8    ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    eor #\1|fao         ;invert expected flags + always on bits
                                    endm
                                endif
                            else
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faid)&m8   ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1|faid)      ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8   ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #\1|faod        ;invert expected flags + always on bits
                                    endm
                                endif
                            endif
                        
                        ;macros to set (register|memory|zeropage) & status
                        set_stat    macro       ;setting flags in the processor status register
                                    load_flag \1
                                    pha         ;use stack to load status
                                    plp
                                    endm
                        
                        set_a       macro       ;precharging accu & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda #\1     ;precharge accu
                                    plp
                                    endm
                        
                        set_x       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldx #\1     ;precharge index x
                                    plp
                                    endm
                        
                        set_y       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldy #\1     ;precharge index y
                                    plp
                                    endm
                        
                        set_ax      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;precharge accu
                                    plp
                                    endm
                        
                        set_ay      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,y    ;precharge accu
                                    plp
                                    endm
                        
                        set_z       macro       ;precharging indexed zp & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to zeropage
                                    sta zpt
                                    plp
                                    endm
                        
                        set_zx      macro       ;precharging zp,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed zeropage
                                    sta zpt,x
                                    plp
                                    endm
                        
                        set_abs     macro       ;precharging indexed memory & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to memory
                                    sta abst
                                    plp
                                    endm
                        
                        set_absx    macro       ;precharging abs,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed memory
                                    sta abst,x
                                    plp
                                    endm
                        
                        ;macros to test (register|memory|zeropage) & status & (mask)
                        tst_stat    macro       ;testing flags in the processor status register
                                    php         ;save status
                                    pla         ;use stack to retrieve status
                                    pha
                                    cmp_flag \1
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_a       macro       ;testing result in accu & flags
                                    php         ;save flags
                                    cmp #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_x       macro       ;testing result in x index & flags
                                    php         ;save flags
                                    cpx #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_y       macro       ;testing result in y index & flags
                                    php         ;save flags
                                    cpy #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_ax      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne     ;
                                    endm
                        
                        tst_ay      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,y    ;test result
                                    trap_ne     ;
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,y    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_z       macro       ;indexed testing result in zp & flags
                                    php         ;save flags
                                    lda zpt
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_zx      macro       ;testing result in zp,x & flags
                                    php         ;save flags
                                    lda zpt,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_abs     macro       ;indexed testing result in memory & flags
                                    php         ;save flags
                                    lda abst
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_absx    macro       ;testing result in abs,x & flags
                                    php         ;save flags
                                    lda abst,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        ; RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                        ;   uses zpt word as indirect pointer, zpt+2 word as checksum
                                if ram_top > -1
                        check_ram   macro
                                    cld
                                    lda #0
                                    sta zpt         ;set low byte of indirect pointer
                                    sta zpt+3       ;checksum high byte
                                  if disable_selfmod = 0
                                    sta range_adr   ;reset self modifying code
                                  endif
                                    clc
                                    ldx #zp_bss-zero_page ;zeropage - write test area
                        ccs3\?      adc zero_page,x
                                    bcc ccs2\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs2\?      inx
                                    bne ccs3\?
                                    ldx #hi(abs1)   ;set high byte of indirect pointer
                                    stx zpt+1
                                    ldy #lo(abs1)   ;data after write & execute test area
                        ccs5\?      adc (zpt),y
                                    bcc ccs4\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs4\?      iny
                                    bne ccs5\?
                                    inx             ;advance RAM high address
                                    stx zpt+1
                                    cpx #ram_top
                                    bne ccs5\?
                                    sta zpt+2       ;checksum low is
                                    cmp ram_chksm   ;checksum low expected
                                    trap_ne         ;checksum mismatch
                                    lda zpt+3       ;checksum high is
                                    cmp ram_chksm+1 ;checksum high expected
                                    trap_ne         ;checksum mismatch
                                    endm
                                else
                        check_ram   macro
                                    ;RAM check disabled - RAM size not set
                                    endm
                                endif
                        
                        next_test   macro           ;make sure, tests don't jump the fence
                                    lda test_case   ;previous test
                                    cmp #test_num
                                    trap_ne         ;test is out of sequence
                        test_num = test_num + 1
                                    lda #test_num   ;*** next tests' number
                                    sta test_case
                                    ;check_ram       ;uncomment to find altered RAM after each test
                                    endm
                        
                            if load_data_direct = 1
                                data
                            else
                                bss                 ;uninitialized segment, copy of data at end of code!
                            endif
0000 =                          org zero_page
                        ;break test interrupt save
0000 : 00               irq_a   ds  1               ;a register
0001 : 00               irq_x   ds  1               ;x register
                            if I_flag = 2
                        ;masking for I bit in status
                        flag_I_on   ds  1           ;or mask to load flags
                        flag_I_off  ds  1           ;and mask to load flags
                            endif
0002 :                  zpt                         ;5 bytes store/modify test area
                        ;add/subtract operand generation and result/flag prediction
0002 : 00               adfc    ds  1               ;carry flag before op
0003 : 00               ad1     ds  1               ;operand 1 - accumulator
0004 : 00               ad2     ds  1               ;operand 2 - memory / immediate
0005 : 00               adrl    ds  1               ;expected result bits 0-7
0006 : 00               adrh    ds  1               ;expected result bit 8 (carry)
0007 : 00               adrf    ds  1               ;expected flags NV0000ZC (only binary mode)
0008 : 00               sb2     ds  1               ;operand 2 complemented for subtract
0009 :                  zp_bss
0009 : c3824100         zp1     db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
000d : 7f               zp7f    db  $7f             ;test pattern for compare
                        ;logical zeropage operands
000e : 001f7180         zpOR    db  0,$1f,$71,$80   ;test pattern for OR
0012 : 0fff7f80         zpAN    db  $0f,$ff,$7f,$80 ;test pattern for AND
0016 : ff0f8f8f         zpEO    db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
001a : 1702             ind1    dw  abs1            ;indirect pointer to pattern in absolute memory
001c : 1802                     dw  abs1+1
001e : 1902                     dw  abs1+2
0020 : 1a02                     dw  abs1+3
0022 : 1b02                     dw  abs7f
0024 : 1f01             inw1    dw  abs1-$f8        ;indirect pointer for wrap-test pattern
0026 : 0302             indt    dw  abst            ;indirect pointer to store area in absolute memory
0028 : 0402                     dw  abst+1
002a : 0502                     dw  abst+2
002c : 0602                     dw  abst+3
002e : 0b01             inwt    dw  abst-$f8        ;indirect pointer for wrap-test store
0030 : 4e02             indAN   dw  absAN           ;indirect pointer to AND pattern in absolute memory
0032 : 4f02                     dw  absAN+1
0034 : 5002                     dw  absAN+2
0036 : 5102                     dw  absAN+3
0038 : 5202             indEO   dw  absEO           ;indirect pointer to EOR pattern in absolute memory
003a : 5302                     dw  absEO+1
003c : 5402                     dw  absEO+2
003e : 5502                     dw  absEO+3
0040 : 4a02             indOR   dw  absOR           ;indirect pointer to OR pattern in absolute memory
0042 : 4b02                     dw  absOR+1
0044 : 4c02                     dw  absOR+2
0046 : 4d02                     dw  absOR+3
                        ;add/subtract indirect pointers
0048 : 0302             adi2    dw  ada2            ;indirect pointer to operand 2 in absolute memory
004a : 0402             sbi2    dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
004c : 0401             adiy2   dw  ada2-$ff        ;with offset for indirect indexed
004e : 0501             sbiy2   dw  sba2-$ff
0050 :                  zp_bss_end
                        
0200 =                          org data_segment
0200 : 00               test_case   ds  1           ;current test number
0201 : 0000             ram_chksm   ds  2           ;checksum for RAM integrity test
                        ;add/subtract operand copy - abs tests write area
0203 :                  abst                        ;5 bytes store/modify test area
0203 : 00               ada2    ds  1               ;operand 2
0204 : 00               sba2    ds  1               ;operand 2 complemented for subtract
0205 : 000000                   ds  3               ;fill remaining bytes
0208 :                  data_bss
                            if load_data_direct = 1
0208 : 2900             ex_andi and #0              ;execute immediate opcodes
020a : 60                       rts
020b : 4900             ex_eori eor #0              ;execute immediate opcodes
020d : 60                       rts
020e : 0900             ex_orai ora #0              ;execute immediate opcodes
0210 : 60                       rts
0211 : 6900             ex_adci adc #0              ;execute immediate opcodes
0213 : 60                       rts
0214 : e900             ex_sbci sbc #0              ;execute immediate opcodes
0216 : 60                       rts
                            else
                        ex_andi ds  3
                        ex_eori ds  3
                        ex_orai ds  3
                        ex_adci ds  3
                        ex_sbci ds  3
                            endif
0217 : c3824100         abs1    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
021b : 7f               abs7f   db  $7f             ;test pattern for compare
                        ;loads
021c : 80800002         fLDx    db  fn,fn,0,fz      ;expected flags for load
                        ;shifts
0220 :                  rASL                        ;expected result ASL & ROL -carry
0220 : 86048200         rROL    db  $86,$04,$82,0   ; "
0224 : 87058301         rROLc   db  $87,$05,$83,1   ;expected result ROL +carry
0228 :                  rLSR                        ;expected result LSR & ROR -carry
0228 : 61412000         rROR    db  $61,$41,$20,0   ; "
022c : e1c1a080         rRORc   db  $e1,$c1,$a0,$80 ;expected result ROR +carry
0230 :                  fASL                        ;expected flags for shifts
0230 : 81018002         fROL    db  fnc,fc,fn,fz    ;no carry in
0234 : 81018000         fROLc   db  fnc,fc,fn,0     ;carry in
0238 :                  fLSR
0238 : 01000102         fROR    db  fc,0,fc,fz      ;no carry in
023c : 81808180         fRORc   db  fnc,fn,fnc,fn   ;carry in
                        ;increments (decrements)
0240 : 7f80ff0001       rINC    db  $7f,$80,$ff,0,1 ;expected result for INC/DEC
0245 : 0080800200       fINC    db  0,fn,fn,fz,0    ;expected flags for INC/DEC
                        ;logical memory operand
024a : 001f7180         absOR   db  0,$1f,$71,$80   ;test pattern for OR
024e : 0fff7f80         absAN   db  $0f,$ff,$7f,$80 ;test pattern for AND
0252 : ff0f8f8f         absEO   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;logical accu operand
0256 : 00f11f00         absORa  db  0,$f1,$1f,0     ;test pattern for OR
025a : f0ffffff         absANa  db  $f0,$ff,$ff,$ff ;test pattern for AND
025e : fff0f00f         absEOa  db  $ff,$f0,$f0,$0f ;test pattern for EOR
                        ;logical results
0262 : 00ff7f80         absrlo  db  0,$ff,$7f,$80
0266 : 02800080         absflo  db  fz,fn,0,fn
026a :                  data_bss_end
                        
                        
                                code
0800 =                          org code_segment
0800 : d8               start   cld
0801 : a2ff                     ldx #$ff
0803 : 9a                       txs
0804 : a900                     lda #0          ;*** test 0 = initialize
0806 : 8d0002                   sta test_case
0000 =                  test_num = 0
                        
                        ;stop interrupts before initializing BSS
                            if I_flag = 1
                                sei
                            endif
                        
                        ;initialize I/O for report channel
                            if report = 1
                                jsr report_init
                            endif
                        
                        ;pretest small branch offset
0809 : a205                     ldx #5
080b : 4c3308                   jmp psb_test
080e :                  psb_bwok
080e : a005                     ldy #5
0810 : d008                     bne psb_forw
                                trap        ;branch should be taken
0812 : 4c1208          >        jmp *           ;failed anyway
                        
0815 : 88                       dey         ;forward landing zone
0816 : 88                       dey
0817 : 88                       dey
0818 : 88                       dey
0819 : 88                       dey
081a :                  psb_forw
081a : 88                       dey
081b : 88                       dey
081c : 88                       dey
081d : 88                       dey
081e : 88                       dey
081f : f017                     beq psb_fwok
                                trap        ;forward offset
0821 : 4c2108          >        jmp *           ;failed anyway
                        
                        
0824 : ca                       dex         ;backward landing zone
0825 : ca                       dex
0826 : ca                       dex
0827 : ca                       dex
0828 : ca                       dex
0829 :                  psb_back
0829 : ca                       dex
082a : ca                       dex
082b : ca                       dex
082c : ca                       dex
082d : ca                       dex
082e : f0de                     beq psb_bwok
                                trap        ;backward offset
0830 : 4c3008          >        jmp *           ;failed anyway
                        
0833 :                  psb_test
0833 : d0f4                     bne psb_back
                                trap        ;branch should be taken
0835 : 4c3508          >        jmp *           ;failed anyway
                        
0838 :                  psb_fwok
                        
                        ;initialize BSS segment
                            if load_data_direct != 1
                                ldx #zp_end-zp_init-1
                        ld_zp   lda zp_init,x
                                sta zp_bss,x
                                dex
                                bpl ld_zp
                                ldx #data_end-data_init-1
                        ld_data lda data_init,x
                                sta data_bss,x
                                dex
                                bpl ld_data
                              if ROM_vectors = 1
                                ldx #5
                        ld_vect lda vec_init,x
                                sta vec_bss,x
                                dex
                                bpl ld_vect
                              endif
                            endif
                        
                        ;retain status of interrupt flag
                            if I_flag = 2
                                php
                                pla
                                and #4          ;isolate flag
                                sta flag_I_on   ;or mask
                                eor #lo(~4)     ;reverse
                                sta flag_I_off  ;and mask
                            endif
                        
                        ;generate checksum for RAM integrity test
                            if ram_top > -1
                                lda #0
                                sta zpt         ;set low byte of indirect pointer
                                sta ram_chksm+1 ;checksum high byte
                              if disable_selfmod = 0
                                sta range_adr   ;reset self modifying code
                              endif
                                clc
                                ldx #zp_bss-zero_page ;zeropage - write test area
                        gcs3    adc zero_page,x
                                bcc gcs2
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs2    inx
                                bne gcs3
                                ldx #hi(abs1)   ;set high byte of indirect pointer
                                stx zpt+1
                                ldy #lo(abs1)   ;data after write & execute test area
                        gcs5    adc (zpt),y
                                bcc gcs4
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs4    iny
                                bne gcs5
                                inx             ;advance RAM high address
                                stx zpt+1
                                cpx #ram_top
                                bne gcs5
                                sta ram_chksm   ;checksum complete
                            endif
                                next_test
0838 : ad0002          >            lda test_case   ;previous test
083b : c900            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
083d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0001 =                 >test_num = test_num + 1
083f : a901            >            lda #test_num   ;*** next tests' number
0841 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                            if disable_selfmod = 0
                        ;testing relative addressing with BEQ
0844 : a0fe                     ldy #$fe        ;testing maximum range, not -1/-2 (invalid/self adr)
0846 :                  range_loop
0846 : 88                       dey             ;next relative address
0847 : 98                       tya
0848 : aa                       tax             ;precharge count to end of loop
0849 : 1008                     bpl range_fw    ;calculate relative address
084b : 18                       clc             ;avoid branch self or to relative address of branch
084c : 6902                     adc #2
084e : ea                       nop             ;offset landing zone - tolerate +/-5 offset to branch
084f : ea                       nop
0850 : ea                       nop
0851 : ea                       nop
0852 : ea                       nop
0853 :                  range_fw
0853 : ea                       nop
0854 : ea                       nop
0855 : ea                       nop
0856 : ea                       nop
0857 : ea                       nop
0858 : 497f                     eor #$7f        ;complement except sign
085a : 8de608                   sta range_adr   ;load into test target
085d : a900                     lda #0          ;should set zero flag in status register
085f : 4ce508                   jmp range_op
                        
0862 : ca                       dex             ; offset landing zone - backward branch too far
0863 : ca                       dex
0864 : ca                       dex
0865 : ca                       dex
0866 : ca                       dex
                                ;relative address target field with branch under test in the middle
0867 : ca                       dex             ;-128 - max backward
0868 : ca                       dex
0869 : ca                       dex
086a : ca                       dex
086b : ca                       dex
086c : ca                       dex
086d : ca                       dex
086e : ca                       dex
086f : ca                       dex             ;-120
0870 : ca                       dex
0871 : ca                       dex
0872 : ca                       dex
0873 : ca                       dex
0874 : ca                       dex
0875 : ca                       dex
0876 : ca                       dex
0877 : ca                       dex
0878 : ca                       dex
0879 : ca                       dex             ;-110
087a : ca                       dex
087b : ca                       dex
087c : ca                       dex
087d : ca                       dex
087e : ca                       dex
087f : ca                       dex
0880 : ca                       dex
0881 : ca                       dex
0882 : ca                       dex
0883 : ca                       dex             ;-100
0884 : ca                       dex
0885 : ca                       dex
0886 : ca                       dex
0887 : ca                       dex
0888 : ca                       dex
0889 : ca                       dex
088a : ca                       dex
088b : ca                       dex
088c : ca                       dex
088d : ca                       dex             ;-90
088e : ca                       dex
088f : ca                       dex
0890 : ca                       dex
0891 : ca                       dex
0892 : ca                       dex
0893 : ca                       dex
0894 : ca                       dex
0895 : ca                       dex
0896 : ca                       dex
0897 : ca                       dex             ;-80
0898 : ca                       dex
0899 : ca                       dex
089a : ca                       dex
089b : ca                       dex
089c : ca                       dex
089d : ca                       dex
089e : ca                       dex
089f : ca                       dex
08a0 : ca                       dex
08a1 : ca                       dex             ;-70
08a2 : ca                       dex
08a3 : ca                       dex
08a4 : ca                       dex
08a5 : ca                       dex
08a6 : ca                       dex
08a7 : ca                       dex
08a8 : ca                       dex
08a9 : ca                       dex
08aa : ca                       dex
08ab : ca                       dex             ;-60
08ac : ca                       dex
08ad : ca                       dex
08ae : ca                       dex
08af : ca                       dex
08b0 : ca                       dex
08b1 : ca                       dex
08b2 : ca                       dex
08b3 : ca                       dex
08b4 : ca                       dex
08b5 : ca                       dex             ;-50
08b6 : ca                       dex
08b7 : ca                       dex
08b8 : ca                       dex
08b9 : ca                       dex
08ba : ca                       dex
08bb : ca                       dex
08bc : ca                       dex
08bd : ca                       dex
08be : ca                       dex
08bf : ca                       dex             ;-40
08c0 : ca                       dex
08c1 : ca                       dex
08c2 : ca                       dex
08c3 : ca                       dex
08c4 : ca                       dex
08c5 : ca                       dex
08c6 : ca                       dex
08c7 : ca                       dex
08c8 : ca                       dex
08c9 : ca                       dex             ;-30
08ca : ca                       dex
08cb : ca                       dex
08cc : ca                       dex
08cd : ca                       dex
08ce : ca                       dex
08cf : ca                       dex
08d0 : ca                       dex
08d1 : ca                       dex
08d2 : ca                       dex
08d3 : ca                       dex             ;-20
08d4 : ca                       dex
08d5 : ca                       dex
08d6 : ca                       dex
08d7 : ca                       dex
08d8 : ca                       dex
08d9 : ca                       dex
08da : ca                       dex
08db : ca                       dex
08dc : ca                       dex
08dd : ca                       dex             ;-10
08de : ca                       dex
08df : ca                       dex
08e0 : ca                       dex
08e1 : ca                       dex
08e2 : ca                       dex
08e3 : ca                       dex
08e4 : ca                       dex             ;-3
08e5 :                  range_op                ;test target with zero flag=0, z=1 if previous dex
08e6 =                  range_adr   = *+1       ;modifiable relative address
08e5 : f03e                     beq *+64        ;+64 if called without modification
08e7 : ca                       dex             ;+0
08e8 : ca                       dex
08e9 : ca                       dex
08ea : ca                       dex
08eb : ca                       dex
08ec : ca                       dex
08ed : ca                       dex
08ee : ca                       dex
08ef : ca                       dex
08f0 : ca                       dex
08f1 : ca                       dex             ;+10
08f2 : ca                       dex
08f3 : ca                       dex
08f4 : ca                       dex
08f5 : ca                       dex
08f6 : ca                       dex
08f7 : ca                       dex
08f8 : ca                       dex
08f9 : ca                       dex
08fa : ca                       dex
08fb : ca                       dex             ;+20
08fc : ca                       dex
08fd : ca                       dex
08fe : ca                       dex
08ff : ca                       dex
0900 : ca                       dex
0901 : ca                       dex
0902 : ca                       dex
0903 : ca                       dex
0904 : ca                       dex
0905 : ca                       dex             ;+30
0906 : ca                       dex
0907 : ca                       dex
0908 : ca                       dex
0909 : ca                       dex
090a : ca                       dex
090b : ca                       dex
090c : ca                       dex
090d : ca                       dex
090e : ca                       dex
090f : ca                       dex             ;+40
0910 : ca                       dex
0911 : ca                       dex
0912 : ca                       dex
0913 : ca                       dex
0914 : ca                       dex
0915 : ca                       dex
0916 : ca                       dex
0917 : ca                       dex
0918 : ca                       dex
0919 : ca                       dex             ;+50
091a : ca                       dex
091b : ca                       dex
091c : ca                       dex
091d : ca                       dex
091e : ca                       dex
091f : ca                       dex
0920 : ca                       dex
0921 : ca                       dex
0922 : ca                       dex
0923 : ca                       dex             ;+60
0924 : ca                       dex
0925 : ca                       dex
0926 : ca                       dex
0927 : ca                       dex
0928 : ca                       dex
0929 : ca                       dex
092a : ca                       dex
092b : ca                       dex
092c : ca                       dex
092d : ca                       dex             ;+70
092e : ca                       dex
092f : ca                       dex
0930 : ca                       dex
0931 : ca                       dex
0932 : ca                       dex
0933 : ca                       dex
0934 : ca                       dex
0935 : ca                       dex
0936 : ca                       dex
0937 : ca                       dex             ;+80
0938 : ca                       dex
0939 : ca                       dex
093a : ca                       dex
093b : ca                       dex
093c : ca                       dex
093d : ca                       dex
093e : ca                       dex
093f : ca                       dex
0940 : ca                       dex
0941 : ca                       dex             ;+90
0942 : ca                       dex
0943 : ca                       dex
0944 : ca                       dex
0945 : ca                       dex
0946 : ca                       dex
0947 : ca                       dex
0948 : ca                       dex
0949 : ca                       dex
094a : ca                       dex
094b : ca                       dex             ;+100
094c : ca                       dex
094d : ca                       dex
094e : ca                       dex
094f : ca                       dex
0950 : ca                       dex
0951 : ca                       dex
0952 : ca                       dex
0953 : ca                       dex
0954 : ca                       dex
0955 : ca                       dex             ;+110
0956 : ca                       dex
0957 : ca                       dex
0958 : ca                       dex
0959 : ca                       dex
095a : ca                       dex
095b : ca                       dex
095c : ca                       dex
095d : ca                       dex
095e : ca                       dex
095f : ca                       dex             ;+120
0960 : ca                       dex
0961 : ca                       dex
0962 : ca                       dex
0963 : ca                       dex
0964 : ca                       dex
0965 : ca                       dex
0966 : ea                       nop             ;offset landing zone - forward branch too far
0967 : ea                       nop
0968 : ea                       nop
0969 : ea                       nop
096a : ea                       nop
096b : f008                     beq range_ok    ;+127 - max forward
                                trap            ; bad range
096d : 4c6d09          >        jmp *           ;failed anyway
                        
0970 : ea                       nop             ;offset landing zone - tolerate +/-5 offset to branch
0971 : ea                       nop
0972 : ea                       nop
0973 : ea                       nop
0974 : ea                       nop
0975 :                  range_ok
0975 : ea                       nop
0976 : ea                       nop
0977 : ea                       nop
0978 : ea                       nop
0979 : ea                       nop
097a : c000                     cpy #0
097c : f003                     beq range_end
097e : 4c4608                   jmp range_loop
0981 :                  range_end               ;range test successful
                            endif
                                next_test
0981 : ad0002          >            lda test_case   ;previous test
0984 : c901            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0986 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0002 =                 >test_num = test_num + 1
0988 : a902            >            lda #test_num   ;*** next tests' number
098a : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;partial test BNE & CMP, CPX, CPY immediate
098d : c001                     cpy #1          ;testing BNE true
098f : d003                     bne test_bne
                                trap
0991 : 4c9109          >        jmp *           ;failed anyway
                        
0994 :                  test_bne
0994 : a900                     lda #0
0996 : c900                     cmp #0          ;test compare immediate
                                trap_ne
0998 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
099a : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
099c : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
099e : c901                     cmp #1
                                trap_eq
09a0 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
09a2 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
09a4 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
09a6 : aa                       tax
09a7 : e000                     cpx #0          ;test compare x immediate
                                trap_ne
09a9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
09ab : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
09ad : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
09af : e001                     cpx #1
                                trap_eq
09b1 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
09b3 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
09b5 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
09b7 : a8                       tay
09b8 : c000                     cpy #0          ;test compare y immediate
                                trap_ne
09ba : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
09bc : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
09be : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
09c0 : c001                     cpy #1
                                trap_eq
09c2 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
09c4 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
09c6 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                next_test
09c8 : ad0002          >            lda test_case   ;previous test
09cb : c902            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
09cd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0003 =                 >test_num = test_num + 1
09cf : a903            >            lda #test_num   ;*** next tests' number
09d1 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ;testing stack operations PHA PHP PLA PLP
                        
09d4 : a2ff                     ldx #$ff        ;initialize stack
09d6 : 9a                       txs
09d7 : a955                     lda #$55
09d9 : 48                       pha
09da : a9aa                     lda #$aa
09dc : 48                       pha
09dd : cdfe01                   cmp $1fe        ;on stack ?
                                trap_ne
09e0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09e2 : ba                       tsx
09e3 : 8a                       txa             ;overwrite accu
09e4 : c9fd                     cmp #$fd        ;sp decremented?
                                trap_ne
09e6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09e8 : 68                       pla
09e9 : c9aa                     cmp #$aa        ;successful retreived from stack?
                                trap_ne
09eb : d0fe            >        bne *           ;failed not equal (non zero)
                        
09ed : 68                       pla
09ee : c955                     cmp #$55
                                trap_ne
09f0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09f2 : cdff01                   cmp $1ff        ;remains on stack?
                                trap_ne
09f5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09f7 : ba                       tsx
09f8 : e0ff                     cpx #$ff        ;sp incremented?
                                trap_ne
09fa : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
09fc : ad0002          >            lda test_case   ;previous test
09ff : c903            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0a01 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0004 =                 >test_num = test_num + 1
0a03 : a904            >            lda #test_num   ;*** next tests' number
0a05 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;testing branch decisions BPL BMI BVC BVS BCC BCS BNE BEQ
                                set_stat $ff    ;all on
                       >            load_flag $ff    
0a08 : a9ff            >            lda #$ff                 ;allow test to change I-flag (no mask)
                       >
0a0a : 48              >            pha         ;use stack to load status
0a0b : 28              >            plp
                        
0a0c : 101a                     bpl nbr1        ;branches should not be taken
0a0e : 501b                     bvc nbr2
0a10 : 901c                     bcc nbr3
0a12 : d01d                     bne nbr4
0a14 : 3003                     bmi br1         ;branches should be taken
                                trap
0a16 : 4c160a          >        jmp *           ;failed anyway
                        
0a19 : 7003             br1     bvs br2
                                trap
0a1b : 4c1b0a          >        jmp *           ;failed anyway
                        
0a1e : b003             br2     bcs br3
                                trap
0a20 : 4c200a          >        jmp *           ;failed anyway
                        
0a23 : f00f             br3     beq br4
                                trap
0a25 : 4c250a          >        jmp *           ;failed anyway
                        
0a28 :                  nbr1
                                trap            ;previous bpl taken
0a28 : 4c280a          >        jmp *           ;failed anyway
                        
0a2b :                  nbr2
                                trap            ;previous bvc taken
0a2b : 4c2b0a          >        jmp *           ;failed anyway
                        
0a2e :                  nbr3
                                trap            ;previous bcc taken
0a2e : 4c2e0a          >        jmp *           ;failed anyway
                        
0a31 :                  nbr4
                                trap            ;previous bne taken
0a31 : 4c310a          >        jmp *           ;failed anyway
                        
0a34 : 08               br4     php
0a35 : ba                       tsx
0a36 : e0fe                     cpx #$fe        ;sp after php?
                                trap_ne
0a38 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a3a : 68                       pla
                                cmp_flag $ff    ;returned all flags on?
0a3b : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0a3d : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a3f : ba                       tsx
0a40 : e0ff                     cpx #$ff        ;sp after php?
                                trap_ne
0a42 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0      ;all off
                       >            load_flag 0      
0a44 : a900            >            lda #0                   ;allow test to change I-flag (no mask)
                       >
0a46 : 48              >            pha         ;use stack to load status
0a47 : 28              >            plp
                        
0a48 : 301a                     bmi nbr11       ;branches should not be taken
0a4a : 701b                     bvs nbr12
0a4c : b01c                     bcs nbr13
0a4e : f01d                     beq nbr14
0a50 : 1003                     bpl br11        ;branches should be taken
                                trap
0a52 : 4c520a          >        jmp *           ;failed anyway
                        
0a55 : 5003             br11    bvc br12
                                trap
0a57 : 4c570a          >        jmp *           ;failed anyway
                        
0a5a : 9003             br12    bcc br13
                                trap
0a5c : 4c5c0a          >        jmp *           ;failed anyway
                        
0a5f : d00f             br13    bne br14
                                trap
0a61 : 4c610a          >        jmp *           ;failed anyway
                        
0a64 :                  nbr11
                                trap            ;previous bmi taken
0a64 : 4c640a          >        jmp *           ;failed anyway
                        
0a67 :                  nbr12
                                trap            ;previous bvs taken
0a67 : 4c670a          >        jmp *           ;failed anyway
                        
0a6a :                  nbr13
                                trap            ;previous bcs taken
0a6a : 4c6a0a          >        jmp *           ;failed anyway
                        
0a6d :                  nbr14
                                trap            ;previous beq taken
0a6d : 4c6d0a          >        jmp *           ;failed anyway
                        
0a70 : 08               br14    php
0a71 : 68                       pla
                                cmp_flag 0      ;flags off except break (pushed by sw) + reserved?
0a72 : c930            >            cmp #(0      |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0a74 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                ;crosscheck flags
                                set_stat zero
                       >            load_flag zero
0a76 : a902            >            lda #zero             ;allow test to change I-flag (no mask)
                       >
0a78 : 48              >            pha         ;use stack to load status
0a79 : 28              >            plp
                        
0a7a : d002                     bne brzs1
0a7c : f003                     beq brzs2
0a7e :                  brzs1
                                trap            ;branch zero/non zero
0a7e : 4c7e0a          >        jmp *           ;failed anyway
                        
0a81 : b002             brzs2   bcs brzs3
0a83 : 9003                     bcc brzs4
0a85 :                  brzs3
                                trap            ;branch carry/no carry
0a85 : 4c850a          >        jmp *           ;failed anyway
                        
0a88 : 3002             brzs4   bmi brzs5
0a8a : 1003                     bpl brzs6
0a8c :                  brzs5
                                trap            ;branch minus/plus
0a8c : 4c8c0a          >        jmp *           ;failed anyway
                        
0a8f : 7002             brzs6   bvs brzs7
0a91 : 5003                     bvc brzs8
0a93 :                  brzs7
                                trap            ;branch overflow/no overflow
0a93 : 4c930a          >        jmp *           ;failed anyway
                        
0a96 :                  brzs8
                                set_stat carry
                       >            load_flag carry
0a96 : a901            >            lda #carry             ;allow test to change I-flag (no mask)
                       >
0a98 : 48              >            pha         ;use stack to load status
0a99 : 28              >            plp
                        
0a9a : f002                     beq brcs1
0a9c : d003                     bne brcs2
0a9e :                  brcs1
                                trap            ;branch zero/non zero
0a9e : 4c9e0a          >        jmp *           ;failed anyway
                        
0aa1 : 9002             brcs2   bcc brcs3
0aa3 : b003                     bcs brcs4
0aa5 :                  brcs3
                                trap            ;branch carry/no carry
0aa5 : 4ca50a          >        jmp *           ;failed anyway
                        
0aa8 : 3002             brcs4   bmi brcs5
0aaa : 1003                     bpl brcs6
0aac :                  brcs5
                                trap            ;branch minus/plus
0aac : 4cac0a          >        jmp *           ;failed anyway
                        
0aaf : 7002             brcs6   bvs brcs7
0ab1 : 5003                     bvc brcs8
0ab3 :                  brcs7
                                trap            ;branch overflow/no overflow
0ab3 : 4cb30a          >        jmp *           ;failed anyway
                        
                        
0ab6 :                  brcs8
                                set_stat minus
                       >            load_flag minus
0ab6 : a980            >            lda #minus             ;allow test to change I-flag (no mask)
                       >
0ab8 : 48              >            pha         ;use stack to load status
0ab9 : 28              >            plp
                        
0aba : f002                     beq brmi1
0abc : d003                     bne brmi2
0abe :                  brmi1
                                trap            ;branch zero/non zero
0abe : 4cbe0a          >        jmp *           ;failed anyway
                        
0ac1 : b002             brmi2   bcs brmi3
0ac3 : 9003                     bcc brmi4
0ac5 :                  brmi3
                                trap            ;branch carry/no carry
0ac5 : 4cc50a          >        jmp *           ;failed anyway
                        
0ac8 : 1002             brmi4   bpl brmi5
0aca : 3003                     bmi brmi6
0acc :                  brmi5
                                trap            ;branch minus/plus
0acc : 4ccc0a          >        jmp *           ;failed anyway
                        
0acf : 7002             brmi6   bvs brmi7
0ad1 : 5003                     bvc brmi8
0ad3 :                  brmi7
                                trap            ;branch overflow/no overflow
0ad3 : 4cd30a          >        jmp *           ;failed anyway
                        
0ad6 :                  brmi8
                                set_stat overfl
                       >            load_flag overfl
0ad6 : a940            >            lda #overfl             ;allow test to change I-flag (no mask)
                       >
0ad8 : 48              >            pha         ;use stack to load status
0ad9 : 28              >            plp
                        
0ada : f002                     beq brvs1
0adc : d003                     bne brvs2
0ade :                  brvs1
                                trap            ;branch zero/non zero
0ade : 4cde0a          >        jmp *           ;failed anyway
                        
0ae1 : b002             brvs2   bcs brvs3
0ae3 : 9003                     bcc brvs4
0ae5 :                  brvs3
                                trap            ;branch carry/no carry
0ae5 : 4ce50a          >        jmp *           ;failed anyway
                        
0ae8 : 3002             brvs4   bmi brvs5
0aea : 1003                     bpl brvs6
0aec :                  brvs5
                                trap            ;branch minus/plus
0aec : 4cec0a          >        jmp *           ;failed anyway
                        
0aef : 5002             brvs6   bvc brvs7
0af1 : 7003                     bvs brvs8
0af3 :                  brvs7
                                trap            ;branch overflow/no overflow
0af3 : 4cf30a          >        jmp *           ;failed anyway
                        
0af6 :                  brvs8
                                set_stat $ff-zero
                       >            load_flag $ff-zero
0af6 : a9fd            >            lda #$ff-zero             ;allow test to change I-flag (no mask)
                       >
0af8 : 48              >            pha         ;use stack to load status
0af9 : 28              >            plp
                        
0afa : f002                     beq brzc1
0afc : d003                     bne brzc2
0afe :                  brzc1
                                trap            ;branch zero/non zero
0afe : 4cfe0a          >        jmp *           ;failed anyway
                        
0b01 : 9002             brzc2   bcc brzc3
0b03 : b003                     bcs brzc4
0b05 :                  brzc3
                                trap            ;branch carry/no carry
0b05 : 4c050b          >        jmp *           ;failed anyway
                        
0b08 : 1002             brzc4   bpl brzc5
0b0a : 3003                     bmi brzc6
0b0c :                  brzc5
                                trap            ;branch minus/plus
0b0c : 4c0c0b          >        jmp *           ;failed anyway
                        
0b0f : 5002             brzc6   bvc brzc7
0b11 : 7003                     bvs brzc8
0b13 :                  brzc7
                                trap            ;branch overflow/no overflow
0b13 : 4c130b          >        jmp *           ;failed anyway
                        
0b16 :                  brzc8
                                set_stat $ff-carry
                       >            load_flag $ff-carry
0b16 : a9fe            >            lda #$ff-carry             ;allow test to change I-flag (no mask)
                       >
0b18 : 48              >            pha         ;use stack to load status
0b19 : 28              >            plp
                        
0b1a : d002                     bne brcc1
0b1c : f003                     beq brcc2
0b1e :                  brcc1
                                trap            ;branch zero/non zero
0b1e : 4c1e0b          >        jmp *           ;failed anyway
                        
0b21 : b002             brcc2   bcs brcc3
0b23 : 9003                     bcc brcc4
0b25 :                  brcc3
                                trap            ;branch carry/no carry
0b25 : 4c250b          >        jmp *           ;failed anyway
                        
0b28 : 1002             brcc4   bpl brcc5
0b2a : 3003                     bmi brcc6
0b2c :                  brcc5
                                trap            ;branch minus/plus
0b2c : 4c2c0b          >        jmp *           ;failed anyway
                        
0b2f : 5002             brcc6   bvc brcc7
0b31 : 7003                     bvs brcc8
0b33 :                  brcc7
                                trap            ;branch overflow/no overflow
0b33 : 4c330b          >        jmp *           ;failed anyway
                        
0b36 :                  brcc8
                                set_stat $ff-minus
                       >            load_flag $ff-minus
0b36 : a97f            >            lda #$ff-minus             ;allow test to change I-flag (no mask)
                       >
0b38 : 48              >            pha         ;use stack to load status
0b39 : 28              >            plp
                        
0b3a : d002                     bne brpl1
0b3c : f003                     beq brpl2
0b3e :                  brpl1
                                trap            ;branch zero/non zero
0b3e : 4c3e0b          >        jmp *           ;failed anyway
                        
0b41 : 9002             brpl2   bcc brpl3
0b43 : b003                     bcs brpl4
0b45 :                  brpl3
                                trap            ;branch carry/no carry
0b45 : 4c450b          >        jmp *           ;failed anyway
                        
0b48 : 3002             brpl4   bmi brpl5
0b4a : 1003                     bpl brpl6
0b4c :                  brpl5
                                trap            ;branch minus/plus
0b4c : 4c4c0b          >        jmp *           ;failed anyway
                        
0b4f : 5002             brpl6   bvc brpl7
0b51 : 7003                     bvs brpl8
0b53 :                  brpl7
                                trap            ;branch overflow/no overflow
0b53 : 4c530b          >        jmp *           ;failed anyway
                        
0b56 :                  brpl8
                                set_stat $ff-overfl
                       >            load_flag $ff-overfl
0b56 : a9bf            >            lda #$ff-overfl             ;allow test to change I-flag (no mask)
                       >
0b58 : 48              >            pha         ;use stack to load status
0b59 : 28              >            plp
                        
0b5a : d002                     bne brvc1
0b5c : f003                     beq brvc2
0b5e :                  brvc1
                                trap            ;branch zero/non zero
0b5e : 4c5e0b          >        jmp *           ;failed anyway
                        
0b61 : 9002             brvc2   bcc brvc3
0b63 : b003                     bcs brvc4
0b65 :                  brvc3
                                trap            ;branch carry/no carry
0b65 : 4c650b          >        jmp *           ;failed anyway
                        
0b68 : 1002             brvc4   bpl brvc5
0b6a : 3003                     bmi brvc6
0b6c :                  brvc5
                                trap            ;branch minus/plus
0b6c : 4c6c0b          >        jmp *           ;failed anyway
                        
0b6f : 7002             brvc6   bvs brvc7
0b71 : 5003                     bvc brvc8
0b73 :                  brvc7
                                trap            ;branch overflow/no overflow
0b73 : 4c730b          >        jmp *           ;failed anyway
                        
0b76 :                  brvc8
                                next_test
0b76 : ad0002          >            lda test_case   ;previous test
0b79 : c904            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0b7b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0005 =                 >test_num = test_num + 1
0b7d : a905            >            lda #test_num   ;*** next tests' number
0b7f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; test PHA does not alter flags or accumulator but PLA does
0b82 : a255                     ldx #$55        ;x & y protected
0b84 : a0aa                     ldy #$aa
                                set_a 1,$ff     ;push
                       >            load_flag $ff     
0b86 : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
0b88 : 48              >            pha         ;use stack to load status
0b89 : a901            >            lda #1     ;precharge accu
0b8b : 28              >            plp
                        
0b8c : 48                       pha
                                tst_a 1,$ff
0b8d : 08              >            php         ;save flags
0b8e : c901            >            cmp #1     ;test result
                       >            trap_ne
0b90 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b92 : 68              >            pla         ;load status
0b93 : 48              >            pha
                       >            cmp_flag $ff
0b94 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b96 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b98 : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
0b99 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0b9b : 48              >            pha         ;use stack to load status
0b9c : a900            >            lda #0     ;precharge accu
0b9e : 28              >            plp
                        
0b9f : 48                       pha
                                tst_a 0,0
0ba0 : 08              >            php         ;save flags
0ba1 : c900            >            cmp #0     ;test result
                       >            trap_ne
0ba3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ba5 : 68              >            pla         ;load status
0ba6 : 48              >            pha
                       >            cmp_flag 0
0ba7 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ba9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bab : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
0bac : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0bae : 48              >            pha         ;use stack to load status
0baf : a9ff            >            lda #$ff     ;precharge accu
0bb1 : 28              >            plp
                        
0bb2 : 48                       pha
                                tst_a $ff,$ff
0bb3 : 08              >            php         ;save flags
0bb4 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0bb6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bb8 : 68              >            pla         ;load status
0bb9 : 48              >            pha
                       >            cmp_flag $ff
0bba : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bbc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bbe : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
0bbf : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0bc1 : 48              >            pha         ;use stack to load status
0bc2 : a901            >            lda #1     ;precharge accu
0bc4 : 28              >            plp
                        
0bc5 : 48                       pha
                                tst_a 1,0
0bc6 : 08              >            php         ;save flags
0bc7 : c901            >            cmp #1     ;test result
                       >            trap_ne
0bc9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bcb : 68              >            pla         ;load status
0bcc : 48              >            pha
                       >            cmp_flag 0
0bcd : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bcf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bd1 : 28              >            plp         ;restore status
                        
                                set_a 0,$ff
                       >            load_flag $ff
0bd2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0bd4 : 48              >            pha         ;use stack to load status
0bd5 : a900            >            lda #0     ;precharge accu
0bd7 : 28              >            plp
                        
0bd8 : 48                       pha
                                tst_a 0,$ff
0bd9 : 08              >            php         ;save flags
0bda : c900            >            cmp #0     ;test result
                       >            trap_ne
0bdc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bde : 68              >            pla         ;load status
0bdf : 48              >            pha
                       >            cmp_flag $ff
0be0 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0be2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0be4 : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
0be5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0be7 : 48              >            pha         ;use stack to load status
0be8 : a9ff            >            lda #$ff     ;precharge accu
0bea : 28              >            plp
                        
0beb : 48                       pha
                                tst_a $ff,0
0bec : 08              >            php         ;save flags
0bed : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0bef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bf1 : 68              >            pla         ;load status
0bf2 : 48              >            pha
                       >            cmp_flag 0
0bf3 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bf5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bf7 : 28              >            plp         ;restore status
                        
                                set_a 0,$ff     ;pull
                       >            load_flag $ff     
0bf8 : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
0bfa : 48              >            pha         ;use stack to load status
0bfb : a900            >            lda #0     ;precharge accu
0bfd : 28              >            plp
                        
0bfe : 68                       pla
                                tst_a $ff,$ff-zero
0bff : 08              >            php         ;save flags
0c00 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c02 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c04 : 68              >            pla         ;load status
0c05 : 48              >            pha
                       >            cmp_flag $ff-zero
0c06 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c08 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c0a : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
0c0b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0c0d : 48              >            pha         ;use stack to load status
0c0e : a9ff            >            lda #$ff     ;precharge accu
0c10 : 28              >            plp
                        
0c11 : 68                       pla
                                tst_a 0,zero
0c12 : 08              >            php         ;save flags
0c13 : c900            >            cmp #0     ;test result
                       >            trap_ne
0c15 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c17 : 68              >            pla         ;load status
0c18 : 48              >            pha
                       >            cmp_flag zero
0c19 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c1b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c1d : 28              >            plp         ;restore status
                        
                                set_a $fe,$ff
                       >            load_flag $ff
0c1e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0c20 : 48              >            pha         ;use stack to load status
0c21 : a9fe            >            lda #$fe     ;precharge accu
0c23 : 28              >            plp
                        
0c24 : 68                       pla
                                tst_a 1,$ff-zero-minus
0c25 : 08              >            php         ;save flags
0c26 : c901            >            cmp #1     ;test result
                       >            trap_ne
0c28 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c2a : 68              >            pla         ;load status
0c2b : 48              >            pha
                       >            cmp_flag $ff-zero-minus
0c2c : c97d            >            cmp #($ff-zero-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c2e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c30 : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
0c31 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0c33 : 48              >            pha         ;use stack to load status
0c34 : a900            >            lda #0     ;precharge accu
0c36 : 28              >            plp
                        
0c37 : 68                       pla
                                tst_a $ff,minus
0c38 : 08              >            php         ;save flags
0c39 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c3b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c3d : 68              >            pla         ;load status
0c3e : 48              >            pha
                       >            cmp_flag minus
0c3f : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c41 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c43 : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
0c44 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0c46 : 48              >            pha         ;use stack to load status
0c47 : a9ff            >            lda #$ff     ;precharge accu
0c49 : 28              >            plp
                        
0c4a : 68                       pla
                                tst_a 0,$ff-minus
0c4b : 08              >            php         ;save flags
0c4c : c900            >            cmp #0     ;test result
                       >            trap_ne
0c4e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c50 : 68              >            pla         ;load status
0c51 : 48              >            pha
                       >            cmp_flag $ff-minus
0c52 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c54 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c56 : 28              >            plp         ;restore status
                        
                                set_a $fe,0
                       >            load_flag 0
0c57 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0c59 : 48              >            pha         ;use stack to load status
0c5a : a9fe            >            lda #$fe     ;precharge accu
0c5c : 28              >            plp
                        
0c5d : 68                       pla
                                tst_a 1,0
0c5e : 08              >            php         ;save flags
0c5f : c901            >            cmp #1     ;test result
                       >            trap_ne
0c61 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c63 : 68              >            pla         ;load status
0c64 : 48              >            pha
                       >            cmp_flag 0
0c65 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c67 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c69 : 28              >            plp         ;restore status
                        
0c6a : e055                     cpx #$55        ;x & y unchanged?
                                trap_ne
0c6c : d0fe            >        bne *           ;failed not equal (non zero)
                        
0c6e : c0aa                     cpy #$aa
                                trap_ne
0c70 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0c72 : ad0002          >            lda test_case   ;previous test
0c75 : c905            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0c77 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0006 =                 >test_num = test_num + 1
0c79 : a906            >            lda #test_num   ;*** next tests' number
0c7b : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; partial pretest EOR #
                                set_a $3c,0
                       >            load_flag 0
0c7e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0c80 : 48              >            pha         ;use stack to load status
0c81 : a93c            >            lda #$3c     ;precharge accu
0c83 : 28              >            plp
                        
0c84 : 49c3                     eor #$c3
                                tst_a $ff,fn
0c86 : 08              >            php         ;save flags
0c87 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c89 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c8b : 68              >            pla         ;load status
0c8c : 48              >            pha
                       >            cmp_flag fn
0c8d : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c8f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c91 : 28              >            plp         ;restore status
                        
                                set_a $c3,0
                       >            load_flag 0
0c92 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0c94 : 48              >            pha         ;use stack to load status
0c95 : a9c3            >            lda #$c3     ;precharge accu
0c97 : 28              >            plp
                        
0c98 : 49c3                     eor #$c3
                                tst_a 0,fz
0c9a : 08              >            php         ;save flags
0c9b : c900            >            cmp #0     ;test result
                       >            trap_ne
0c9d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c9f : 68              >            pla         ;load status
0ca0 : 48              >            pha
                       >            cmp_flag fz
0ca1 : c932            >            cmp #(fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ca3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ca5 : 28              >            plp         ;restore status
                        
                                next_test
0ca6 : ad0002          >            lda test_case   ;previous test
0ca9 : c906            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0cab : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0007 =                 >test_num = test_num + 1
0cad : a907            >            lda #test_num   ;*** next tests' number
0caf : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; PC modifying instructions except branches (NOP, JMP, JSR, RTS, BRK, RTI)
                        ; testing NOP
0cb2 : a224                     ldx #$24
0cb4 : a042                     ldy #$42
                                set_a $18,0
                       >            load_flag 0
0cb6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0cb8 : 48              >            pha         ;use stack to load status
0cb9 : a918            >            lda #$18     ;precharge accu
0cbb : 28              >            plp
                        
0cbc : ea                       nop
                                tst_a $18,0
0cbd : 08              >            php         ;save flags
0cbe : c918            >            cmp #$18     ;test result
                       >            trap_ne
0cc0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cc2 : 68              >            pla         ;load status
0cc3 : 48              >            pha
                       >            cmp_flag 0
0cc4 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cc6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cc8 : 28              >            plp         ;restore status
                        
0cc9 : e024                     cpx #$24
                                trap_ne
0ccb : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ccd : c042                     cpy #$42
                                trap_ne
0ccf : d0fe            >        bne *           ;failed not equal (non zero)
                        
0cd1 : a2db                     ldx #$db
0cd3 : a0bd                     ldy #$bd
                                set_a $e7,$ff
                       >            load_flag $ff
0cd5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0cd7 : 48              >            pha         ;use stack to load status
0cd8 : a9e7            >            lda #$e7     ;precharge accu
0cda : 28              >            plp
                        
0cdb : ea                       nop
                                tst_a $e7,$ff
0cdc : 08              >            php         ;save flags
0cdd : c9e7            >            cmp #$e7     ;test result
                       >            trap_ne
0cdf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ce1 : 68              >            pla         ;load status
0ce2 : 48              >            pha
                       >            cmp_flag $ff
0ce3 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ce5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ce7 : 28              >            plp         ;restore status
                        
0ce8 : e0db                     cpx #$db
                                trap_ne
0cea : d0fe            >        bne *           ;failed not equal (non zero)
                        
0cec : c0bd                     cpy #$bd
                                trap_ne
0cee : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0cf0 : ad0002          >            lda test_case   ;previous test
0cf3 : c907            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0cf5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0008 =                 >test_num = test_num + 1
0cf7 : a908            >            lda #test_num   ;*** next tests' number
0cf9 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; jump absolute
                                set_stat $0
                       >            load_flag $0
0cfc : a900            >            lda #$0             ;allow test to change I-flag (no mask)
                       >
0cfe : 48              >            pha         ;use stack to load status
0cff : 28              >            plp
                        
0d00 : a946                     lda #'F'
0d02 : a241                     ldx #'A'
0d04 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
0d06 : 4cef3a                   jmp test_far
0d09 : ea                       nop
0d0a : ea                       nop
                                trap_ne         ;runover protection
0d0b : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d0d : e8                       inx
0d0e : e8                       inx
0d0f :                  far_ret
                                trap_eq         ;returned flags OK?
0d0f : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
0d11 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
0d13 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0d15 : 50fe            >        bvc *           ;failed overflow clear
                        
0d17 : c9ec                     cmp #('F'^$aa)  ;returned registers OK?
                                trap_ne
0d19 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d1b : e042                     cpx #('A'+1)
                                trap_ne
0d1d : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d1f : c04f                     cpy #('R'-3)
                                trap_ne
0d21 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d23 : ca                       dex
0d24 : c8                       iny
0d25 : c8                       iny
0d26 : c8                       iny
0d27 : 49aa                     eor #$aa        ;N=0, V=1, Z=0, C=1
0d29 : 4c320d                   jmp test_near
0d2c : ea                       nop
0d2d : ea                       nop
                                trap_ne         ;runover protection
0d2e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d30 : e8                       inx
0d31 : e8                       inx
0d32 :                  test_near
                                trap_eq         ;passed flags OK?
0d32 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_mi
0d34 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_cc
0d36 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0d38 : 50fe            >        bvc *           ;failed overflow clear
                        
0d3a : c946                     cmp #'F'        ;passed registers OK?
                                trap_ne
0d3c : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d3e : e041                     cpx #'A'
                                trap_ne
0d40 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d42 : c052                     cpy #'R'
                                trap_ne
0d44 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0d46 : ad0002          >            lda test_case   ;previous test
0d49 : c908            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0d4b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0009 =                 >test_num = test_num + 1
0d4d : a909            >            lda #test_num   ;*** next tests' number
0d4f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; jump indirect
                                set_stat 0
                       >            load_flag 0
0d52 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0d54 : 48              >            pha         ;use stack to load status
0d55 : 28              >            plp
                        
0d56 : a949                     lda #'I'
0d58 : a24e                     ldx #'N'
0d5a : a044                     ldy #'D'        ;N=0, V=0, Z=0, C=0
0d5c : 6c1e3b                   jmp (ptr_tst_ind)
0d5f : ea                       nop
                                trap_ne         ;runover protection
0d60 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d62 : 88                       dey
0d63 : 88                       dey
0d64 :                  ind_ret
0d64 : 08                       php             ;either SP or Y count will fail, if we do not hit
0d65 : 88                       dey
0d66 : 88                       dey
0d67 : 88                       dey
0d68 : 28                       plp
                                trap_eq         ;returned flags OK?
0d69 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
0d6b : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
0d6d : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0d6f : 50fe            >        bvc *           ;failed overflow clear
                        
0d71 : c9e3                     cmp #('I'^$aa)  ;returned registers OK?
                                trap_ne
0d73 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d75 : e04f                     cpx #('N'+1)
                                trap_ne
0d77 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d79 : c03e                     cpy #('D'-6)
                                trap_ne
0d7b : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d7d : ba                       tsx             ;SP check
0d7e : e0ff                     cpx #$ff
                                trap_ne
0d80 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0d82 : ad0002          >            lda test_case   ;previous test
0d85 : c909            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0d87 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000a =                 >test_num = test_num + 1
0d89 : a90a            >            lda #test_num   ;*** next tests' number
0d8b : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; jump subroutine & return from subroutine
                                set_stat 0
                       >            load_flag 0
0d8e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0d90 : 48              >            pha         ;use stack to load status
0d91 : 28              >            plp
                        
0d92 : a94a                     lda #'J'
0d94 : a253                     ldx #'S'
0d96 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
0d98 : 205d3b                   jsr test_jsr
0d9a =                  jsr_ret = *-1           ;last address of jsr = return address
0d9b : 08                       php             ;either SP or Y count will fail, if we do not hit
0d9c : 88                       dey
0d9d : 88                       dey
0d9e : 88                       dey
0d9f : 28                       plp
                                trap_eq         ;returned flags OK?
0da0 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
0da2 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
0da4 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0da6 : 50fe            >        bvc *           ;failed overflow clear
                        
0da8 : c9e0                     cmp #('J'^$aa)  ;returned registers OK?
                                trap_ne
0daa : d0fe            >        bne *           ;failed not equal (non zero)
                        
0dac : e054                     cpx #('S'+1)
                                trap_ne
0dae : d0fe            >        bne *           ;failed not equal (non zero)
                        
0db0 : c04c                     cpy #('R'-6)
                                trap_ne
0db2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0db4 : ba                       tsx             ;sp?
0db5 : e0ff                     cpx #$ff
                                trap_ne
0db7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0db9 : ad0002          >            lda test_case   ;previous test
0dbc : c90a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0dbe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000b =                 >test_num = test_num + 1
0dc0 : a90b            >            lda #test_num   ;*** next tests' number
0dc2 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; break & return from interrupt
                            if ROM_vectors = 1
                                load_flag 0     ;with interrupts enabled if allowed!
0dc5 : a900            >            lda #0                  ;allow test to change I-flag (no mask)
                        
0dc7 : 48                       pha
0dc8 : a942                     lda #'B'
0dca : a252                     ldx #'R'
0dcc : a04b                     ldy #'K'
0dce : 28                       plp             ;N=0, V=0, Z=0, C=0
0dcf : 00                       brk
                            else
                                lda #hi brk_ret0 ;emulated break
                                pha
                                lda #lo brk_ret0
                                pha
                                load_flag fao    ;set break & unused on stack
                                pha
                                load_flag intdis ;during interrupt
                                pha
                                lda #'B'
                                ldx #'R'
                                ldy #'K'
                                plp             ;N=0, V=0, Z=0, C=0
                                jmp irq_trap
                            endif
0dd0 : 88                       dey             ;should not be executed
0dd1 :                  brk_ret0                ;address of break return
0dd1 : 08                       php             ;either SP or Y count will fail, if we do not hit
0dd2 : 88                       dey
0dd3 : 88                       dey
0dd4 : 88                       dey
0dd5 : c9e8                     cmp #'B'^$aa    ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
0dd7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0dd9 : e053                     cpx #'R'+1
                                trap_ne
0ddb : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ddd : c045                     cpy #'K'-6
                                trap_ne
0ddf : d0fe            >        bne *           ;failed not equal (non zero)
                        
0de1 : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag 0
0de2 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0de4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0de6 : ba                       tsx             ;sp?
0de7 : e0ff                     cpx #$ff
                                trap_ne
0de9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                            if ROM_vectors = 1
                                load_flag $ff   ;with interrupts disabled if allowed!
0deb : a9ff            >            lda #$ff                ;allow test to change I-flag (no mask)
                        
0ded : 48                       pha
0dee : a9bd                     lda #$ff-'B'
0df0 : a2ad                     ldx #$ff-'R'
0df2 : a0b4                     ldy #$ff-'K'
0df4 : 28                       plp             ;N=1, V=1, Z=1, C=1
0df5 : 00                       brk
                            else
                                lda #hi brk_ret1 ;emulated break
                                pha
                                lda #lo brk_ret1
                                pha
                                load_flag $ff
                                pha             ;set break & unused on stack
                                pha             ;actual flags
                                lda #$ff-'B'
                                ldx #$ff-'R'
                                ldy #$ff-'K'
                                plp             ;N=1, V=1, Z=1, C=1
                                jmp irq_trap
                            endif
0df6 : 88                       dey             ;should not be executed
0df7 :                  brk_ret1                ;address of break return
0df7 : 08                       php             ;either SP or Y count will fail, if we do not hit
0df8 : 88                       dey
0df9 : 88                       dey
0dfa : 88                       dey
0dfb : c917                     cmp #($ff-'B')^$aa  ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
0dfd : d0fe            >        bne *           ;failed not equal (non zero)
                        
0dff : e0ae                     cpx #$ff-'R'+1
                                trap_ne
0e01 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e03 : c0ae                     cpy #$ff-'K'-6
                                trap_ne
0e05 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e07 : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag $ff
0e08 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0e0a : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e0c : ba                       tsx             ;sp?
0e0d : e0ff                     cpx #$ff
                                trap_ne
0e0f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0e11 : ad0002          >            lda test_case   ;previous test
0e14 : c90b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0e16 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000c =                 >test_num = test_num + 1
0e18 : a90c            >            lda #test_num   ;*** next tests' number
0e1a : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; test set and clear flags CLC CLI CLD CLV SEC SEI SED
                                set_stat $ff
                       >            load_flag $ff
0e1d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0e1f : 48              >            pha         ;use stack to load status
0e20 : 28              >            plp
                        
0e21 : 18                       clc
                                tst_stat $ff-carry
0e22 : 08              >            php         ;save status
0e23 : 68              >            pla         ;use stack to retrieve status
0e24 : 48              >            pha
                       >            cmp_flag $ff-carry
0e25 : c9fe            >            cmp #($ff-carry|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0e27 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e29 : 28              >            plp         ;restore status
                        
0e2a : 38                       sec
                                tst_stat $ff
0e2b : 08              >            php         ;save status
0e2c : 68              >            pla         ;use stack to retrieve status
0e2d : 48              >            pha
                       >            cmp_flag $ff
0e2e : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0e30 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e32 : 28              >            plp         ;restore status
                        
                            if I_flag = 3
0e33 : 58                       cli
                                tst_stat $ff-intdis
0e34 : 08              >            php         ;save status
0e35 : 68              >            pla         ;use stack to retrieve status
0e36 : 48              >            pha
                       >            cmp_flag $ff-intdis
0e37 : c9fb            >            cmp #($ff-intdis|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0e39 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e3b : 28              >            plp         ;restore status
                        
0e3c : 78                       sei
                                tst_stat $ff
0e3d : 08              >            php         ;save status
0e3e : 68              >            pla         ;use stack to retrieve status
0e3f : 48              >            pha
                       >            cmp_flag $ff
0e40 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0e42 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e44 : 28              >            plp         ;restore status
                        
                            endif
0e45 : d8                       cld
                                tst_stat $ff-decmode
0e46 : 08              >            php         ;save status
0e47 : 68              >            pla         ;use stack to retrieve status
0e48 : 48              >            pha
                       >            cmp_flag $ff-decmode
0e49 : c9f7            >            cmp #($ff-decmode|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0e4b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e4d : 28              >            plp         ;restore status
                        
0e4e : f8                       sed
                                tst_stat $ff
0e4f : 08              >            php         ;save status
0e50 : 68              >            pla         ;use stack to retrieve status
0e51 : 48              >            pha
                       >            cmp_flag $ff
0e52 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0e54 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e56 : 28              >            plp         ;restore status
                        
0e57 : b8                       clv
                                tst_stat $ff-overfl
0e58 : 08              >            php         ;save status
0e59 : 68              >            pla         ;use stack to retrieve status
0e5a : 48              >            pha
                       >            cmp_flag $ff-overfl
0e5b : c9bf            >            cmp #($ff-overfl|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0e5d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e5f : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0e60 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0e62 : 48              >            pha         ;use stack to load status
0e63 : 28              >            plp
                        
                                tst_stat 0
0e64 : 08              >            php         ;save status
0e65 : 68              >            pla         ;use stack to retrieve status
0e66 : 48              >            pha
                       >            cmp_flag 0
0e67 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0e69 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e6b : 28              >            plp         ;restore status
                        
0e6c : 38                       sec
                                tst_stat carry
0e6d : 08              >            php         ;save status
0e6e : 68              >            pla         ;use stack to retrieve status
0e6f : 48              >            pha
                       >            cmp_flag carry
0e70 : c931            >            cmp #(carry|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0e72 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e74 : 28              >            plp         ;restore status
                        
0e75 : 18                       clc
                                tst_stat 0
0e76 : 08              >            php         ;save status
0e77 : 68              >            pla         ;use stack to retrieve status
0e78 : 48              >            pha
                       >            cmp_flag 0
0e79 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0e7b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e7d : 28              >            plp         ;restore status
                        
                            if I_flag = 3
0e7e : 78                       sei
                                tst_stat intdis
0e7f : 08              >            php         ;save status
0e80 : 68              >            pla         ;use stack to retrieve status
0e81 : 48              >            pha
                       >            cmp_flag intdis
0e82 : c934            >            cmp #(intdis|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0e84 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e86 : 28              >            plp         ;restore status
                        
0e87 : 58                       cli
                                tst_stat 0
0e88 : 08              >            php         ;save status
0e89 : 68              >            pla         ;use stack to retrieve status
0e8a : 48              >            pha
                       >            cmp_flag 0
0e8b : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0e8d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e8f : 28              >            plp         ;restore status
                        
                            endif
0e90 : f8                       sed
                                tst_stat decmode
0e91 : 08              >            php         ;save status
0e92 : 68              >            pla         ;use stack to retrieve status
0e93 : 48              >            pha
                       >            cmp_flag decmode
0e94 : c938            >            cmp #(decmode|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0e96 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e98 : 28              >            plp         ;restore status
                        
0e99 : d8                       cld
                                tst_stat 0
0e9a : 08              >            php         ;save status
0e9b : 68              >            pla         ;use stack to retrieve status
0e9c : 48              >            pha
                       >            cmp_flag 0
0e9d : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0e9f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ea1 : 28              >            plp         ;restore status
                        
                                set_stat overfl
                       >            load_flag overfl
0ea2 : a940            >            lda #overfl             ;allow test to change I-flag (no mask)
                       >
0ea4 : 48              >            pha         ;use stack to load status
0ea5 : 28              >            plp
                        
                                tst_stat overfl
0ea6 : 08              >            php         ;save status
0ea7 : 68              >            pla         ;use stack to retrieve status
0ea8 : 48              >            pha
                       >            cmp_flag overfl
0ea9 : c970            >            cmp #(overfl|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0eab : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ead : 28              >            plp         ;restore status
                        
0eae : b8                       clv
                                tst_stat 0
0eaf : 08              >            php         ;save status
0eb0 : 68              >            pla         ;use stack to retrieve status
0eb1 : 48              >            pha
                       >            cmp_flag 0
0eb2 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0eb4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0eb6 : 28              >            plp         ;restore status
                        
                                next_test
0eb7 : ad0002          >            lda test_case   ;previous test
0eba : c90c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0ebc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000d =                 >test_num = test_num + 1
0ebe : a90d            >            lda #test_num   ;*** next tests' number
0ec0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ; testing index register increment/decrement and transfer
                        ; INX INY DEX DEY TAX TXA TAY TYA
0ec3 : a2fe                     ldx #$fe
                                set_stat $ff
                       >            load_flag $ff
0ec5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0ec7 : 48              >            pha         ;use stack to load status
0ec8 : 28              >            plp
                        
0ec9 : e8                       inx             ;ff
                                tst_x $ff,$ff-zero
0eca : 08              >            php         ;save flags
0ecb : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0ecd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ecf : 68              >            pla         ;load status
0ed0 : 48              >            pha
                       >            cmp_flag $ff-zero
0ed1 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ed3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ed5 : 28              >            plp         ;restore status
                        
0ed6 : e8                       inx             ;00
                                tst_x 0,$ff-minus
0ed7 : 08              >            php         ;save flags
0ed8 : e000            >            cpx #0     ;test result
                       >            trap_ne
0eda : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0edc : 68              >            pla         ;load status
0edd : 48              >            pha
                       >            cmp_flag $ff-minus
0ede : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ee0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ee2 : 28              >            plp         ;restore status
                        
0ee3 : e8                       inx             ;01
                                tst_x 1,$ff-minus-zero
0ee4 : 08              >            php         ;save flags
0ee5 : e001            >            cpx #1     ;test result
                       >            trap_ne
0ee7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ee9 : 68              >            pla         ;load status
0eea : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0eeb : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0eed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0eef : 28              >            plp         ;restore status
                        
0ef0 : ca                       dex             ;00
                                tst_x 0,$ff-minus
0ef1 : 08              >            php         ;save flags
0ef2 : e000            >            cpx #0     ;test result
                       >            trap_ne
0ef4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ef6 : 68              >            pla         ;load status
0ef7 : 48              >            pha
                       >            cmp_flag $ff-minus
0ef8 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0efa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0efc : 28              >            plp         ;restore status
                        
0efd : ca                       dex             ;ff
                                tst_x $ff,$ff-zero
0efe : 08              >            php         ;save flags
0eff : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0f01 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f03 : 68              >            pla         ;load status
0f04 : 48              >            pha
                       >            cmp_flag $ff-zero
0f05 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0f07 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f09 : 28              >            plp         ;restore status
                        
0f0a : ca                       dex             ;fe
                                set_stat 0
                       >            load_flag 0
0f0b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0f0d : 48              >            pha         ;use stack to load status
0f0e : 28              >            plp
                        
0f0f : e8                       inx             ;ff
                                tst_x $ff,minus
0f10 : 08              >            php         ;save flags
0f11 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0f13 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f15 : 68              >            pla         ;load status
0f16 : 48              >            pha
                       >            cmp_flag minus
0f17 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0f19 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f1b : 28              >            plp         ;restore status
                        
0f1c : e8                       inx             ;00
                                tst_x 0,zero
0f1d : 08              >            php         ;save flags
0f1e : e000            >            cpx #0     ;test result
                       >            trap_ne
0f20 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f22 : 68              >            pla         ;load status
0f23 : 48              >            pha
                       >            cmp_flag zero
0f24 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0f26 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f28 : 28              >            plp         ;restore status
                        
0f29 : e8                       inx             ;01
                                tst_x 1,0
0f2a : 08              >            php         ;save flags
0f2b : e001            >            cpx #1     ;test result
                       >            trap_ne
0f2d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f2f : 68              >            pla         ;load status
0f30 : 48              >            pha
                       >            cmp_flag 0
0f31 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0f33 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f35 : 28              >            plp         ;restore status
                        
0f36 : ca                       dex             ;00
                                tst_x 0,zero
0f37 : 08              >            php         ;save flags
0f38 : e000            >            cpx #0     ;test result
                       >            trap_ne
0f3a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f3c : 68              >            pla         ;load status
0f3d : 48              >            pha
                       >            cmp_flag zero
0f3e : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0f40 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f42 : 28              >            plp         ;restore status
                        
0f43 : ca                       dex             ;ff
                                tst_x $ff,minus
0f44 : 08              >            php         ;save flags
0f45 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0f47 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f49 : 68              >            pla         ;load status
0f4a : 48              >            pha
                       >            cmp_flag minus
0f4b : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0f4d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f4f : 28              >            plp         ;restore status
                        
                        
0f50 : a0fe                     ldy #$fe
                                set_stat $ff
                       >            load_flag $ff
0f52 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0f54 : 48              >            pha         ;use stack to load status
0f55 : 28              >            plp
                        
0f56 : c8                       iny             ;ff
                                tst_y $ff,$ff-zero
0f57 : 08              >            php         ;save flags
0f58 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0f5a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f5c : 68              >            pla         ;load status
0f5d : 48              >            pha
                       >            cmp_flag $ff-zero
0f5e : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0f60 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f62 : 28              >            plp         ;restore status
                        
0f63 : c8                       iny             ;00
                                tst_y 0,$ff-minus
0f64 : 08              >            php         ;save flags
0f65 : c000            >            cpy #0     ;test result
                       >            trap_ne
0f67 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f69 : 68              >            pla         ;load status
0f6a : 48              >            pha
                       >            cmp_flag $ff-minus
0f6b : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0f6d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f6f : 28              >            plp         ;restore status
                        
0f70 : c8                       iny             ;01
                                tst_y 1,$ff-minus-zero
0f71 : 08              >            php         ;save flags
0f72 : c001            >            cpy #1     ;test result
                       >            trap_ne
0f74 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f76 : 68              >            pla         ;load status
0f77 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0f78 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0f7a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f7c : 28              >            plp         ;restore status
                        
0f7d : 88                       dey             ;00
                                tst_y 0,$ff-minus
0f7e : 08              >            php         ;save flags
0f7f : c000            >            cpy #0     ;test result
                       >            trap_ne
0f81 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f83 : 68              >            pla         ;load status
0f84 : 48              >            pha
                       >            cmp_flag $ff-minus
0f85 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0f87 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f89 : 28              >            plp         ;restore status
                        
0f8a : 88                       dey             ;ff
                                tst_y $ff,$ff-zero
0f8b : 08              >            php         ;save flags
0f8c : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0f8e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f90 : 68              >            pla         ;load status
0f91 : 48              >            pha
                       >            cmp_flag $ff-zero
0f92 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0f94 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f96 : 28              >            plp         ;restore status
                        
0f97 : 88                       dey             ;fe
                                set_stat 0
                       >            load_flag 0
0f98 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0f9a : 48              >            pha         ;use stack to load status
0f9b : 28              >            plp
                        
0f9c : c8                       iny             ;ff
                                tst_y $ff,0+minus
0f9d : 08              >            php         ;save flags
0f9e : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0fa0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0fa2 : 68              >            pla         ;load status
0fa3 : 48              >            pha
                       >            cmp_flag 0+minus
0fa4 : c9b0            >            cmp #(0+minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0fa6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0fa8 : 28              >            plp         ;restore status
                        
0fa9 : c8                       iny             ;00
                                tst_y 0,zero
0faa : 08              >            php         ;save flags
0fab : c000            >            cpy #0     ;test result
                       >            trap_ne
0fad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0faf : 68              >            pla         ;load status
0fb0 : 48              >            pha
                       >            cmp_flag zero
0fb1 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0fb3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0fb5 : 28              >            plp         ;restore status
                        
0fb6 : c8                       iny             ;01
                                tst_y 1,0
0fb7 : 08              >            php         ;save flags
0fb8 : c001            >            cpy #1     ;test result
                       >            trap_ne
0fba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0fbc : 68              >            pla         ;load status
0fbd : 48              >            pha
                       >            cmp_flag 0
0fbe : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0fc0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0fc2 : 28              >            plp         ;restore status
                        
0fc3 : 88                       dey             ;00
                                tst_y 0,zero
0fc4 : 08              >            php         ;save flags
0fc5 : c000            >            cpy #0     ;test result
                       >            trap_ne
0fc7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0fc9 : 68              >            pla         ;load status
0fca : 48              >            pha
                       >            cmp_flag zero
0fcb : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0fcd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0fcf : 28              >            plp         ;restore status
                        
0fd0 : 88                       dey             ;ff
                                tst_y $ff,minus
0fd1 : 08              >            php         ;save flags
0fd2 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0fd4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0fd6 : 68              >            pla         ;load status
0fd7 : 48              >            pha
                       >            cmp_flag minus
0fd8 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0fda : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0fdc : 28              >            plp         ;restore status
                        
                        
0fdd : a2ff                     ldx #$ff
                                set_stat $ff
                       >            load_flag $ff
0fdf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0fe1 : 48              >            pha         ;use stack to load status
0fe2 : 28              >            plp
                        
0fe3 : 8a                       txa
                                tst_a $ff,$ff-zero
0fe4 : 08              >            php         ;save flags
0fe5 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0fe7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0fe9 : 68              >            pla         ;load status
0fea : 48              >            pha
                       >            cmp_flag $ff-zero
0feb : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0fed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0fef : 28              >            plp         ;restore status
                        
0ff0 : 08                       php
0ff1 : e8                       inx             ;00
0ff2 : 28                       plp
0ff3 : 8a                       txa
                                tst_a 0,$ff-minus
0ff4 : 08              >            php         ;save flags
0ff5 : c900            >            cmp #0     ;test result
                       >            trap_ne
0ff7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ff9 : 68              >            pla         ;load status
0ffa : 48              >            pha
                       >            cmp_flag $ff-minus
0ffb : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ffd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0fff : 28              >            plp         ;restore status
                        
1000 : 08                       php
1001 : e8                       inx             ;01
1002 : 28                       plp
1003 : 8a                       txa
                                tst_a 1,$ff-minus-zero
1004 : 08              >            php         ;save flags
1005 : c901            >            cmp #1     ;test result
                       >            trap_ne
1007 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1009 : 68              >            pla         ;load status
100a : 48              >            pha
                       >            cmp_flag $ff-minus-zero
100b : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
100d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
100f : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
1010 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1012 : 48              >            pha         ;use stack to load status
1013 : 28              >            plp
                        
1014 : 8a                       txa
                                tst_a 1,0
1015 : 08              >            php         ;save flags
1016 : c901            >            cmp #1     ;test result
                       >            trap_ne
1018 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
101a : 68              >            pla         ;load status
101b : 48              >            pha
                       >            cmp_flag 0
101c : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
101e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1020 : 28              >            plp         ;restore status
                        
1021 : 08                       php
1022 : ca                       dex             ;00
1023 : 28                       plp
1024 : 8a                       txa
                                tst_a 0,zero
1025 : 08              >            php         ;save flags
1026 : c900            >            cmp #0     ;test result
                       >            trap_ne
1028 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
102a : 68              >            pla         ;load status
102b : 48              >            pha
                       >            cmp_flag zero
102c : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
102e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1030 : 28              >            plp         ;restore status
                        
1031 : 08                       php
1032 : ca                       dex             ;ff
1033 : 28                       plp
1034 : 8a                       txa
                                tst_a $ff,minus
1035 : 08              >            php         ;save flags
1036 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1038 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
103a : 68              >            pla         ;load status
103b : 48              >            pha
                       >            cmp_flag minus
103c : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
103e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1040 : 28              >            plp         ;restore status
                        
                        
1041 : a0ff                     ldy #$ff
                                set_stat $ff
                       >            load_flag $ff
1043 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1045 : 48              >            pha         ;use stack to load status
1046 : 28              >            plp
                        
1047 : 98                       tya
                                tst_a $ff,$ff-zero
1048 : 08              >            php         ;save flags
1049 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
104b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
104d : 68              >            pla         ;load status
104e : 48              >            pha
                       >            cmp_flag $ff-zero
104f : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1051 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1053 : 28              >            plp         ;restore status
                        
1054 : 08                       php
1055 : c8                       iny             ;00
1056 : 28                       plp
1057 : 98                       tya
                                tst_a 0,$ff-minus
1058 : 08              >            php         ;save flags
1059 : c900            >            cmp #0     ;test result
                       >            trap_ne
105b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
105d : 68              >            pla         ;load status
105e : 48              >            pha
                       >            cmp_flag $ff-minus
105f : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1061 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1063 : 28              >            plp         ;restore status
                        
1064 : 08                       php
1065 : c8                       iny             ;01
1066 : 28                       plp
1067 : 98                       tya
                                tst_a 1,$ff-minus-zero
1068 : 08              >            php         ;save flags
1069 : c901            >            cmp #1     ;test result
                       >            trap_ne
106b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
106d : 68              >            pla         ;load status
106e : 48              >            pha
                       >            cmp_flag $ff-minus-zero
106f : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1071 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1073 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
1074 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1076 : 48              >            pha         ;use stack to load status
1077 : 28              >            plp
                        
1078 : 98                       tya
                                tst_a 1,0
1079 : 08              >            php         ;save flags
107a : c901            >            cmp #1     ;test result
                       >            trap_ne
107c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
107e : 68              >            pla         ;load status
107f : 48              >            pha
                       >            cmp_flag 0
1080 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1082 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1084 : 28              >            plp         ;restore status
                        
1085 : 08                       php
1086 : 88                       dey             ;00
1087 : 28                       plp
1088 : 98                       tya
                                tst_a 0,zero
1089 : 08              >            php         ;save flags
108a : c900            >            cmp #0     ;test result
                       >            trap_ne
108c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
108e : 68              >            pla         ;load status
108f : 48              >            pha
                       >            cmp_flag zero
1090 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1092 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1094 : 28              >            plp         ;restore status
                        
1095 : 08                       php
1096 : 88                       dey             ;ff
1097 : 28                       plp
1098 : 98                       tya
                                tst_a $ff,minus
1099 : 08              >            php         ;save flags
109a : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
109c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
109e : 68              >            pla         ;load status
109f : 48              >            pha
                       >            cmp_flag minus
10a0 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
10a2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
10a4 : 28              >            plp         ;restore status
                        
                        
                                load_flag $ff
10a5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
10a7 : 48                       pha
10a8 : a2ff                     ldx #$ff        ;ff
10aa : 8a                       txa
10ab : 28                       plp
10ac : a8                       tay
                                tst_y $ff,$ff-zero
10ad : 08              >            php         ;save flags
10ae : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
10b0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
10b2 : 68              >            pla         ;load status
10b3 : 48              >            pha
                       >            cmp_flag $ff-zero
10b4 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
10b6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
10b8 : 28              >            plp         ;restore status
                        
10b9 : 08                       php
10ba : e8                       inx             ;00
10bb : 8a                       txa
10bc : 28                       plp
10bd : a8                       tay
                                tst_y 0,$ff-minus
10be : 08              >            php         ;save flags
10bf : c000            >            cpy #0     ;test result
                       >            trap_ne
10c1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
10c3 : 68              >            pla         ;load status
10c4 : 48              >            pha
                       >            cmp_flag $ff-minus
10c5 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
10c7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
10c9 : 28              >            plp         ;restore status
                        
10ca : 08                       php
10cb : e8                       inx             ;01
10cc : 8a                       txa
10cd : 28                       plp
10ce : a8                       tay
                                tst_y 1,$ff-minus-zero
10cf : 08              >            php         ;save flags
10d0 : c001            >            cpy #1     ;test result
                       >            trap_ne
10d2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
10d4 : 68              >            pla         ;load status
10d5 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
10d6 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
10d8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
10da : 28              >            plp         ;restore status
                        
                                load_flag 0
10db : a900            >            lda #0             ;allow test to change I-flag (no mask)
                        
10dd : 48                       pha
10de : a900                     lda #0
10e0 : 8a                       txa
10e1 : 28                       plp
10e2 : a8                       tay
                                tst_y 1,0
10e3 : 08              >            php         ;save flags
10e4 : c001            >            cpy #1     ;test result
                       >            trap_ne
10e6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
10e8 : 68              >            pla         ;load status
10e9 : 48              >            pha
                       >            cmp_flag 0
10ea : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
10ec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
10ee : 28              >            plp         ;restore status
                        
10ef : 08                       php
10f0 : ca                       dex             ;00
10f1 : 8a                       txa
10f2 : 28                       plp
10f3 : a8                       tay
                                tst_y 0,zero
10f4 : 08              >            php         ;save flags
10f5 : c000            >            cpy #0     ;test result
                       >            trap_ne
10f7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
10f9 : 68              >            pla         ;load status
10fa : 48              >            pha
                       >            cmp_flag zero
10fb : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
10fd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
10ff : 28              >            plp         ;restore status
                        
1100 : 08                       php
1101 : ca                       dex             ;ff
1102 : 8a                       txa
1103 : 28                       plp
1104 : a8                       tay
                                tst_y $ff,minus
1105 : 08              >            php         ;save flags
1106 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
1108 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
110a : 68              >            pla         ;load status
110b : 48              >            pha
                       >            cmp_flag minus
110c : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
110e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1110 : 28              >            plp         ;restore status
                        
                        
                        
                                load_flag $ff
1111 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
1113 : 48                       pha
1114 : a0ff                     ldy #$ff        ;ff
1116 : 98                       tya
1117 : 28                       plp
1118 : aa                       tax
                                tst_x $ff,$ff-zero
1119 : 08              >            php         ;save flags
111a : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
111c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
111e : 68              >            pla         ;load status
111f : 48              >            pha
                       >            cmp_flag $ff-zero
1120 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1122 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1124 : 28              >            plp         ;restore status
                        
1125 : 08                       php
1126 : c8                       iny             ;00
1127 : 98                       tya
1128 : 28                       plp
1129 : aa                       tax
                                tst_x 0,$ff-minus
112a : 08              >            php         ;save flags
112b : e000            >            cpx #0     ;test result
                       >            trap_ne
112d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
112f : 68              >            pla         ;load status
1130 : 48              >            pha
                       >            cmp_flag $ff-minus
1131 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1133 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1135 : 28              >            plp         ;restore status
                        
1136 : 08                       php
1137 : c8                       iny             ;01
1138 : 98                       tya
1139 : 28                       plp
113a : aa                       tax
                                tst_x 1,$ff-minus-zero
113b : 08              >            php         ;save flags
113c : e001            >            cpx #1     ;test result
                       >            trap_ne
113e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1140 : 68              >            pla         ;load status
1141 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
1142 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1144 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1146 : 28              >            plp         ;restore status
                        
                                load_flag 0
1147 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                        
1149 : 48                       pha
114a : a900                     lda #0          ;preset status
114c : 98                       tya
114d : 28                       plp
114e : aa                       tax
                                tst_x 1,0
114f : 08              >            php         ;save flags
1150 : e001            >            cpx #1     ;test result
                       >            trap_ne
1152 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1154 : 68              >            pla         ;load status
1155 : 48              >            pha
                       >            cmp_flag 0
1156 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1158 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
115a : 28              >            plp         ;restore status
                        
115b : 08                       php
115c : 88                       dey             ;00
115d : 98                       tya
115e : 28                       plp
115f : aa                       tax
                                tst_x 0,zero
1160 : 08              >            php         ;save flags
1161 : e000            >            cpx #0     ;test result
                       >            trap_ne
1163 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1165 : 68              >            pla         ;load status
1166 : 48              >            pha
                       >            cmp_flag zero
1167 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1169 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
116b : 28              >            plp         ;restore status
                        
116c : 08                       php
116d : 88                       dey             ;ff
116e : 98                       tya
116f : 28                       plp
1170 : aa                       tax
                                tst_x $ff,minus
1171 : 08              >            php         ;save flags
1172 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
1174 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1176 : 68              >            pla         ;load status
1177 : 48              >            pha
                       >            cmp_flag minus
1178 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
117a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
117c : 28              >            plp         ;restore status
                        
                                next_test
117d : ad0002          >            lda test_case   ;previous test
1180 : c90d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1182 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000e =                 >test_num = test_num + 1
1184 : a90e            >            lda #test_num   ;*** next tests' number
1186 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;TSX sets NZ - TXS does not
                        ;  This section also tests for proper stack wrap around.
1189 : a201                     ldx #1          ;01
                                set_stat $ff
                       >            load_flag $ff
118b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
118d : 48              >            pha         ;use stack to load status
118e : 28              >            plp
                        
118f : 9a                       txs
1190 : 08                       php
1191 : ad0101                   lda $101
                                cmp_flag $ff
1194 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
1196 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1198 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
119a : 48              >            pha         ;use stack to load status
119b : 28              >            plp
                        
119c : 9a                       txs
119d : 08                       php
119e : ad0101                   lda $101
                                cmp_flag 0
11a1 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
11a3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11a5 : ca                       dex             ;00
                                set_stat $ff
                       >            load_flag $ff
11a6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
11a8 : 48              >            pha         ;use stack to load status
11a9 : 28              >            plp
                        
11aa : 9a                       txs
11ab : 08                       php
11ac : ad0001                   lda $100
                                cmp_flag $ff
11af : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
11b1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
11b3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
11b5 : 48              >            pha         ;use stack to load status
11b6 : 28              >            plp
                        
11b7 : 9a                       txs
11b8 : 08                       php
11b9 : ad0001                   lda $100
                                cmp_flag 0
11bc : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
11be : d0fe            >        bne *           ;failed not equal (non zero)
                        
11c0 : ca                       dex             ;ff
                                set_stat $ff
                       >            load_flag $ff
11c1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
11c3 : 48              >            pha         ;use stack to load status
11c4 : 28              >            plp
                        
11c5 : 9a                       txs
11c6 : 08                       php
11c7 : adff01                   lda $1ff
                                cmp_flag $ff
11ca : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
11cc : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
11ce : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
11d0 : 48              >            pha         ;use stack to load status
11d1 : 28              >            plp
                        
11d2 : 9a                       txs
11d3 : 08                       php
11d4 : adff01                   lda $1ff
                                cmp_flag 0
11d7 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                        
11d9 : a201                     ldx #1
11db : 9a                       txs             ;sp=01
                                set_stat $ff
                       >            load_flag $ff
11dc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
11de : 48              >            pha         ;use stack to load status
11df : 28              >            plp
                        
11e0 : ba                       tsx             ;clears Z, N
11e1 : 08                       php             ;sp=00
11e2 : e001                     cpx #1
                                trap_ne
11e4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11e6 : ad0101                   lda $101
                                cmp_flag $ff-minus-zero
11e9 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
11eb : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
11ed : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
11ef : 48              >            pha         ;use stack to load status
11f0 : 28              >            plp
                        
11f1 : ba                       tsx             ;clears N, sets Z
11f2 : 08                       php             ;sp=ff
11f3 : e000                     cpx #0
                                trap_ne
11f5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11f7 : ad0001                   lda $100
                                cmp_flag $ff-minus
11fa : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
11fc : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
11fe : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1200 : 48              >            pha         ;use stack to load status
1201 : 28              >            plp
                        
1202 : ba                       tsx             ;clears N, sets Z
1203 : 08                       php             ;sp=fe
1204 : e0ff                     cpx #$ff
                                trap_ne
1206 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1208 : adff01                   lda $1ff
                                cmp_flag $ff-zero
120b : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
120d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
120f : a201                     ldx #1
1211 : 9a                       txs             ;sp=01
                                set_stat 0
                       >            load_flag 0
1212 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1214 : 48              >            pha         ;use stack to load status
1215 : 28              >            plp
                        
1216 : ba                       tsx             ;clears Z, N
1217 : 08                       php             ;sp=00
1218 : e001                     cpx #1
                                trap_ne
121a : d0fe            >        bne *           ;failed not equal (non zero)
                        
121c : ad0101                   lda $101
                                cmp_flag 0
121f : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
1221 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1223 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1225 : 48              >            pha         ;use stack to load status
1226 : 28              >            plp
                        
1227 : ba                       tsx             ;clears N, sets Z
1228 : 08                       php             ;sp=ff
1229 : e000                     cpx #0
                                trap_ne
122b : d0fe            >        bne *           ;failed not equal (non zero)
                        
122d : ad0001                   lda $100
                                cmp_flag zero
1230 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
1232 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1234 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1236 : 48              >            pha         ;use stack to load status
1237 : 28              >            plp
                        
1238 : ba                       tsx             ;clears N, sets Z
1239 : 08                       php             ;sp=fe
123a : e0ff                     cpx #$ff
                                trap_ne
123c : d0fe            >        bne *           ;failed not equal (non zero)
                        
123e : adff01                   lda $1ff
                                cmp_flag minus
1241 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
1243 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1245 : 68                       pla             ;sp=ff
                                next_test
1246 : ad0002          >            lda test_case   ;previous test
1249 : c90e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
124b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000f =                 >test_num = test_num + 1
124d : a90f            >            lda #test_num   ;*** next tests' number
124f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing index register load & store LDY LDX STY STX all addressing modes
                        ; LDX / STX - zp,y / abs,y
1252 : a003                     ldy #3
1254 :                  tldx
                                set_stat 0
                       >            load_flag 0
1254 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1256 : 48              >            pha         ;use stack to load status
1257 : 28              >            plp
                        
1258 : b609                     ldx zp1,y
125a : 08                       php         ;test stores do not alter flags
125b : 8a                       txa
125c : 49c3                     eor #$c3
125e : 28                       plp
125f : 990302                   sta abst,y
1262 : 08                       php         ;flags after load/store sequence
1263 : 49c3                     eor #$c3
1265 : d91702                   cmp abs1,y  ;test result
                                trap_ne
1268 : d0fe            >        bne *           ;failed not equal (non zero)
                        
126a : 68                       pla         ;load status
                                eor_flag 0
126b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
126d : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
1270 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1272 : 88                       dey
1273 : 10df                     bpl tldx
                        
1275 : a003                     ldy #3
1277 :                  tldx1
                                set_stat $ff
                       >            load_flag $ff
1277 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1279 : 48              >            pha         ;use stack to load status
127a : 28              >            plp
                        
127b : b609                     ldx zp1,y
127d : 08                       php         ;test stores do not alter flags
127e : 8a                       txa
127f : 49c3                     eor #$c3
1281 : 28                       plp
1282 : 990302                   sta abst,y
1285 : 08                       php         ;flags after load/store sequence
1286 : 49c3                     eor #$c3
1288 : d91702                   cmp abs1,y  ;test result
                                trap_ne
128b : d0fe            >        bne *           ;failed not equal (non zero)
                        
128d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
128e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1290 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
1293 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1295 : 88                       dey
1296 : 10df                     bpl tldx1
                        
1298 : a003                     ldy #3
129a :                  tldx2
                                set_stat 0
                       >            load_flag 0
129a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
129c : 48              >            pha         ;use stack to load status
129d : 28              >            plp
                        
129e : be1702                   ldx abs1,y
12a1 : 08                       php         ;test stores do not alter flags
12a2 : 8a                       txa
12a3 : 49c3                     eor #$c3
12a5 : aa                       tax
12a6 : 28                       plp
12a7 : 9602                     stx zpt,y
12a9 : 08                       php         ;flags after load/store sequence
12aa : 49c3                     eor #$c3
12ac : d90900                   cmp zp1,y   ;test result
                                trap_ne
12af : d0fe            >        bne *           ;failed not equal (non zero)
                        
12b1 : 68                       pla         ;load status
                                eor_flag 0
12b2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
12b4 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
12b7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12b9 : 88                       dey
12ba : 10de                     bpl tldx2
                        
12bc : a003                     ldy #3
12be :                  tldx3
                                set_stat $ff
                       >            load_flag $ff
12be : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
12c0 : 48              >            pha         ;use stack to load status
12c1 : 28              >            plp
                        
12c2 : be1702                   ldx abs1,y
12c5 : 08                       php         ;test stores do not alter flags
12c6 : 8a                       txa
12c7 : 49c3                     eor #$c3
12c9 : aa                       tax
12ca : 28                       plp
12cb : 9602                     stx zpt,y
12cd : 08                       php         ;flags after load/store sequence
12ce : 49c3                     eor #$c3
12d0 : d90900                   cmp zp1,y   ;test result
                                trap_ne
12d3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12d5 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
12d6 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
12d8 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
12db : d0fe            >        bne *           ;failed not equal (non zero)
                        
12dd : 88                       dey
12de : 10de                     bpl tldx3
                        
12e0 : a003                     ldy #3      ;testing store result
12e2 : a200                     ldx #0
12e4 : b90200           tstx    lda zpt,y
12e7 : 49c3                     eor #$c3
12e9 : d90900                   cmp zp1,y
                                trap_ne     ;store to zp data
12ec : d0fe            >        bne *           ;failed not equal (non zero)
                        
12ee : 9602                     stx zpt,y   ;clear
12f0 : b90302                   lda abst,y
12f3 : 49c3                     eor #$c3
12f5 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
12f8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12fa : 8a                       txa
12fb : 990302                   sta abst,y  ;clear
12fe : 88                       dey
12ff : 10e3                     bpl tstx
                                next_test
1301 : ad0002          >            lda test_case   ;previous test
1304 : c90f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1306 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0010 =                 >test_num = test_num + 1
1308 : a910            >            lda #test_num   ;*** next tests' number
130a : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
130d : a0fd                     ldy #3+$fa
130f : b60f             tldx4   ldx zp1-$fa&$ff,y   ;wrap on indexed zp
1311 : 8a                       txa
1312 : 990901                   sta abst-$fa,y      ;no STX abs,y!
1315 : 88                       dey
1316 : c0fa                     cpy #$fa
1318 : b0f5                     bcs tldx4
131a : a0fd                     ldy #3+$fa
131c : be1d01           tldx5   ldx abs1-$fa,y      ;no wrap on indexed abs
131f : 9608                     stx zpt-$fa&$ff,y
1321 : 88                       dey
1322 : c0fa                     cpy #$fa
1324 : b0f6                     bcs tldx5
1326 : a003                     ldy #3      ;testing wraparound result
1328 : a200                     ldx #0
132a : b90200           tstx1   lda zpt,y
132d : d90900                   cmp zp1,y
                                trap_ne     ;store to zp data
1330 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1332 : 9602                     stx zpt,y   ;clear
1334 : b90302                   lda abst,y
1337 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
133a : d0fe            >        bne *           ;failed not equal (non zero)
                        
133c : 8a                       txa
133d : 990302                   sta abst,y  ;clear
1340 : 88                       dey
1341 : 10e7                     bpl tstx1
                                next_test
1343 : ad0002          >            lda test_case   ;previous test
1346 : c910            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1348 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0011 =                 >test_num = test_num + 1
134a : a911            >            lda #test_num   ;*** next tests' number
134c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDY / STY - zp,x / abs,x
134f : a203                     ldx #3
1351 :                  tldy
                                set_stat 0
                       >            load_flag 0
1351 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1353 : 48              >            pha         ;use stack to load status
1354 : 28              >            plp
                        
1355 : b409                     ldy zp1,x
1357 : 08                       php         ;test stores do not alter flags
1358 : 98                       tya
1359 : 49c3                     eor #$c3
135b : 28                       plp
135c : 9d0302                   sta abst,x
135f : 08                       php         ;flags after load/store sequence
1360 : 49c3                     eor #$c3
1362 : dd1702                   cmp abs1,x  ;test result
                                trap_ne
1365 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1367 : 68                       pla         ;load status
                                eor_flag 0
1368 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
136a : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
136d : d0fe            >        bne *           ;failed not equal (non zero)
                        
136f : ca                       dex
1370 : 10df                     bpl tldy
                        
1372 : a203                     ldx #3
1374 :                  tldy1
                                set_stat $ff
                       >            load_flag $ff
1374 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1376 : 48              >            pha         ;use stack to load status
1377 : 28              >            plp
                        
1378 : b409                     ldy zp1,x
137a : 08                       php         ;test stores do not alter flags
137b : 98                       tya
137c : 49c3                     eor #$c3
137e : 28                       plp
137f : 9d0302                   sta abst,x
1382 : 08                       php         ;flags after load/store sequence
1383 : 49c3                     eor #$c3
1385 : dd1702                   cmp abs1,x  ;test result
                                trap_ne
1388 : d0fe            >        bne *           ;failed not equal (non zero)
                        
138a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
138b : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
138d : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
1390 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1392 : ca                       dex
1393 : 10df                     bpl tldy1
                        
1395 : a203                     ldx #3
1397 :                  tldy2
                                set_stat 0
                       >            load_flag 0
1397 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1399 : 48              >            pha         ;use stack to load status
139a : 28              >            plp
                        
139b : bc1702                   ldy abs1,x
139e : 08                       php         ;test stores do not alter flags
139f : 98                       tya
13a0 : 49c3                     eor #$c3
13a2 : a8                       tay
13a3 : 28                       plp
13a4 : 9402                     sty zpt,x
13a6 : 08                       php         ;flags after load/store sequence
13a7 : 49c3                     eor #$c3
13a9 : d509                     cmp zp1,x   ;test result
                                trap_ne
13ab : d0fe            >        bne *           ;failed not equal (non zero)
                        
13ad : 68                       pla         ;load status
                                eor_flag 0
13ae : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
13b0 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
13b3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13b5 : ca                       dex
13b6 : 10df                     bpl tldy2
                        
13b8 : a203                     ldx #3
13ba :                  tldy3
                                set_stat $ff
                       >            load_flag $ff
13ba : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
13bc : 48              >            pha         ;use stack to load status
13bd : 28              >            plp
                        
13be : bc1702                   ldy abs1,x
13c1 : 08                       php         ;test stores do not alter flags
13c2 : 98                       tya
13c3 : 49c3                     eor #$c3
13c5 : a8                       tay
13c6 : 28                       plp
13c7 : 9402                     sty zpt,x
13c9 : 08                       php         ;flags after load/store sequence
13ca : 49c3                     eor #$c3
13cc : d509                     cmp zp1,x   ;test result
                                trap_ne
13ce : d0fe            >        bne *           ;failed not equal (non zero)
                        
13d0 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
13d1 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
13d3 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
13d6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13d8 : ca                       dex
13d9 : 10df                     bpl tldy3
                        
13db : a203                     ldx #3      ;testing store result
13dd : a000                     ldy #0
13df : b502             tsty    lda zpt,x
13e1 : 49c3                     eor #$c3
13e3 : d509                     cmp zp1,x
                                trap_ne     ;store to zp,x data
13e5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13e7 : 9402                     sty zpt,x   ;clear
13e9 : bd0302                   lda abst,x
13ec : 49c3                     eor #$c3
13ee : dd1702                   cmp abs1,x
                                trap_ne     ;store to abs,x data
13f1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13f3 : 8a                       txa
13f4 : 9d0302                   sta abst,x  ;clear
13f7 : ca                       dex
13f8 : 10e5                     bpl tsty
                                next_test
13fa : ad0002          >            lda test_case   ;previous test
13fd : c911            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
13ff : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0012 =                 >test_num = test_num + 1
1401 : a912            >            lda #test_num   ;*** next tests' number
1403 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
1406 : a2fd                     ldx #3+$fa
1408 : b40f             tldy4   ldy zp1-$fa&$ff,x   ;wrap on indexed zp
140a : 98                       tya
140b : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
140e : ca                       dex
140f : e0fa                     cpx #$fa
1411 : b0f5                     bcs tldy4
1413 : a2fd                     ldx #3+$fa
1415 : bc1d01           tldy5   ldy abs1-$fa,x      ;no wrap on indexed abs
1418 : 9408                     sty zpt-$fa&$ff,x
141a : ca                       dex
141b : e0fa                     cpx #$fa
141d : b0f6                     bcs tldy5
141f : a203                     ldx #3      ;testing wraparound result
1421 : a000                     ldy #0
1423 : b502             tsty1   lda zpt,x
1425 : d509                     cmp zp1,x
                                trap_ne     ;store to zp,x data
1427 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1429 : 9402                     sty zpt,x   ;clear
142b : bd0302                   lda abst,x
142e : dd1702                   cmp abs1,x
                                trap_ne     ;store to abs,x data
1431 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1433 : 8a                       txa
1434 : 9d0302                   sta abst,x  ;clear
1437 : ca                       dex
1438 : 10e9                     bpl tsty1
                                next_test
143a : ad0002          >            lda test_case   ;previous test
143d : c912            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
143f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0013 =                 >test_num = test_num + 1
1441 : a913            >            lda #test_num   ;*** next tests' number
1443 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDX / STX - zp / abs / #
                                set_stat 0
                       >            load_flag 0
1446 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1448 : 48              >            pha         ;use stack to load status
1449 : 28              >            plp
                        
144a : a609                     ldx zp1
144c : 08                       php         ;test stores do not alter flags
144d : 8a                       txa
144e : 49c3                     eor #$c3
1450 : aa                       tax
1451 : 28                       plp
1452 : 8e0302                   stx abst
1455 : 08                       php         ;flags after load/store sequence
1456 : 49c3                     eor #$c3
1458 : aa                       tax
1459 : e0c3                     cpx #$c3    ;test result
                                trap_ne
145b : d0fe            >        bne *           ;failed not equal (non zero)
                        
145d : 68                       pla         ;load status
                                eor_flag 0
145e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1460 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1463 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1465 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1467 : 48              >            pha         ;use stack to load status
1468 : 28              >            plp
                        
1469 : a60a                     ldx zp1+1
146b : 08                       php         ;test stores do not alter flags
146c : 8a                       txa
146d : 49c3                     eor #$c3
146f : aa                       tax
1470 : 28                       plp
1471 : 8e0402                   stx abst+1
1474 : 08                       php         ;flags after load/store sequence
1475 : 49c3                     eor #$c3
1477 : aa                       tax
1478 : e082                     cpx #$82    ;test result
                                trap_ne
147a : d0fe            >        bne *           ;failed not equal (non zero)
                        
147c : 68                       pla         ;load status
                                eor_flag 0
147d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
147f : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1482 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1484 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1486 : 48              >            pha         ;use stack to load status
1487 : 28              >            plp
                        
1488 : a60b                     ldx zp1+2
148a : 08                       php         ;test stores do not alter flags
148b : 8a                       txa
148c : 49c3                     eor #$c3
148e : aa                       tax
148f : 28                       plp
1490 : 8e0502                   stx abst+2
1493 : 08                       php         ;flags after load/store sequence
1494 : 49c3                     eor #$c3
1496 : aa                       tax
1497 : e041                     cpx #$41    ;test result
                                trap_ne
1499 : d0fe            >        bne *           ;failed not equal (non zero)
                        
149b : 68                       pla         ;load status
                                eor_flag 0
149c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
149e : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
14a1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
14a3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
14a5 : 48              >            pha         ;use stack to load status
14a6 : 28              >            plp
                        
14a7 : a60c                     ldx zp1+3
14a9 : 08                       php         ;test stores do not alter flags
14aa : 8a                       txa
14ab : 49c3                     eor #$c3
14ad : aa                       tax
14ae : 28                       plp
14af : 8e0602                   stx abst+3
14b2 : 08                       php         ;flags after load/store sequence
14b3 : 49c3                     eor #$c3
14b5 : aa                       tax
14b6 : e000                     cpx #0      ;test result
                                trap_ne
14b8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14ba : 68                       pla         ;load status
                                eor_flag 0
14bb : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
14bd : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
14c0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
14c2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
14c4 : 48              >            pha         ;use stack to load status
14c5 : 28              >            plp
                        
14c6 : a609                     ldx zp1
14c8 : 08                       php         ;test stores do not alter flags
14c9 : 8a                       txa
14ca : 49c3                     eor #$c3
14cc : aa                       tax
14cd : 28                       plp
14ce : 8e0302                   stx abst
14d1 : 08                       php         ;flags after load/store sequence
14d2 : 49c3                     eor #$c3
14d4 : aa                       tax
14d5 : e0c3                     cpx #$c3    ;test result
                                trap_ne     ;
14d7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14d9 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
14da : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
14dc : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
14df : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
14e1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
14e3 : 48              >            pha         ;use stack to load status
14e4 : 28              >            plp
                        
14e5 : a60a                     ldx zp1+1
14e7 : 08                       php         ;test stores do not alter flags
14e8 : 8a                       txa
14e9 : 49c3                     eor #$c3
14eb : aa                       tax
14ec : 28                       plp
14ed : 8e0402                   stx abst+1
14f0 : 08                       php         ;flags after load/store sequence
14f1 : 49c3                     eor #$c3
14f3 : aa                       tax
14f4 : e082                     cpx #$82    ;test result
                                trap_ne
14f6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14f8 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
14f9 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
14fb : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
14fe : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1500 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1502 : 48              >            pha         ;use stack to load status
1503 : 28              >            plp
                        
1504 : a60b                     ldx zp1+2
1506 : 08                       php         ;test stores do not alter flags
1507 : 8a                       txa
1508 : 49c3                     eor #$c3
150a : aa                       tax
150b : 28                       plp
150c : 8e0502                   stx abst+2
150f : 08                       php         ;flags after load/store sequence
1510 : 49c3                     eor #$c3
1512 : aa                       tax
1513 : e041                     cpx #$41    ;test result
                                trap_ne     ;
1515 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1517 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1518 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
151a : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
151d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
151f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1521 : 48              >            pha         ;use stack to load status
1522 : 28              >            plp
                        
1523 : a60c                     ldx zp1+3
1525 : 08                       php         ;test stores do not alter flags
1526 : 8a                       txa
1527 : 49c3                     eor #$c3
1529 : aa                       tax
152a : 28                       plp
152b : 8e0602                   stx abst+3
152e : 08                       php         ;flags after load/store sequence
152f : 49c3                     eor #$c3
1531 : aa                       tax
1532 : e000                     cpx #0      ;test result
                                trap_ne
1534 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1536 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1537 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1539 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
153c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat 0
                       >            load_flag 0
153e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1540 : 48              >            pha         ;use stack to load status
1541 : 28              >            plp
                        
1542 : ae1702                   ldx abs1
1545 : 08                       php         ;test stores do not alter flags
1546 : 8a                       txa
1547 : 49c3                     eor #$c3
1549 : aa                       tax
154a : 28                       plp
154b : 8602                     stx zpt
154d : 08                       php         ;flags after load/store sequence
154e : 49c3                     eor #$c3
1550 : c509                     cmp zp1     ;test result
                                trap_ne
1552 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1554 : 68                       pla         ;load status
                                eor_flag 0
1555 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1557 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
155a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
155c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
155e : 48              >            pha         ;use stack to load status
155f : 28              >            plp
                        
1560 : ae1802                   ldx abs1+1
1563 : 08                       php         ;test stores do not alter flags
1564 : 8a                       txa
1565 : 49c3                     eor #$c3
1567 : aa                       tax
1568 : 28                       plp
1569 : 8603                     stx zpt+1
156b : 08                       php         ;flags after load/store sequence
156c : 49c3                     eor #$c3
156e : c50a                     cmp zp1+1   ;test result
                                trap_ne
1570 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1572 : 68                       pla         ;load status
                                eor_flag 0
1573 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1575 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1578 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
157a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
157c : 48              >            pha         ;use stack to load status
157d : 28              >            plp
                        
157e : ae1902                   ldx abs1+2
1581 : 08                       php         ;test stores do not alter flags
1582 : 8a                       txa
1583 : 49c3                     eor #$c3
1585 : aa                       tax
1586 : 28                       plp
1587 : 8604                     stx zpt+2
1589 : 08                       php         ;flags after load/store sequence
158a : 49c3                     eor #$c3
158c : c50b                     cmp zp1+2   ;test result
                                trap_ne
158e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1590 : 68                       pla         ;load status
                                eor_flag 0
1591 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1593 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1596 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1598 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
159a : 48              >            pha         ;use stack to load status
159b : 28              >            plp
                        
159c : ae1a02                   ldx abs1+3
159f : 08                       php         ;test stores do not alter flags
15a0 : 8a                       txa
15a1 : 49c3                     eor #$c3
15a3 : aa                       tax
15a4 : 28                       plp
15a5 : 8605                     stx zpt+3
15a7 : 08                       php         ;flags after load/store sequence
15a8 : 49c3                     eor #$c3
15aa : c50c                     cmp zp1+3   ;test result
                                trap_ne
15ac : d0fe            >        bne *           ;failed not equal (non zero)
                        
15ae : 68                       pla         ;load status
                                eor_flag 0
15af : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
15b1 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
15b4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
15b6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
15b8 : 48              >            pha         ;use stack to load status
15b9 : 28              >            plp
                        
15ba : ae1702                   ldx abs1
15bd : 08                       php         ;test stores do not alter flags
15be : 8a                       txa
15bf : 49c3                     eor #$c3
15c1 : aa                       tax
15c2 : 28                       plp
15c3 : 8602                     stx zpt
15c5 : 08                       php         ;flags after load/store sequence
15c6 : 49c3                     eor #$c3
15c8 : aa                       tax
15c9 : e409                     cpx zp1     ;test result
                                trap_ne
15cb : d0fe            >        bne *           ;failed not equal (non zero)
                        
15cd : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
15ce : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
15d0 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
15d3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
15d5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
15d7 : 48              >            pha         ;use stack to load status
15d8 : 28              >            plp
                        
15d9 : ae1802                   ldx abs1+1
15dc : 08                       php         ;test stores do not alter flags
15dd : 8a                       txa
15de : 49c3                     eor #$c3
15e0 : aa                       tax
15e1 : 28                       plp
15e2 : 8603                     stx zpt+1
15e4 : 08                       php         ;flags after load/store sequence
15e5 : 49c3                     eor #$c3
15e7 : aa                       tax
15e8 : e40a                     cpx zp1+1   ;test result
                                trap_ne
15ea : d0fe            >        bne *           ;failed not equal (non zero)
                        
15ec : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
15ed : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
15ef : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
15f2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
15f4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
15f6 : 48              >            pha         ;use stack to load status
15f7 : 28              >            plp
                        
15f8 : ae1902                   ldx abs1+2
15fb : 08                       php         ;test stores do not alter flags
15fc : 8a                       txa
15fd : 49c3                     eor #$c3
15ff : aa                       tax
1600 : 28                       plp
1601 : 8604                     stx zpt+2
1603 : 08                       php         ;flags after load/store sequence
1604 : 49c3                     eor #$c3
1606 : aa                       tax
1607 : e40b                     cpx zp1+2   ;test result
                                trap_ne
1609 : d0fe            >        bne *           ;failed not equal (non zero)
                        
160b : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
160c : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
160e : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1611 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1613 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1615 : 48              >            pha         ;use stack to load status
1616 : 28              >            plp
                        
1617 : ae1a02                   ldx abs1+3
161a : 08                       php         ;test stores do not alter flags
161b : 8a                       txa
161c : 49c3                     eor #$c3
161e : aa                       tax
161f : 28                       plp
1620 : 8605                     stx zpt+3
1622 : 08                       php         ;flags after load/store sequence
1623 : 49c3                     eor #$c3
1625 : aa                       tax
1626 : e40c                     cpx zp1+3   ;test result
                                trap_ne
1628 : d0fe            >        bne *           ;failed not equal (non zero)
                        
162a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
162b : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
162d : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1630 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat 0
                       >            load_flag 0
1632 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1634 : 48              >            pha         ;use stack to load status
1635 : 28              >            plp
                        
1636 : a2c3                     ldx #$c3
1638 : 08                       php
1639 : ec1702                   cpx abs1    ;test result
                                trap_ne
163c : d0fe            >        bne *           ;failed not equal (non zero)
                        
163e : 68                       pla         ;load status
                                eor_flag 0
163f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1641 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1644 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1646 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1648 : 48              >            pha         ;use stack to load status
1649 : 28              >            plp
                        
164a : a282                     ldx #$82
164c : 08                       php
164d : ec1802                   cpx abs1+1  ;test result
                                trap_ne
1650 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1652 : 68                       pla         ;load status
                                eor_flag 0
1653 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1655 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1658 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
165a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
165c : 48              >            pha         ;use stack to load status
165d : 28              >            plp
                        
165e : a241                     ldx #$41
1660 : 08                       php
1661 : ec1902                   cpx abs1+2  ;test result
                                trap_ne
1664 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1666 : 68                       pla         ;load status
                                eor_flag 0
1667 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1669 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
166c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
166e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1670 : 48              >            pha         ;use stack to load status
1671 : 28              >            plp
                        
1672 : a200                     ldx #0
1674 : 08                       php
1675 : ec1a02                   cpx abs1+3  ;test result
                                trap_ne
1678 : d0fe            >        bne *           ;failed not equal (non zero)
                        
167a : 68                       pla         ;load status
                                eor_flag 0
167b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
167d : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1680 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1682 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1684 : 48              >            pha         ;use stack to load status
1685 : 28              >            plp
                        
1686 : a2c3                     ldx #$c3
1688 : 08                       php
1689 : ec1702                   cpx abs1    ;test result
                                trap_ne
168c : d0fe            >        bne *           ;failed not equal (non zero)
                        
168e : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
168f : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1691 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1694 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1696 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1698 : 48              >            pha         ;use stack to load status
1699 : 28              >            plp
                        
169a : a282                     ldx #$82
169c : 08                       php
169d : ec1802                   cpx abs1+1  ;test result
                                trap_ne
16a0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16a2 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
16a3 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
16a5 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
16a8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
16aa : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
16ac : 48              >            pha         ;use stack to load status
16ad : 28              >            plp
                        
16ae : a241                     ldx #$41
16b0 : 08                       php
16b1 : ec1902                   cpx abs1+2  ;test result
                                trap_ne
16b4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16b6 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
16b7 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
16b9 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
16bc : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
16be : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
16c0 : 48              >            pha         ;use stack to load status
16c1 : 28              >            plp
                        
16c2 : a200                     ldx #0
16c4 : 08                       php
16c5 : ec1a02                   cpx abs1+3  ;test result
                                trap_ne
16c8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16ca : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
16cb : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
16cd : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
16d0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
16d2 : a200                     ldx #0
16d4 : a502                     lda zpt
16d6 : 49c3                     eor #$c3
16d8 : c509                     cmp zp1
                                trap_ne     ;store to zp data
16da : d0fe            >        bne *           ;failed not equal (non zero)
                        
16dc : 8602                     stx zpt     ;clear
16de : ad0302                   lda abst
16e1 : 49c3                     eor #$c3
16e3 : cd1702                   cmp abs1
                                trap_ne     ;store to abs data
16e6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16e8 : 8e0302                   stx abst    ;clear
16eb : a503                     lda zpt+1
16ed : 49c3                     eor #$c3
16ef : c50a                     cmp zp1+1
                                trap_ne     ;store to zp data
16f1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16f3 : 8603                     stx zpt+1   ;clear
16f5 : ad0402                   lda abst+1
16f8 : 49c3                     eor #$c3
16fa : cd1802                   cmp abs1+1
                                trap_ne     ;store to abs data
16fd : d0fe            >        bne *           ;failed not equal (non zero)
                        
16ff : 8e0402                   stx abst+1  ;clear
1702 : a504                     lda zpt+2
1704 : 49c3                     eor #$c3
1706 : c50b                     cmp zp1+2
                                trap_ne     ;store to zp data
1708 : d0fe            >        bne *           ;failed not equal (non zero)
                        
170a : 8604                     stx zpt+2   ;clear
170c : ad0502                   lda abst+2
170f : 49c3                     eor #$c3
1711 : cd1902                   cmp abs1+2
                                trap_ne     ;store to abs data
1714 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1716 : 8e0502                   stx abst+2  ;clear
1719 : a505                     lda zpt+3
171b : 49c3                     eor #$c3
171d : c50c                     cmp zp1+3
                                trap_ne     ;store to zp data
171f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1721 : 8605                     stx zpt+3   ;clear
1723 : ad0602                   lda abst+3
1726 : 49c3                     eor #$c3
1728 : cd1a02                   cmp abs1+3
                                trap_ne     ;store to abs data
172b : d0fe            >        bne *           ;failed not equal (non zero)
                        
172d : 8e0602                   stx abst+3  ;clear
                                next_test
1730 : ad0002          >            lda test_case   ;previous test
1733 : c913            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1735 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0014 =                 >test_num = test_num + 1
1737 : a914            >            lda #test_num   ;*** next tests' number
1739 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDY / STY - zp / abs / #
                                set_stat 0
                       >            load_flag 0
173c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
173e : 48              >            pha         ;use stack to load status
173f : 28              >            plp
                        
1740 : a409                     ldy zp1
1742 : 08                       php         ;test stores do not alter flags
1743 : 98                       tya
1744 : 49c3                     eor #$c3
1746 : a8                       tay
1747 : 28                       plp
1748 : 8c0302                   sty abst
174b : 08                       php         ;flags after load/store sequence
174c : 49c3                     eor #$c3
174e : a8                       tay
174f : c0c3                     cpy #$c3    ;test result
                                trap_ne
1751 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1753 : 68                       pla         ;load status
                                eor_flag 0
1754 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1756 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1759 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
175b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
175d : 48              >            pha         ;use stack to load status
175e : 28              >            plp
                        
175f : a40a                     ldy zp1+1
1761 : 08                       php         ;test stores do not alter flags
1762 : 98                       tya
1763 : 49c3                     eor #$c3
1765 : a8                       tay
1766 : 28                       plp
1767 : 8c0402                   sty abst+1
176a : 08                       php         ;flags after load/store sequence
176b : 49c3                     eor #$c3
176d : a8                       tay
176e : c082                     cpy #$82    ;test result
                                trap_ne
1770 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1772 : 68                       pla         ;load status
                                eor_flag 0
1773 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1775 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1778 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
177a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
177c : 48              >            pha         ;use stack to load status
177d : 28              >            plp
                        
177e : a40b                     ldy zp1+2
1780 : 08                       php         ;test stores do not alter flags
1781 : 98                       tya
1782 : 49c3                     eor #$c3
1784 : a8                       tay
1785 : 28                       plp
1786 : 8c0502                   sty abst+2
1789 : 08                       php         ;flags after load/store sequence
178a : 49c3                     eor #$c3
178c : a8                       tay
178d : c041                     cpy #$41    ;test result
                                trap_ne
178f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1791 : 68                       pla         ;load status
                                eor_flag 0
1792 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1794 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1797 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1799 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
179b : 48              >            pha         ;use stack to load status
179c : 28              >            plp
                        
179d : a40c                     ldy zp1+3
179f : 08                       php         ;test stores do not alter flags
17a0 : 98                       tya
17a1 : 49c3                     eor #$c3
17a3 : a8                       tay
17a4 : 28                       plp
17a5 : 8c0602                   sty abst+3
17a8 : 08                       php         ;flags after load/store sequence
17a9 : 49c3                     eor #$c3
17ab : a8                       tay
17ac : c000                     cpy #0      ;test result
                                trap_ne
17ae : d0fe            >        bne *           ;failed not equal (non zero)
                        
17b0 : 68                       pla         ;load status
                                eor_flag 0
17b1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
17b3 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
17b6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
17b8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
17ba : 48              >            pha         ;use stack to load status
17bb : 28              >            plp
                        
17bc : a409                     ldy zp1
17be : 08                       php         ;test stores do not alter flags
17bf : 98                       tya
17c0 : 49c3                     eor #$c3
17c2 : a8                       tay
17c3 : 28                       plp
17c4 : 8c0302                   sty abst
17c7 : 08                       php         ;flags after load/store sequence
17c8 : 49c3                     eor #$c3
17ca : a8                       tay
17cb : c0c3                     cpy #$c3    ;test result
                                trap_ne
17cd : d0fe            >        bne *           ;failed not equal (non zero)
                        
17cf : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
17d0 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
17d2 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
17d5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
17d7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
17d9 : 48              >            pha         ;use stack to load status
17da : 28              >            plp
                        
17db : a40a                     ldy zp1+1
17dd : 08                       php         ;test stores do not alter flags
17de : 98                       tya
17df : 49c3                     eor #$c3
17e1 : a8                       tay
17e2 : 28                       plp
17e3 : 8c0402                   sty abst+1
17e6 : 08                       php         ;flags after load/store sequence
17e7 : 49c3                     eor #$c3
17e9 : a8                       tay
17ea : c082                     cpy #$82   ;test result
                                trap_ne
17ec : d0fe            >        bne *           ;failed not equal (non zero)
                        
17ee : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
17ef : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
17f1 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
17f4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
17f6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
17f8 : 48              >            pha         ;use stack to load status
17f9 : 28              >            plp
                        
17fa : a40b                     ldy zp1+2
17fc : 08                       php         ;test stores do not alter flags
17fd : 98                       tya
17fe : 49c3                     eor #$c3
1800 : a8                       tay
1801 : 28                       plp
1802 : 8c0502                   sty abst+2
1805 : 08                       php         ;flags after load/store sequence
1806 : 49c3                     eor #$c3
1808 : a8                       tay
1809 : c041                     cpy #$41    ;test result
                                trap_ne
180b : d0fe            >        bne *           ;failed not equal (non zero)
                        
180d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
180e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1810 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1813 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1815 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1817 : 48              >            pha         ;use stack to load status
1818 : 28              >            plp
                        
1819 : a40c                     ldy zp1+3
181b : 08                       php         ;test stores do not alter flags
181c : 98                       tya
181d : 49c3                     eor #$c3
181f : a8                       tay
1820 : 28                       plp
1821 : 8c0602                   sty abst+3
1824 : 08                       php         ;flags after load/store sequence
1825 : 49c3                     eor #$c3
1827 : a8                       tay
1828 : c000                     cpy #0      ;test result
                                trap_ne
182a : d0fe            >        bne *           ;failed not equal (non zero)
                        
182c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
182d : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
182f : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1832 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat 0
                       >            load_flag 0
1834 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1836 : 48              >            pha         ;use stack to load status
1837 : 28              >            plp
                        
1838 : ac1702                   ldy abs1
183b : 08                       php         ;test stores do not alter flags
183c : 98                       tya
183d : 49c3                     eor #$c3
183f : a8                       tay
1840 : 28                       plp
1841 : 8402                     sty zpt
1843 : 08                       php         ;flags after load/store sequence
1844 : 49c3                     eor #$c3
1846 : a8                       tay
1847 : c409                     cpy zp1     ;test result
                                trap_ne
1849 : d0fe            >        bne *           ;failed not equal (non zero)
                        
184b : 68                       pla         ;load status
                                eor_flag 0
184c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
184e : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1851 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1853 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1855 : 48              >            pha         ;use stack to load status
1856 : 28              >            plp
                        
1857 : ac1802                   ldy abs1+1
185a : 08                       php         ;test stores do not alter flags
185b : 98                       tya
185c : 49c3                     eor #$c3
185e : a8                       tay
185f : 28                       plp
1860 : 8403                     sty zpt+1
1862 : 08                       php         ;flags after load/store sequence
1863 : 49c3                     eor #$c3
1865 : a8                       tay
1866 : c40a                     cpy zp1+1   ;test result
                                trap_ne
1868 : d0fe            >        bne *           ;failed not equal (non zero)
                        
186a : 68                       pla         ;load status
                                eor_flag 0
186b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
186d : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1870 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1872 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1874 : 48              >            pha         ;use stack to load status
1875 : 28              >            plp
                        
1876 : ac1902                   ldy abs1+2
1879 : 08                       php         ;test stores do not alter flags
187a : 98                       tya
187b : 49c3                     eor #$c3
187d : a8                       tay
187e : 28                       plp
187f : 8404                     sty zpt+2
1881 : 08                       php         ;flags after load/store sequence
1882 : 49c3                     eor #$c3
1884 : a8                       tay
1885 : c40b                     cpy zp1+2   ;test result
                                trap_ne
1887 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1889 : 68                       pla         ;load status
                                eor_flag 0
188a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
188c : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
188f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1891 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1893 : 48              >            pha         ;use stack to load status
1894 : 28              >            plp
                        
1895 : ac1a02                   ldy abs1+3
1898 : 08                       php         ;test stores do not alter flags
1899 : 98                       tya
189a : 49c3                     eor #$c3
189c : a8                       tay
189d : 28                       plp
189e : 8405                     sty zpt+3
18a0 : 08                       php         ;flags after load/store sequence
18a1 : 49c3                     eor #$c3
18a3 : a8                       tay
18a4 : c40c                     cpy zp1+3   ;test result
                                trap_ne
18a6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
18a8 : 68                       pla         ;load status
                                eor_flag 0
18a9 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
18ab : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
18ae : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
18b0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
18b2 : 48              >            pha         ;use stack to load status
18b3 : 28              >            plp
                        
18b4 : ac1702                   ldy abs1
18b7 : 08                       php         ;test stores do not alter flags
18b8 : 98                       tya
18b9 : 49c3                     eor #$c3
18bb : a8                       tay
18bc : 28                       plp
18bd : 8402                     sty zpt
18bf : 08                       php         ;flags after load/store sequence
18c0 : 49c3                     eor #$c3
18c2 : a8                       tay
18c3 : c509                     cmp zp1     ;test result
                                trap_ne
18c5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
18c7 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
18c8 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
18ca : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
18cd : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
18cf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
18d1 : 48              >            pha         ;use stack to load status
18d2 : 28              >            plp
                        
18d3 : ac1802                   ldy abs1+1
18d6 : 08                       php         ;test stores do not alter flags
18d7 : 98                       tya
18d8 : 49c3                     eor #$c3
18da : a8                       tay
18db : 28                       plp
18dc : 8403                     sty zpt+1
18de : 08                       php         ;flags after load/store sequence
18df : 49c3                     eor #$c3
18e1 : a8                       tay
18e2 : c50a                     cmp zp1+1   ;test result
                                trap_ne
18e4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
18e6 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
18e7 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
18e9 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
18ec : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
18ee : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
18f0 : 48              >            pha         ;use stack to load status
18f1 : 28              >            plp
                        
18f2 : ac1902                   ldy abs1+2
18f5 : 08                       php         ;test stores do not alter flags
18f6 : 98                       tya
18f7 : 49c3                     eor #$c3
18f9 : a8                       tay
18fa : 28                       plp
18fb : 8404                     sty zpt+2
18fd : 08                       php         ;flags after load/store sequence
18fe : 49c3                     eor #$c3
1900 : a8                       tay
1901 : c50b                     cmp zp1+2   ;test result
                                trap_ne
1903 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1905 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1906 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1908 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
190b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
190d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
190f : 48              >            pha         ;use stack to load status
1910 : 28              >            plp
                        
1911 : ac1a02                   ldy abs1+3
1914 : 08                       php         ;test stores do not alter flags
1915 : 98                       tya
1916 : 49c3                     eor #$c3
1918 : a8                       tay
1919 : 28                       plp
191a : 8405                     sty zpt+3
191c : 08                       php         ;flags after load/store sequence
191d : 49c3                     eor #$c3
191f : a8                       tay
1920 : c50c                     cmp zp1+3   ;test result
                                trap_ne
1922 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1924 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1925 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1927 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
192a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                        
                                set_stat 0
                       >            load_flag 0
192c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
192e : 48              >            pha         ;use stack to load status
192f : 28              >            plp
                        
1930 : a0c3                     ldy #$c3
1932 : 08                       php
1933 : cc1702                   cpy abs1    ;test result
                                trap_ne
1936 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1938 : 68                       pla         ;load status
                                eor_flag 0
1939 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
193b : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
193e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1940 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1942 : 48              >            pha         ;use stack to load status
1943 : 28              >            plp
                        
1944 : a082                     ldy #$82
1946 : 08                       php
1947 : cc1802                   cpy abs1+1  ;test result
                                trap_ne
194a : d0fe            >        bne *           ;failed not equal (non zero)
                        
194c : 68                       pla         ;load status
                                eor_flag 0
194d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
194f : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1952 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1954 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1956 : 48              >            pha         ;use stack to load status
1957 : 28              >            plp
                        
1958 : a041                     ldy #$41
195a : 08                       php
195b : cc1902                   cpy abs1+2  ;test result
                                trap_ne
195e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1960 : 68                       pla         ;load status
                                eor_flag 0
1961 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1963 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1966 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1968 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
196a : 48              >            pha         ;use stack to load status
196b : 28              >            plp
                        
196c : a000                     ldy #0
196e : 08                       php
196f : cc1a02                   cpy abs1+3  ;test result
                                trap_ne
1972 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1974 : 68                       pla         ;load status
                                eor_flag 0
1975 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1977 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
197a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
197c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
197e : 48              >            pha         ;use stack to load status
197f : 28              >            plp
                        
1980 : a0c3                     ldy #$c3
1982 : 08                       php
1983 : cc1702                   cpy abs1    ;test result
                                trap_ne
1986 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1988 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1989 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
198b : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
198e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1990 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1992 : 48              >            pha         ;use stack to load status
1993 : 28              >            plp
                        
1994 : a082                     ldy #$82
1996 : 08                       php
1997 : cc1802                   cpy abs1+1  ;test result
                                trap_ne
199a : d0fe            >        bne *           ;failed not equal (non zero)
                        
199c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
199d : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
199f : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
19a2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
19a4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
19a6 : 48              >            pha         ;use stack to load status
19a7 : 28              >            plp
                        
19a8 : a041                     ldy #$41
19aa : 08                       php
19ab : cc1902                   cpy abs1+2   ;test result
                                trap_ne
19ae : d0fe            >        bne *           ;failed not equal (non zero)
                        
19b0 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
19b1 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
19b3 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
19b6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
19b8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
19ba : 48              >            pha         ;use stack to load status
19bb : 28              >            plp
                        
19bc : a000                     ldy #0
19be : 08                       php
19bf : cc1a02                   cpy abs1+3  ;test result
                                trap_ne
19c2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
19c4 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
19c5 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
19c7 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
19ca : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
19cc : a000                     ldy #0
19ce : a502                     lda zpt
19d0 : 49c3                     eor #$c3
19d2 : c509                     cmp zp1
                                trap_ne     ;store to zp   data
19d4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
19d6 : 8402                     sty zpt     ;clear
19d8 : ad0302                   lda abst
19db : 49c3                     eor #$c3
19dd : cd1702                   cmp abs1
                                trap_ne     ;store to abs   data
19e0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
19e2 : 8c0302                   sty abst    ;clear
19e5 : a503                     lda zpt+1
19e7 : 49c3                     eor #$c3
19e9 : c50a                     cmp zp1+1
                                trap_ne     ;store to zp+1 data
19eb : d0fe            >        bne *           ;failed not equal (non zero)
                        
19ed : 8403                     sty zpt+1   ;clear
19ef : ad0402                   lda abst+1
19f2 : 49c3                     eor #$c3
19f4 : cd1802                   cmp abs1+1
                                trap_ne     ;store to abs+1 data
19f7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
19f9 : 8c0402                   sty abst+1  ;clear
19fc : a504                     lda zpt+2
19fe : 49c3                     eor #$c3
1a00 : c50b                     cmp zp1+2
                                trap_ne     ;store to zp+2 data
1a02 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a04 : 8404                     sty zpt+2   ;clear
1a06 : ad0502                   lda abst+2
1a09 : 49c3                     eor #$c3
1a0b : cd1902                   cmp abs1+2
                                trap_ne     ;store to abs+2 data
1a0e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a10 : 8c0502                   sty abst+2  ;clear
1a13 : a505                     lda zpt+3
1a15 : 49c3                     eor #$c3
1a17 : c50c                     cmp zp1+3
                                trap_ne     ;store to zp+3 data
1a19 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a1b : 8405                     sty zpt+3   ;clear
1a1d : ad0602                   lda abst+3
1a20 : 49c3                     eor #$c3
1a22 : cd1a02                   cmp abs1+3
                                trap_ne     ;store to abs+3 data
1a25 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a27 : 8c0602                   sty abst+3  ;clear
                                next_test
1a2a : ad0002          >            lda test_case   ;previous test
1a2d : c914            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1a2f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0015 =                 >test_num = test_num + 1
1a31 : a915            >            lda #test_num   ;*** next tests' number
1a33 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing load / store accumulator LDA / STA all addressing modes
                        ; LDA / STA - zp,x / abs,x
1a36 : a203                     ldx #3
1a38 :                  tldax
                                set_stat 0
                       >            load_flag 0
1a38 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1a3a : 48              >            pha         ;use stack to load status
1a3b : 28              >            plp
                        
1a3c : b509                     lda zp1,x
1a3e : 08                       php         ;test stores do not alter flags
1a3f : 49c3                     eor #$c3
1a41 : 28                       plp
1a42 : 9d0302                   sta abst,x
1a45 : 08                       php         ;flags after load/store sequence
1a46 : 49c3                     eor #$c3
1a48 : dd1702                   cmp abs1,x  ;test result
                                trap_ne
1a4b : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a4d : 68                       pla         ;load status
                                eor_flag 0
1a4e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1a50 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
1a53 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a55 : ca                       dex
1a56 : 10e0                     bpl tldax
                        
1a58 : a203                     ldx #3
1a5a :                  tldax1
                                set_stat $ff
                       >            load_flag $ff
1a5a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a5c : 48              >            pha         ;use stack to load status
1a5d : 28              >            plp
                        
1a5e : b509                     lda zp1,x
1a60 : 08                       php         ;test stores do not alter flags
1a61 : 49c3                     eor #$c3
1a63 : 28                       plp
1a64 : 9d0302                   sta abst,x
1a67 : 08                       php         ;flags after load/store sequence
1a68 : 49c3                     eor #$c3
1a6a : dd1702                   cmp abs1,x   ;test result
                                trap_ne
1a6d : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a6f : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a70 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1a72 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
1a75 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a77 : ca                       dex
1a78 : 10e0                     bpl tldax1
                        
1a7a : a203                     ldx #3
1a7c :                  tldax2
                                set_stat 0
                       >            load_flag 0
1a7c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1a7e : 48              >            pha         ;use stack to load status
1a7f : 28              >            plp
                        
1a80 : bd1702                   lda abs1,x
1a83 : 08                       php         ;test stores do not alter flags
1a84 : 49c3                     eor #$c3
1a86 : 28                       plp
1a87 : 9502                     sta zpt,x
1a89 : 08                       php         ;flags after load/store sequence
1a8a : 49c3                     eor #$c3
1a8c : d509                     cmp zp1,x   ;test result
                                trap_ne
1a8e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a90 : 68                       pla         ;load status
                                eor_flag 0
1a91 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1a93 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
1a96 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a98 : ca                       dex
1a99 : 10e1                     bpl tldax2
                        
1a9b : a203                     ldx #3
1a9d :                  tldax3
                                set_stat $ff
                       >            load_flag $ff
1a9d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a9f : 48              >            pha         ;use stack to load status
1aa0 : 28              >            plp
                        
1aa1 : bd1702                   lda abs1,x
1aa4 : 08                       php         ;test stores do not alter flags
1aa5 : 49c3                     eor #$c3
1aa7 : 28                       plp
1aa8 : 9502                     sta zpt,x
1aaa : 08                       php         ;flags after load/store sequence
1aab : 49c3                     eor #$c3
1aad : d509                     cmp zp1,x   ;test result
                                trap_ne
1aaf : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ab1 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1ab2 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1ab4 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
1ab7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ab9 : ca                       dex
1aba : 10e1                     bpl tldax3
                        
1abc : a203                     ldx #3      ;testing store result
1abe : a000                     ldy #0
1ac0 : b502             tstax   lda zpt,x
1ac2 : 49c3                     eor #$c3
1ac4 : d509                     cmp zp1,x
                                trap_ne     ;store to zp,x data
1ac6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ac8 : 9402                     sty zpt,x   ;clear
1aca : bd0302                   lda abst,x
1acd : 49c3                     eor #$c3
1acf : dd1702                   cmp abs1,x
                                trap_ne     ;store to abs,x data
1ad2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ad4 : 8a                       txa
1ad5 : 9d0302                   sta abst,x  ;clear
1ad8 : ca                       dex
1ad9 : 10e5                     bpl tstax
                                next_test
1adb : ad0002          >            lda test_case   ;previous test
1ade : c915            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1ae0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0016 =                 >test_num = test_num + 1
1ae2 : a916            >            lda #test_num   ;*** next tests' number
1ae4 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - (zp),y / abs,y / (zp,x)
1ae7 : a003                     ldy #3
1ae9 :                  tlday
                                set_stat 0
                       >            load_flag 0
1ae9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1aeb : 48              >            pha         ;use stack to load status
1aec : 28              >            plp
                        
1aed : b11a                     lda (ind1),y
1aef : 08                       php         ;test stores do not alter flags
1af0 : 49c3                     eor #$c3
1af2 : 28                       plp
1af3 : 990302                   sta abst,y
1af6 : 08                       php         ;flags after load/store sequence
1af7 : 49c3                     eor #$c3
1af9 : d91702                   cmp abs1,y  ;test result
                                trap_ne
1afc : d0fe            >        bne *           ;failed not equal (non zero)
                        
1afe : 68                       pla         ;load status
                                eor_flag 0
1aff : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1b01 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
1b04 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b06 : 88                       dey
1b07 : 10e0                     bpl tlday
                        
1b09 : a003                     ldy #3
1b0b :                  tlday1
                                set_stat $ff
                       >            load_flag $ff
1b0b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1b0d : 48              >            pha         ;use stack to load status
1b0e : 28              >            plp
                        
1b0f : b11a                     lda (ind1),y
1b11 : 08                       php         ;test stores do not alter flags
1b12 : 49c3                     eor #$c3
1b14 : 28                       plp
1b15 : 990302                   sta abst,y
1b18 : 08                       php         ;flags after load/store sequence
1b19 : 49c3                     eor #$c3
1b1b : d91702                   cmp abs1,y  ;test result
                                trap_ne
1b1e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b20 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1b21 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1b23 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
1b26 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b28 : 88                       dey
1b29 : 10e0                     bpl tlday1
                        
1b2b : a003                     ldy #3      ;testing store result
1b2d : a200                     ldx #0
1b2f : b90302           tstay   lda abst,y
1b32 : 49c3                     eor #$c3
1b34 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
1b37 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b39 : 8a                       txa
1b3a : 990302                   sta abst,y  ;clear
1b3d : 88                       dey
1b3e : 10ef                     bpl tstay
                        
1b40 : a003                     ldy #3
1b42 :                  tlday2
                                set_stat 0
                       >            load_flag 0
1b42 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1b44 : 48              >            pha         ;use stack to load status
1b45 : 28              >            plp
                        
1b46 : b91702                   lda abs1,y
1b49 : 08                       php         ;test stores do not alter flags
1b4a : 49c3                     eor #$c3
1b4c : 28                       plp
1b4d : 9126                     sta (indt),y
1b4f : 08                       php         ;flags after load/store sequence
1b50 : 49c3                     eor #$c3
1b52 : d11a                     cmp (ind1),y    ;test result
                                trap_ne
1b54 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b56 : 68                       pla         ;load status
                                eor_flag 0
1b57 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1b59 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
1b5c : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b5e : 88                       dey
1b5f : 10e1                     bpl tlday2
                        
1b61 : a003                     ldy #3
1b63 :                  tlday3
                                set_stat $ff
                       >            load_flag $ff
1b63 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1b65 : 48              >            pha         ;use stack to load status
1b66 : 28              >            plp
                        
1b67 : b91702                   lda abs1,y
1b6a : 08                       php         ;test stores do not alter flags
1b6b : 49c3                     eor #$c3
1b6d : 28                       plp
1b6e : 9126                     sta (indt),y
1b70 : 08                       php         ;flags after load/store sequence
1b71 : 49c3                     eor #$c3
1b73 : d11a                     cmp (ind1),y   ;test result
                                trap_ne
1b75 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b77 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1b78 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1b7a : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
1b7d : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b7f : 88                       dey
1b80 : 10e1                     bpl tlday3
                        
1b82 : a003                     ldy #3      ;testing store result
1b84 : a200                     ldx #0
1b86 : b90302           tstay1  lda abst,y
1b89 : 49c3                     eor #$c3
1b8b : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
1b8e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b90 : 8a                       txa
1b91 : 990302                   sta abst,y  ;clear
1b94 : 88                       dey
1b95 : 10ef                     bpl tstay1
                        
1b97 : a206                     ldx #6
1b99 : a003                     ldy #3
1b9b :                  tldax4
                                set_stat 0
                       >            load_flag 0
1b9b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1b9d : 48              >            pha         ;use stack to load status
1b9e : 28              >            plp
                        
1b9f : a11a                     lda (ind1,x)
1ba1 : 08                       php         ;test stores do not alter flags
1ba2 : 49c3                     eor #$c3
1ba4 : 28                       plp
1ba5 : 8126                     sta (indt,x)
1ba7 : 08                       php         ;flags after load/store sequence
1ba8 : 49c3                     eor #$c3
1baa : d91702                   cmp abs1,y  ;test result
                                trap_ne
1bad : d0fe            >        bne *           ;failed not equal (non zero)
                        
1baf : 68                       pla         ;load status
                                eor_flag 0
1bb0 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1bb2 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
1bb5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1bb7 : ca                       dex
1bb8 : ca                       dex
1bb9 : 88                       dey
1bba : 10df                     bpl tldax4
                        
1bbc : a206                     ldx #6
1bbe : a003                     ldy #3
1bc0 :                  tldax5
                                set_stat $ff
                       >            load_flag $ff
1bc0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1bc2 : 48              >            pha         ;use stack to load status
1bc3 : 28              >            plp
                        
1bc4 : a11a                     lda (ind1,x)
1bc6 : 08                       php         ;test stores do not alter flags
1bc7 : 49c3                     eor #$c3
1bc9 : 28                       plp
1bca : 8126                     sta (indt,x)
1bcc : 08                       php         ;flags after load/store sequence
1bcd : 49c3                     eor #$c3
1bcf : d91702                   cmp abs1,y  ;test result
                                trap_ne
1bd2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1bd4 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1bd5 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1bd7 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
1bda : d0fe            >        bne *           ;failed not equal (non zero)
                        
1bdc : ca                       dex
1bdd : ca                       dex
1bde : 88                       dey
1bdf : 10df                     bpl tldax5
                        
1be1 : a003                     ldy #3      ;testing store result
1be3 : a200                     ldx #0
1be5 : b90302           tstay2  lda abst,y
1be8 : 49c3                     eor #$c3
1bea : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
1bed : d0fe            >        bne *           ;failed not equal (non zero)
                        
1bef : 8a                       txa
1bf0 : 990302                   sta abst,y  ;clear
1bf3 : 88                       dey
1bf4 : 10ef                     bpl tstay2
                                next_test
1bf6 : ad0002          >            lda test_case   ;previous test
1bf9 : c916            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1bfb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0017 =                 >test_num = test_num + 1
1bfd : a917            >            lda #test_num   ;*** next tests' number
1bff : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
1c02 : a2fd                     ldx #3+$fa
1c04 : b50f             tldax6  lda zp1-$fa&$ff,x   ;wrap on indexed zp
1c06 : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
1c09 : ca                       dex
1c0a : e0fa                     cpx #$fa
1c0c : b0f6                     bcs tldax6
1c0e : a2fd                     ldx #3+$fa
1c10 : bd1d01           tldax7  lda abs1-$fa,x      ;no wrap on indexed abs
1c13 : 9508                     sta zpt-$fa&$ff,x
1c15 : ca                       dex
1c16 : e0fa                     cpx #$fa
1c18 : b0f6                     bcs tldax7
                        
1c1a : a203                     ldx #3      ;testing wraparound result
1c1c : a000                     ldy #0
1c1e : b502             tstax1  lda zpt,x
1c20 : d509                     cmp zp1,x
                                trap_ne     ;store to zp,x data
1c22 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1c24 : 9402                     sty zpt,x   ;clear
1c26 : bd0302                   lda abst,x
1c29 : dd1702                   cmp abs1,x
                                trap_ne     ;store to abs,x data
1c2c : d0fe            >        bne *           ;failed not equal (non zero)
                        
1c2e : 8a                       txa
1c2f : 9d0302                   sta abst,x  ;clear
1c32 : ca                       dex
1c33 : 10e9                     bpl tstax1
                        
1c35 : a0fb                     ldy #3+$f8
1c37 : a2fe                     ldx #6+$f8
1c39 : a122             tlday4  lda (ind1-$f8&$ff,x) ;wrap on indexed zp indirect
1c3b : 990b01                   sta abst-$f8,y
1c3e : ca                       dex
1c3f : ca                       dex
1c40 : 88                       dey
1c41 : c0f8                     cpy #$f8
1c43 : b0f4                     bcs tlday4
1c45 : a003                     ldy #3      ;testing wraparound result
1c47 : a200                     ldx #0
1c49 : b90302           tstay4  lda abst,y
1c4c : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
1c4f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1c51 : 8a                       txa
1c52 : 990302                   sta abst,y  ;clear
1c55 : 88                       dey
1c56 : 10f1                     bpl tstay4
                        
1c58 : a0fb                     ldy #3+$f8
1c5a : b91f01           tlday5  lda abs1-$f8,y  ;no wrap on indexed abs
1c5d : 912e                     sta (inwt),y
1c5f : 88                       dey
1c60 : c0f8                     cpy #$f8
1c62 : b0f6                     bcs tlday5
1c64 : a003                     ldy #3      ;testing wraparound result
1c66 : a200                     ldx #0
1c68 : b90302           tstay5  lda abst,y
1c6b : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
1c6e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1c70 : 8a                       txa
1c71 : 990302                   sta abst,y  ;clear
1c74 : 88                       dey
1c75 : 10f1                     bpl tstay5
                        
1c77 : a0fb                     ldy #3+$f8
1c79 : a2fe                     ldx #6+$f8
1c7b : b124             tlday6  lda (inw1),y    ;no wrap on zp indirect indexed
1c7d : 812e                     sta (indt-$f8&$ff,x)
1c7f : ca                       dex
1c80 : ca                       dex
1c81 : 88                       dey
1c82 : c0f8                     cpy #$f8
1c84 : b0f5                     bcs tlday6
1c86 : a003                     ldy #3      ;testing wraparound result
1c88 : a200                     ldx #0
1c8a : b90302           tstay6  lda abst,y
1c8d : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
1c90 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1c92 : 8a                       txa
1c93 : 990302                   sta abst,y  ;clear
1c96 : 88                       dey
1c97 : 10f1                     bpl tstay6
                                next_test
1c99 : ad0002          >            lda test_case   ;previous test
1c9c : c917            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1c9e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0018 =                 >test_num = test_num + 1
1ca0 : a918            >            lda #test_num   ;*** next tests' number
1ca2 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - zp / abs / #
                                set_stat 0
                       >            load_flag 0
1ca5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ca7 : 48              >            pha         ;use stack to load status
1ca8 : 28              >            plp
                        
1ca9 : a509                     lda zp1
1cab : 08                       php         ;test stores do not alter flags
1cac : 49c3                     eor #$c3
1cae : 28                       plp
1caf : 8d0302                   sta abst
1cb2 : 08                       php         ;flags after load/store sequence
1cb3 : 49c3                     eor #$c3
1cb5 : c9c3                     cmp #$c3    ;test result
                                trap_ne
1cb7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1cb9 : 68                       pla         ;load status
                                eor_flag 0
1cba : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1cbc : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1cbf : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1cc1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1cc3 : 48              >            pha         ;use stack to load status
1cc4 : 28              >            plp
                        
1cc5 : a50a                     lda zp1+1
1cc7 : 08                       php         ;test stores do not alter flags
1cc8 : 49c3                     eor #$c3
1cca : 28                       plp
1ccb : 8d0402                   sta abst+1
1cce : 08                       php         ;flags after load/store sequence
1ccf : 49c3                     eor #$c3
1cd1 : c982                     cmp #$82    ;test result
                                trap_ne
1cd3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1cd5 : 68                       pla         ;load status
                                eor_flag 0
1cd6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1cd8 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1cdb : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1cdd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1cdf : 48              >            pha         ;use stack to load status
1ce0 : 28              >            plp
                        
1ce1 : a50b                     lda zp1+2
1ce3 : 08                       php         ;test stores do not alter flags
1ce4 : 49c3                     eor #$c3
1ce6 : 28                       plp
1ce7 : 8d0502                   sta abst+2
1cea : 08                       php         ;flags after load/store sequence
1ceb : 49c3                     eor #$c3
1ced : c941                     cmp #$41    ;test result
                                trap_ne
1cef : d0fe            >        bne *           ;failed not equal (non zero)
                        
1cf1 : 68                       pla         ;load status
                                eor_flag 0
1cf2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1cf4 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1cf7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1cf9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1cfb : 48              >            pha         ;use stack to load status
1cfc : 28              >            plp
                        
1cfd : a50c                     lda zp1+3
1cff : 08                       php         ;test stores do not alter flags
1d00 : 49c3                     eor #$c3
1d02 : 28                       plp
1d03 : 8d0602                   sta abst+3
1d06 : 08                       php         ;flags after load/store sequence
1d07 : 49c3                     eor #$c3
1d09 : c900                     cmp #0      ;test result
                                trap_ne
1d0b : d0fe            >        bne *           ;failed not equal (non zero)
                        
1d0d : 68                       pla         ;load status
                                eor_flag 0
1d0e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1d10 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1d13 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1d15 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1d17 : 48              >            pha         ;use stack to load status
1d18 : 28              >            plp
                        
1d19 : a509                     lda zp1
1d1b : 08                       php         ;test stores do not alter flags
1d1c : 49c3                     eor #$c3
1d1e : 28                       plp
1d1f : 8d0302                   sta abst
1d22 : 08                       php         ;flags after load/store sequence
1d23 : 49c3                     eor #$c3
1d25 : c9c3                     cmp #$c3    ;test result
                                trap_ne
1d27 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1d29 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1d2a : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1d2c : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1d2f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1d31 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1d33 : 48              >            pha         ;use stack to load status
1d34 : 28              >            plp
                        
1d35 : a50a                     lda zp1+1
1d37 : 08                       php         ;test stores do not alter flags
1d38 : 49c3                     eor #$c3
1d3a : 28                       plp
1d3b : 8d0402                   sta abst+1
1d3e : 08                       php         ;flags after load/store sequence
1d3f : 49c3                     eor #$c3
1d41 : c982                     cmp #$82    ;test result
                                trap_ne
1d43 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1d45 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1d46 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1d48 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1d4b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1d4d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1d4f : 48              >            pha         ;use stack to load status
1d50 : 28              >            plp
                        
1d51 : a50b                     lda zp1+2
1d53 : 08                       php         ;test stores do not alter flags
1d54 : 49c3                     eor #$c3
1d56 : 28                       plp
1d57 : 8d0502                   sta abst+2
1d5a : 08                       php         ;flags after load/store sequence
1d5b : 49c3                     eor #$c3
1d5d : c941                     cmp #$41    ;test result
                                trap_ne
1d5f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1d61 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1d62 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1d64 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1d67 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1d69 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1d6b : 48              >            pha         ;use stack to load status
1d6c : 28              >            plp
                        
1d6d : a50c                     lda zp1+3
1d6f : 08                       php         ;test stores do not alter flags
1d70 : 49c3                     eor #$c3
1d72 : 28                       plp
1d73 : 8d0602                   sta abst+3
1d76 : 08                       php         ;flags after load/store sequence
1d77 : 49c3                     eor #$c3
1d79 : c900                     cmp #0      ;test result
                                trap_ne
1d7b : d0fe            >        bne *           ;failed not equal (non zero)
                        
1d7d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1d7e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1d80 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1d83 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1d85 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1d87 : 48              >            pha         ;use stack to load status
1d88 : 28              >            plp
                        
1d89 : ad1702                   lda abs1
1d8c : 08                       php         ;test stores do not alter flags
1d8d : 49c3                     eor #$c3
1d8f : 28                       plp
1d90 : 8502                     sta zpt
1d92 : 08                       php         ;flags after load/store sequence
1d93 : 49c3                     eor #$c3
1d95 : c509                     cmp zp1     ;test result
                                trap_ne
1d97 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1d99 : 68                       pla         ;load status
                                eor_flag 0
1d9a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1d9c : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1d9f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1da1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1da3 : 48              >            pha         ;use stack to load status
1da4 : 28              >            plp
                        
1da5 : ad1802                   lda abs1+1
1da8 : 08                       php         ;test stores do not alter flags
1da9 : 49c3                     eor #$c3
1dab : 28                       plp
1dac : 8503                     sta zpt+1
1dae : 08                       php         ;flags after load/store sequence
1daf : 49c3                     eor #$c3
1db1 : c50a                     cmp zp1+1   ;test result
                                trap_ne
1db3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1db5 : 68                       pla         ;load status
                                eor_flag 0
1db6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1db8 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1dbb : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1dbd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1dbf : 48              >            pha         ;use stack to load status
1dc0 : 28              >            plp
                        
1dc1 : ad1902                   lda abs1+2
1dc4 : 08                       php         ;test stores do not alter flags
1dc5 : 49c3                     eor #$c3
1dc7 : 28                       plp
1dc8 : 8504                     sta zpt+2
1dca : 08                       php         ;flags after load/store sequence
1dcb : 49c3                     eor #$c3
1dcd : c50b                     cmp zp1+2   ;test result
                                trap_ne
1dcf : d0fe            >        bne *           ;failed not equal (non zero)
                        
1dd1 : 68                       pla         ;load status
                                eor_flag 0
1dd2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1dd4 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1dd7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1dd9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ddb : 48              >            pha         ;use stack to load status
1ddc : 28              >            plp
                        
1ddd : ad1a02                   lda abs1+3
1de0 : 08                       php         ;test stores do not alter flags
1de1 : 49c3                     eor #$c3
1de3 : 28                       plp
1de4 : 8505                     sta zpt+3
1de6 : 08                       php         ;flags after load/store sequence
1de7 : 49c3                     eor #$c3
1de9 : c50c                     cmp zp1+3   ;test result
                                trap_ne
1deb : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ded : 68                       pla         ;load status
                                eor_flag 0
1dee : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1df0 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1df3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1df5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1df7 : 48              >            pha         ;use stack to load status
1df8 : 28              >            plp
                        
1df9 : ad1702                   lda abs1
1dfc : 08                       php         ;test stores do not alter flags
1dfd : 49c3                     eor #$c3
1dff : 28                       plp
1e00 : 8502                     sta zpt
1e02 : 08                       php         ;flags after load/store sequence
1e03 : 49c3                     eor #$c3
1e05 : c509                     cmp zp1     ;test result
                                trap_ne
1e07 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1e09 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1e0a : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1e0c : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1e0f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1e11 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1e13 : 48              >            pha         ;use stack to load status
1e14 : 28              >            plp
                        
1e15 : ad1802                   lda abs1+1
1e18 : 08                       php         ;test stores do not alter flags
1e19 : 49c3                     eor #$c3
1e1b : 28                       plp
1e1c : 8503                     sta zpt+1
1e1e : 08                       php         ;flags after load/store sequence
1e1f : 49c3                     eor #$c3
1e21 : c50a                     cmp zp1+1   ;test result
                                trap_ne
1e23 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1e25 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1e26 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1e28 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1e2b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1e2d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1e2f : 48              >            pha         ;use stack to load status
1e30 : 28              >            plp
                        
1e31 : ad1902                   lda abs1+2
1e34 : 08                       php         ;test stores do not alter flags
1e35 : 49c3                     eor #$c3
1e37 : 28                       plp
1e38 : 8504                     sta zpt+2
1e3a : 08                       php         ;flags after load/store sequence
1e3b : 49c3                     eor #$c3
1e3d : c50b                     cmp zp1+2   ;test result
                                trap_ne
1e3f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1e41 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1e42 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1e44 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1e47 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1e49 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1e4b : 48              >            pha         ;use stack to load status
1e4c : 28              >            plp
                        
1e4d : ad1a02                   lda abs1+3
1e50 : 08                       php         ;test stores do not alter flags
1e51 : 49c3                     eor #$c3
1e53 : 28                       plp
1e54 : 8505                     sta zpt+3
1e56 : 08                       php         ;flags after load/store sequence
1e57 : 49c3                     eor #$c3
1e59 : c50c                     cmp zp1+3   ;test result
                                trap_ne
1e5b : d0fe            >        bne *           ;failed not equal (non zero)
                        
1e5d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1e5e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1e60 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1e63 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1e65 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1e67 : 48              >            pha         ;use stack to load status
1e68 : 28              >            plp
                        
1e69 : a9c3                     lda #$c3
1e6b : 08                       php
1e6c : cd1702                   cmp abs1    ;test result
                                trap_ne
1e6f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1e71 : 68                       pla         ;load status
                                eor_flag 0
1e72 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1e74 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1e77 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1e79 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1e7b : 48              >            pha         ;use stack to load status
1e7c : 28              >            plp
                        
1e7d : a982                     lda #$82
1e7f : 08                       php
1e80 : cd1802                   cmp abs1+1  ;test result
                                trap_ne
1e83 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1e85 : 68                       pla         ;load status
                                eor_flag 0
1e86 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1e88 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1e8b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1e8d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1e8f : 48              >            pha         ;use stack to load status
1e90 : 28              >            plp
                        
1e91 : a941                     lda #$41
1e93 : 08                       php
1e94 : cd1902                   cmp abs1+2  ;test result
                                trap_ne
1e97 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1e99 : 68                       pla         ;load status
                                eor_flag 0
1e9a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1e9c : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1e9f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1ea1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ea3 : 48              >            pha         ;use stack to load status
1ea4 : 28              >            plp
                        
1ea5 : a900                     lda #0
1ea7 : 08                       php
1ea8 : cd1a02                   cmp abs1+3  ;test result
                                trap_ne
1eab : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ead : 68                       pla         ;load status
                                eor_flag 0
1eae : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1eb0 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1eb3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1eb5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1eb7 : 48              >            pha         ;use stack to load status
1eb8 : 28              >            plp
                        
1eb9 : a9c3                     lda #$c3
1ebb : 08                       php
1ebc : cd1702                   cmp abs1    ;test result
                                trap_ne
1ebf : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ec1 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1ec2 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1ec4 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1ec7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1ec9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ecb : 48              >            pha         ;use stack to load status
1ecc : 28              >            plp
                        
1ecd : a982                     lda #$82
1ecf : 08                       php
1ed0 : cd1802                   cmp abs1+1  ;test result
                                trap_ne
1ed3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ed5 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1ed6 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1ed8 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1edb : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1edd : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1edf : 48              >            pha         ;use stack to load status
1ee0 : 28              >            plp
                        
1ee1 : a941                     lda #$41
1ee3 : 08                       php
1ee4 : cd1902                   cmp abs1+2  ;test result
                                trap_ne
1ee7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ee9 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1eea : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1eec : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1eef : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1ef1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ef3 : 48              >            pha         ;use stack to load status
1ef4 : 28              >            plp
                        
1ef5 : a900                     lda #0
1ef7 : 08                       php
1ef8 : cd1a02                   cmp abs1+3  ;test result
                                trap_ne
1efb : d0fe            >        bne *           ;failed not equal (non zero)
                        
1efd : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1efe : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1f00 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1f03 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
1f05 : a200                     ldx #0
1f07 : a502                     lda zpt
1f09 : 49c3                     eor #$c3
1f0b : c509                     cmp zp1
                                trap_ne     ;store to zp data
1f0d : d0fe            >        bne *           ;failed not equal (non zero)
                        
1f0f : 8602                     stx zpt     ;clear
1f11 : ad0302                   lda abst
1f14 : 49c3                     eor #$c3
1f16 : cd1702                   cmp abs1
                                trap_ne     ;store to abs data
1f19 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1f1b : 8e0302                   stx abst    ;clear
1f1e : a503                     lda zpt+1
1f20 : 49c3                     eor #$c3
1f22 : c50a                     cmp zp1+1
                                trap_ne     ;store to zp data
1f24 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1f26 : 8603                     stx zpt+1   ;clear
1f28 : ad0402                   lda abst+1
1f2b : 49c3                     eor #$c3
1f2d : cd1802                   cmp abs1+1
                                trap_ne     ;store to abs data
1f30 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1f32 : 8e0402                   stx abst+1  ;clear
1f35 : a504                     lda zpt+2
1f37 : 49c3                     eor #$c3
1f39 : c50b                     cmp zp1+2
                                trap_ne     ;store to zp data
1f3b : d0fe            >        bne *           ;failed not equal (non zero)
                        
1f3d : 8604                     stx zpt+2   ;clear
1f3f : ad0502                   lda abst+2
1f42 : 49c3                     eor #$c3
1f44 : cd1902                   cmp abs1+2
                                trap_ne     ;store to abs data
1f47 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1f49 : 8e0502                   stx abst+2  ;clear
1f4c : a505                     lda zpt+3
1f4e : 49c3                     eor #$c3
1f50 : c50c                     cmp zp1+3
                                trap_ne     ;store to zp data
1f52 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1f54 : 8605                     stx zpt+3   ;clear
1f56 : ad0602                   lda abst+3
1f59 : 49c3                     eor #$c3
1f5b : cd1a02                   cmp abs1+3
                                trap_ne     ;store to abs data
1f5e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1f60 : 8e0602                   stx abst+3  ;clear
                                next_test
1f63 : ad0002          >            lda test_case   ;previous test
1f66 : c918            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1f68 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0019 =                 >test_num = test_num + 1
1f6a : a919            >            lda #test_num   ;*** next tests' number
1f6c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing bit test & compares BIT CPX CPY CMP all addressing modes
                        ; BIT - zp / abs
                                set_a $ff,0
                       >            load_flag 0
1f6f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f71 : 48              >            pha         ;use stack to load status
1f72 : a9ff            >            lda #$ff     ;precharge accu
1f74 : 28              >            plp
                        
1f75 : 240c                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,fz
1f77 : 08              >            php         ;save flags
1f78 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1f7a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f7c : 68              >            pla         ;load status
1f7d : 48              >            pha
                       >            cmp_flag fz
1f7e : c932            >            cmp #(fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f80 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f82 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1f83 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f85 : 48              >            pha         ;use stack to load status
1f86 : a901            >            lda #1     ;precharge accu
1f88 : 28              >            plp
                        
1f89 : 240b                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
1f8b : 08              >            php         ;save flags
1f8c : c901            >            cmp #1     ;test result
                       >            trap_ne
1f8e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f90 : 68              >            pla         ;load status
1f91 : 48              >            pha
                       >            cmp_flag fv
1f92 : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f94 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f96 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1f97 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f99 : 48              >            pha         ;use stack to load status
1f9a : a901            >            lda #1     ;precharge accu
1f9c : 28              >            plp
                        
1f9d : 240a                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
1f9f : 08              >            php         ;save flags
1fa0 : c901            >            cmp #1     ;test result
                       >            trap_ne
1fa2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fa4 : 68              >            pla         ;load status
1fa5 : 48              >            pha
                       >            cmp_flag fnz
1fa6 : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fa8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1faa : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1fab : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1fad : 48              >            pha         ;use stack to load status
1fae : a901            >            lda #1     ;precharge accu
1fb0 : 28              >            plp
                        
1fb1 : 2409                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
1fb3 : 08              >            php         ;save flags
1fb4 : c901            >            cmp #1     ;test result
                       >            trap_ne
1fb6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fb8 : 68              >            pla         ;load status
1fb9 : 48              >            pha
                       >            cmp_flag fnv
1fba : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fbc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fbe : 28              >            plp         ;restore status
                        
                        
                                set_a $ff,$ff
                       >            load_flag $ff
1fbf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1fc1 : 48              >            pha         ;use stack to load status
1fc2 : a9ff            >            lda #$ff     ;precharge accu
1fc4 : 28              >            plp
                        
1fc5 : 240c                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv
1fc7 : 08              >            php         ;save flags
1fc8 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1fca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fcc : 68              >            pla         ;load status
1fcd : 48              >            pha
                       >            cmp_flag ~fnv
1fce : c93f            >            cmp #(~fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fd0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fd2 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1fd3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1fd5 : 48              >            pha         ;use stack to load status
1fd6 : a901            >            lda #1     ;precharge accu
1fd8 : 28              >            plp
                        
1fd9 : 240b                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
1fdb : 08              >            php         ;save flags
1fdc : c901            >            cmp #1     ;test result
                       >            trap_ne
1fde : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fe0 : 68              >            pla         ;load status
1fe1 : 48              >            pha
                       >            cmp_flag ~fnz
1fe2 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fe4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fe6 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1fe7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1fe9 : 48              >            pha         ;use stack to load status
1fea : a901            >            lda #1     ;precharge accu
1fec : 28              >            plp
                        
1fed : 240a                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
1fef : 08              >            php         ;save flags
1ff0 : c901            >            cmp #1     ;test result
                       >            trap_ne
1ff2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ff4 : 68              >            pla         ;load status
1ff5 : 48              >            pha
                       >            cmp_flag ~fv
1ff6 : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ff8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ffa : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1ffb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ffd : 48              >            pha         ;use stack to load status
1ffe : a901            >            lda #1     ;precharge accu
2000 : 28              >            plp
                        
2001 : 2409                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
2003 : 08              >            php         ;save flags
2004 : c901            >            cmp #1     ;test result
                       >            trap_ne
2006 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2008 : 68              >            pla         ;load status
2009 : 48              >            pha
                       >            cmp_flag ~fz
200a : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
200c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
200e : 28              >            plp         ;restore status
                        
                        
                                set_a $ff,0
                       >            load_flag 0
200f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2011 : 48              >            pha         ;use stack to load status
2012 : a9ff            >            lda #$ff     ;precharge accu
2014 : 28              >            plp
                        
2015 : 2c1a02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,fz
2018 : 08              >            php         ;save flags
2019 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
201b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
201d : 68              >            pla         ;load status
201e : 48              >            pha
                       >            cmp_flag fz
201f : c932            >            cmp #(fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2021 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2023 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
2024 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2026 : 48              >            pha         ;use stack to load status
2027 : a901            >            lda #1     ;precharge accu
2029 : 28              >            plp
                        
202a : 2c1902                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
202d : 08              >            php         ;save flags
202e : c901            >            cmp #1     ;test result
                       >            trap_ne
2030 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2032 : 68              >            pla         ;load status
2033 : 48              >            pha
                       >            cmp_flag fv
2034 : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2036 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2038 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
2039 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
203b : 48              >            pha         ;use stack to load status
203c : a901            >            lda #1     ;precharge accu
203e : 28              >            plp
                        
203f : 2c1802                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
2042 : 08              >            php         ;save flags
2043 : c901            >            cmp #1     ;test result
                       >            trap_ne
2045 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2047 : 68              >            pla         ;load status
2048 : 48              >            pha
                       >            cmp_flag fnz
2049 : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
204b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
204d : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
204e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2050 : 48              >            pha         ;use stack to load status
2051 : a901            >            lda #1     ;precharge accu
2053 : 28              >            plp
                        
2054 : 2c1702                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
2057 : 08              >            php         ;save flags
2058 : c901            >            cmp #1     ;test result
                       >            trap_ne
205a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
205c : 68              >            pla         ;load status
205d : 48              >            pha
                       >            cmp_flag fnv
205e : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2060 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2062 : 28              >            plp         ;restore status
                        
                        
                                set_a $ff,$ff
                       >            load_flag $ff
2063 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2065 : 48              >            pha         ;use stack to load status
2066 : a9ff            >            lda #$ff     ;precharge accu
2068 : 28              >            plp
                        
2069 : 2c1a02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv
206c : 08              >            php         ;save flags
206d : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
206f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2071 : 68              >            pla         ;load status
2072 : 48              >            pha
                       >            cmp_flag ~fnv
2073 : c93f            >            cmp #(~fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2075 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2077 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
2078 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
207a : 48              >            pha         ;use stack to load status
207b : a901            >            lda #1     ;precharge accu
207d : 28              >            plp
                        
207e : 2c1902                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
2081 : 08              >            php         ;save flags
2082 : c901            >            cmp #1     ;test result
                       >            trap_ne
2084 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2086 : 68              >            pla         ;load status
2087 : 48              >            pha
                       >            cmp_flag ~fnz
2088 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
208a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
208c : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
208d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
208f : 48              >            pha         ;use stack to load status
2090 : a901            >            lda #1     ;precharge accu
2092 : 28              >            plp
                        
2093 : 2c1802                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
2096 : 08              >            php         ;save flags
2097 : c901            >            cmp #1     ;test result
                       >            trap_ne
2099 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
209b : 68              >            pla         ;load status
209c : 48              >            pha
                       >            cmp_flag ~fv
209d : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
209f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20a1 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
20a2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
20a4 : 48              >            pha         ;use stack to load status
20a5 : a901            >            lda #1     ;precharge accu
20a7 : 28              >            plp
                        
20a8 : 2c1702                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
20ab : 08              >            php         ;save flags
20ac : c901            >            cmp #1     ;test result
                       >            trap_ne
20ae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20b0 : 68              >            pla         ;load status
20b1 : 48              >            pha
                       >            cmp_flag ~fz
20b2 : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20b4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20b6 : 28              >            plp         ;restore status
                        
                                next_test
20b7 : ad0002          >            lda test_case   ;previous test
20ba : c919            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
20bc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001a =                 >test_num = test_num + 1
20be : a91a            >            lda #test_num   ;*** next tests' number
20c0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CPX - zp / abs / #
                                set_x $80,0
                       >            load_flag 0
20c3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
20c5 : 48              >            pha         ;use stack to load status
20c6 : a280            >            ldx #$80     ;precharge index x
20c8 : 28              >            plp
                        
20c9 : e40d                     cpx zp7f
                                tst_stat fc
20cb : 08              >            php         ;save status
20cc : 68              >            pla         ;use stack to retrieve status
20cd : 48              >            pha
                       >            cmp_flag fc
20ce : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20d0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20d2 : 28              >            plp         ;restore status
                        
20d3 : ca                       dex
20d4 : e40d                     cpx zp7f
                                tst_stat fzc
20d6 : 08              >            php         ;save status
20d7 : 68              >            pla         ;use stack to retrieve status
20d8 : 48              >            pha
                       >            cmp_flag fzc
20d9 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20db : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20dd : 28              >            plp         ;restore status
                        
20de : ca                       dex
20df : e40d                     cpx zp7f
                                tst_x $7e,fn
20e1 : 08              >            php         ;save flags
20e2 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
20e4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20e6 : 68              >            pla         ;load status
20e7 : 48              >            pha
                       >            cmp_flag fn
20e8 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20ea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20ec : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
20ed : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
20ef : 48              >            pha         ;use stack to load status
20f0 : a280            >            ldx #$80     ;precharge index x
20f2 : 28              >            plp
                        
20f3 : e40d                     cpx zp7f
                                tst_stat ~fnz
20f5 : 08              >            php         ;save status
20f6 : 68              >            pla         ;use stack to retrieve status
20f7 : 48              >            pha
                       >            cmp_flag ~fnz
20f8 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20fa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20fc : 28              >            plp         ;restore status
                        
20fd : ca                       dex
20fe : e40d                     cpx zp7f
                                tst_stat ~fn
2100 : 08              >            php         ;save status
2101 : 68              >            pla         ;use stack to retrieve status
2102 : 48              >            pha
                       >            cmp_flag ~fn
2103 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2105 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2107 : 28              >            plp         ;restore status
                        
2108 : ca                       dex
2109 : e40d                     cpx zp7f
                                tst_x $7e,~fzc
210b : 08              >            php         ;save flags
210c : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
210e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2110 : 68              >            pla         ;load status
2111 : 48              >            pha
                       >            cmp_flag ~fzc
2112 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2114 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2116 : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
2117 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2119 : 48              >            pha         ;use stack to load status
211a : a280            >            ldx #$80     ;precharge index x
211c : 28              >            plp
                        
211d : ec1b02                   cpx abs7f
                                tst_stat fc
2120 : 08              >            php         ;save status
2121 : 68              >            pla         ;use stack to retrieve status
2122 : 48              >            pha
                       >            cmp_flag fc
2123 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2125 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2127 : 28              >            plp         ;restore status
                        
2128 : ca                       dex
2129 : ec1b02                   cpx abs7f
                                tst_stat fzc
212c : 08              >            php         ;save status
212d : 68              >            pla         ;use stack to retrieve status
212e : 48              >            pha
                       >            cmp_flag fzc
212f : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2131 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2133 : 28              >            plp         ;restore status
                        
2134 : ca                       dex
2135 : ec1b02                   cpx abs7f
                                tst_x $7e,fn
2138 : 08              >            php         ;save flags
2139 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
213b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
213d : 68              >            pla         ;load status
213e : 48              >            pha
                       >            cmp_flag fn
213f : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2141 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2143 : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
2144 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2146 : 48              >            pha         ;use stack to load status
2147 : a280            >            ldx #$80     ;precharge index x
2149 : 28              >            plp
                        
214a : ec1b02                   cpx abs7f
                                tst_stat ~fnz
214d : 08              >            php         ;save status
214e : 68              >            pla         ;use stack to retrieve status
214f : 48              >            pha
                       >            cmp_flag ~fnz
2150 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2152 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2154 : 28              >            plp         ;restore status
                        
2155 : ca                       dex
2156 : ec1b02                   cpx abs7f
                                tst_stat ~fn
2159 : 08              >            php         ;save status
215a : 68              >            pla         ;use stack to retrieve status
215b : 48              >            pha
                       >            cmp_flag ~fn
215c : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
215e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2160 : 28              >            plp         ;restore status
                        
2161 : ca                       dex
2162 : ec1b02                   cpx abs7f
                                tst_x $7e,~fzc
2165 : 08              >            php         ;save flags
2166 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
2168 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
216a : 68              >            pla         ;load status
216b : 48              >            pha
                       >            cmp_flag ~fzc
216c : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
216e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2170 : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
2171 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2173 : 48              >            pha         ;use stack to load status
2174 : a280            >            ldx #$80     ;precharge index x
2176 : 28              >            plp
                        
2177 : e07f                     cpx #$7f
                                tst_stat fc
2179 : 08              >            php         ;save status
217a : 68              >            pla         ;use stack to retrieve status
217b : 48              >            pha
                       >            cmp_flag fc
217c : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
217e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2180 : 28              >            plp         ;restore status
                        
2181 : ca                       dex
2182 : e07f                     cpx #$7f
                                tst_stat fzc
2184 : 08              >            php         ;save status
2185 : 68              >            pla         ;use stack to retrieve status
2186 : 48              >            pha
                       >            cmp_flag fzc
2187 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2189 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
218b : 28              >            plp         ;restore status
                        
218c : ca                       dex
218d : e07f                     cpx #$7f
                                tst_x $7e,fn
218f : 08              >            php         ;save flags
2190 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
2192 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2194 : 68              >            pla         ;load status
2195 : 48              >            pha
                       >            cmp_flag fn
2196 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2198 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
219a : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
219b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
219d : 48              >            pha         ;use stack to load status
219e : a280            >            ldx #$80     ;precharge index x
21a0 : 28              >            plp
                        
21a1 : e07f                     cpx #$7f
                                tst_stat ~fnz
21a3 : 08              >            php         ;save status
21a4 : 68              >            pla         ;use stack to retrieve status
21a5 : 48              >            pha
                       >            cmp_flag ~fnz
21a6 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21a8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21aa : 28              >            plp         ;restore status
                        
21ab : ca                       dex
21ac : e07f                     cpx #$7f
                                tst_stat ~fn
21ae : 08              >            php         ;save status
21af : 68              >            pla         ;use stack to retrieve status
21b0 : 48              >            pha
                       >            cmp_flag ~fn
21b1 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21b3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21b5 : 28              >            plp         ;restore status
                        
21b6 : ca                       dex
21b7 : e07f                     cpx #$7f
                                tst_x $7e,~fzc
21b9 : 08              >            php         ;save flags
21ba : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
21bc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21be : 68              >            pla         ;load status
21bf : 48              >            pha
                       >            cmp_flag ~fzc
21c0 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21c2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21c4 : 28              >            plp         ;restore status
                        
                                next_test
21c5 : ad0002          >            lda test_case   ;previous test
21c8 : c91a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
21ca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001b =                 >test_num = test_num + 1
21cc : a91b            >            lda #test_num   ;*** next tests' number
21ce : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CPY - zp / abs / #
                                set_y $80,0
                       >            load_flag 0
21d1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
21d3 : 48              >            pha         ;use stack to load status
21d4 : a080            >            ldy #$80     ;precharge index y
21d6 : 28              >            plp
                        
21d7 : c40d                     cpy zp7f
                                tst_stat fc
21d9 : 08              >            php         ;save status
21da : 68              >            pla         ;use stack to retrieve status
21db : 48              >            pha
                       >            cmp_flag fc
21dc : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21de : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21e0 : 28              >            plp         ;restore status
                        
21e1 : 88                       dey
21e2 : c40d                     cpy zp7f
                                tst_stat fzc
21e4 : 08              >            php         ;save status
21e5 : 68              >            pla         ;use stack to retrieve status
21e6 : 48              >            pha
                       >            cmp_flag fzc
21e7 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21e9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21eb : 28              >            plp         ;restore status
                        
21ec : 88                       dey
21ed : c40d                     cpy zp7f
                                tst_y $7e,fn
21ef : 08              >            php         ;save flags
21f0 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
21f2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21f4 : 68              >            pla         ;load status
21f5 : 48              >            pha
                       >            cmp_flag fn
21f6 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21f8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21fa : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
21fb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
21fd : 48              >            pha         ;use stack to load status
21fe : a080            >            ldy #$80     ;precharge index y
2200 : 28              >            plp
                        
2201 : c40d                     cpy zp7f
                                tst_stat ~fnz
2203 : 08              >            php         ;save status
2204 : 68              >            pla         ;use stack to retrieve status
2205 : 48              >            pha
                       >            cmp_flag ~fnz
2206 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2208 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
220a : 28              >            plp         ;restore status
                        
220b : 88                       dey
220c : c40d                     cpy zp7f
                                tst_stat ~fn
220e : 08              >            php         ;save status
220f : 68              >            pla         ;use stack to retrieve status
2210 : 48              >            pha
                       >            cmp_flag ~fn
2211 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2213 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2215 : 28              >            plp         ;restore status
                        
2216 : 88                       dey
2217 : c40d                     cpy zp7f
                                tst_y $7e,~fzc
2219 : 08              >            php         ;save flags
221a : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
221c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
221e : 68              >            pla         ;load status
221f : 48              >            pha
                       >            cmp_flag ~fzc
2220 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2222 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2224 : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
2225 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2227 : 48              >            pha         ;use stack to load status
2228 : a080            >            ldy #$80     ;precharge index y
222a : 28              >            plp
                        
222b : cc1b02                   cpy abs7f
                                tst_stat fc
222e : 08              >            php         ;save status
222f : 68              >            pla         ;use stack to retrieve status
2230 : 48              >            pha
                       >            cmp_flag fc
2231 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2233 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2235 : 28              >            plp         ;restore status
                        
2236 : 88                       dey
2237 : cc1b02                   cpy abs7f
                                tst_stat fzc
223a : 08              >            php         ;save status
223b : 68              >            pla         ;use stack to retrieve status
223c : 48              >            pha
                       >            cmp_flag fzc
223d : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
223f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2241 : 28              >            plp         ;restore status
                        
2242 : 88                       dey
2243 : cc1b02                   cpy abs7f
                                tst_y $7e,fn
2246 : 08              >            php         ;save flags
2247 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
2249 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
224b : 68              >            pla         ;load status
224c : 48              >            pha
                       >            cmp_flag fn
224d : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
224f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2251 : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
2252 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2254 : 48              >            pha         ;use stack to load status
2255 : a080            >            ldy #$80     ;precharge index y
2257 : 28              >            plp
                        
2258 : cc1b02                   cpy abs7f
                                tst_stat ~fnz
225b : 08              >            php         ;save status
225c : 68              >            pla         ;use stack to retrieve status
225d : 48              >            pha
                       >            cmp_flag ~fnz
225e : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2260 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2262 : 28              >            plp         ;restore status
                        
2263 : 88                       dey
2264 : cc1b02                   cpy abs7f
                                tst_stat ~fn
2267 : 08              >            php         ;save status
2268 : 68              >            pla         ;use stack to retrieve status
2269 : 48              >            pha
                       >            cmp_flag ~fn
226a : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
226c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
226e : 28              >            plp         ;restore status
                        
226f : 88                       dey
2270 : cc1b02                   cpy abs7f
                                tst_y $7e,~fzc
2273 : 08              >            php         ;save flags
2274 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
2276 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2278 : 68              >            pla         ;load status
2279 : 48              >            pha
                       >            cmp_flag ~fzc
227a : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
227c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
227e : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
227f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2281 : 48              >            pha         ;use stack to load status
2282 : a080            >            ldy #$80     ;precharge index y
2284 : 28              >            plp
                        
2285 : c07f                     cpy #$7f
                                tst_stat fc
2287 : 08              >            php         ;save status
2288 : 68              >            pla         ;use stack to retrieve status
2289 : 48              >            pha
                       >            cmp_flag fc
228a : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
228c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
228e : 28              >            plp         ;restore status
                        
228f : 88                       dey
2290 : c07f                     cpy #$7f
                                tst_stat fzc
2292 : 08              >            php         ;save status
2293 : 68              >            pla         ;use stack to retrieve status
2294 : 48              >            pha
                       >            cmp_flag fzc
2295 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2297 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2299 : 28              >            plp         ;restore status
                        
229a : 88                       dey
229b : c07f                     cpy #$7f
                                tst_y $7e,fn
229d : 08              >            php         ;save flags
229e : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
22a0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22a2 : 68              >            pla         ;load status
22a3 : 48              >            pha
                       >            cmp_flag fn
22a4 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
22a6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22a8 : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
22a9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
22ab : 48              >            pha         ;use stack to load status
22ac : a080            >            ldy #$80     ;precharge index y
22ae : 28              >            plp
                        
22af : c07f                     cpy #$7f
                                tst_stat ~fnz
22b1 : 08              >            php         ;save status
22b2 : 68              >            pla         ;use stack to retrieve status
22b3 : 48              >            pha
                       >            cmp_flag ~fnz
22b4 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
22b6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22b8 : 28              >            plp         ;restore status
                        
22b9 : 88                       dey
22ba : c07f                     cpy #$7f
                                tst_stat ~fn
22bc : 08              >            php         ;save status
22bd : 68              >            pla         ;use stack to retrieve status
22be : 48              >            pha
                       >            cmp_flag ~fn
22bf : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
22c1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22c3 : 28              >            plp         ;restore status
                        
22c4 : 88                       dey
22c5 : c07f                     cpy #$7f
                                tst_y $7e,~fzc
22c7 : 08              >            php         ;save flags
22c8 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
22ca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22cc : 68              >            pla         ;load status
22cd : 48              >            pha
                       >            cmp_flag ~fzc
22ce : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
22d0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22d2 : 28              >            plp         ;restore status
                        
                                next_test
22d3 : ad0002          >            lda test_case   ;previous test
22d6 : c91b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
22d8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001c =                 >test_num = test_num + 1
22da : a91c            >            lda #test_num   ;*** next tests' number
22dc : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CMP - zp / abs / #
                                set_a $80,0
                       >            load_flag 0
22df : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
22e1 : 48              >            pha         ;use stack to load status
22e2 : a980            >            lda #$80     ;precharge accu
22e4 : 28              >            plp
                        
22e5 : c50d                     cmp zp7f
                                tst_a $80,fc
22e7 : 08              >            php         ;save flags
22e8 : c980            >            cmp #$80     ;test result
                       >            trap_ne
22ea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22ec : 68              >            pla         ;load status
22ed : 48              >            pha
                       >            cmp_flag fc
22ee : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
22f0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22f2 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
22f3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
22f5 : 48              >            pha         ;use stack to load status
22f6 : a97f            >            lda #$7f     ;precharge accu
22f8 : 28              >            plp
                        
22f9 : c50d                     cmp zp7f
                                tst_a $7f,fzc
22fb : 08              >            php         ;save flags
22fc : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
22fe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2300 : 68              >            pla         ;load status
2301 : 48              >            pha
                       >            cmp_flag fzc
2302 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2304 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2306 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2307 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2309 : 48              >            pha         ;use stack to load status
230a : a97e            >            lda #$7e     ;precharge accu
230c : 28              >            plp
                        
230d : c50d                     cmp zp7f
                                tst_a $7e,fn
230f : 08              >            php         ;save flags
2310 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2312 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2314 : 68              >            pla         ;load status
2315 : 48              >            pha
                       >            cmp_flag fn
2316 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2318 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
231a : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
231b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
231d : 48              >            pha         ;use stack to load status
231e : a980            >            lda #$80     ;precharge accu
2320 : 28              >            plp
                        
2321 : c50d                     cmp zp7f
                                tst_a $80,~fnz
2323 : 08              >            php         ;save flags
2324 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2326 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2328 : 68              >            pla         ;load status
2329 : 48              >            pha
                       >            cmp_flag ~fnz
232a : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
232c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
232e : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
232f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2331 : 48              >            pha         ;use stack to load status
2332 : a97f            >            lda #$7f     ;precharge accu
2334 : 28              >            plp
                        
2335 : c50d                     cmp zp7f
                                tst_a $7f,~fn
2337 : 08              >            php         ;save flags
2338 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
233a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
233c : 68              >            pla         ;load status
233d : 48              >            pha
                       >            cmp_flag ~fn
233e : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2340 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2342 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2343 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2345 : 48              >            pha         ;use stack to load status
2346 : a97e            >            lda #$7e     ;precharge accu
2348 : 28              >            plp
                        
2349 : c50d                     cmp zp7f
                                tst_a $7e,~fzc
234b : 08              >            php         ;save flags
234c : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
234e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2350 : 68              >            pla         ;load status
2351 : 48              >            pha
                       >            cmp_flag ~fzc
2352 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2354 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2356 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
2357 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2359 : 48              >            pha         ;use stack to load status
235a : a980            >            lda #$80     ;precharge accu
235c : 28              >            plp
                        
235d : cd1b02                   cmp abs7f
                                tst_a $80,fc
2360 : 08              >            php         ;save flags
2361 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2363 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2365 : 68              >            pla         ;load status
2366 : 48              >            pha
                       >            cmp_flag fc
2367 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2369 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
236b : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
236c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
236e : 48              >            pha         ;use stack to load status
236f : a97f            >            lda #$7f     ;precharge accu
2371 : 28              >            plp
                        
2372 : cd1b02                   cmp abs7f
                                tst_a $7f,fzc
2375 : 08              >            php         ;save flags
2376 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2378 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
237a : 68              >            pla         ;load status
237b : 48              >            pha
                       >            cmp_flag fzc
237c : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
237e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2380 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2381 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2383 : 48              >            pha         ;use stack to load status
2384 : a97e            >            lda #$7e     ;precharge accu
2386 : 28              >            plp
                        
2387 : cd1b02                   cmp abs7f
                                tst_a $7e,fn
238a : 08              >            php         ;save flags
238b : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
238d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
238f : 68              >            pla         ;load status
2390 : 48              >            pha
                       >            cmp_flag fn
2391 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2393 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2395 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2396 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2398 : 48              >            pha         ;use stack to load status
2399 : a980            >            lda #$80     ;precharge accu
239b : 28              >            plp
                        
239c : cd1b02                   cmp abs7f
                                tst_a $80,~fnz
239f : 08              >            php         ;save flags
23a0 : c980            >            cmp #$80     ;test result
                       >            trap_ne
23a2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23a4 : 68              >            pla         ;load status
23a5 : 48              >            pha
                       >            cmp_flag ~fnz
23a6 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
23a8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23aa : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
23ab : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
23ad : 48              >            pha         ;use stack to load status
23ae : a97f            >            lda #$7f     ;precharge accu
23b0 : 28              >            plp
                        
23b1 : cd1b02                   cmp abs7f
                                tst_a $7f,~fn
23b4 : 08              >            php         ;save flags
23b5 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
23b7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23b9 : 68              >            pla         ;load status
23ba : 48              >            pha
                       >            cmp_flag ~fn
23bb : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
23bd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23bf : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
23c0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
23c2 : 48              >            pha         ;use stack to load status
23c3 : a97e            >            lda #$7e     ;precharge accu
23c5 : 28              >            plp
                        
23c6 : cd1b02                   cmp abs7f
                                tst_a $7e,~fzc
23c9 : 08              >            php         ;save flags
23ca : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
23cc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23ce : 68              >            pla         ;load status
23cf : 48              >            pha
                       >            cmp_flag ~fzc
23d0 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
23d2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23d4 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
23d5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
23d7 : 48              >            pha         ;use stack to load status
23d8 : a980            >            lda #$80     ;precharge accu
23da : 28              >            plp
                        
23db : c97f                     cmp #$7f
                                tst_a $80,fc
23dd : 08              >            php         ;save flags
23de : c980            >            cmp #$80     ;test result
                       >            trap_ne
23e0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23e2 : 68              >            pla         ;load status
23e3 : 48              >            pha
                       >            cmp_flag fc
23e4 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
23e6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23e8 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
23e9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
23eb : 48              >            pha         ;use stack to load status
23ec : a97f            >            lda #$7f     ;precharge accu
23ee : 28              >            plp
                        
23ef : c97f                     cmp #$7f
                                tst_a $7f,fzc
23f1 : 08              >            php         ;save flags
23f2 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
23f4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23f6 : 68              >            pla         ;load status
23f7 : 48              >            pha
                       >            cmp_flag fzc
23f8 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
23fa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23fc : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
23fd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
23ff : 48              >            pha         ;use stack to load status
2400 : a97e            >            lda #$7e     ;precharge accu
2402 : 28              >            plp
                        
2403 : c97f                     cmp #$7f
                                tst_a $7e,fn
2405 : 08              >            php         ;save flags
2406 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2408 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
240a : 68              >            pla         ;load status
240b : 48              >            pha
                       >            cmp_flag fn
240c : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
240e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2410 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2411 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2413 : 48              >            pha         ;use stack to load status
2414 : a980            >            lda #$80     ;precharge accu
2416 : 28              >            plp
                        
2417 : c97f                     cmp #$7f
                                tst_a $80,~fnz
2419 : 08              >            php         ;save flags
241a : c980            >            cmp #$80     ;test result
                       >            trap_ne
241c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
241e : 68              >            pla         ;load status
241f : 48              >            pha
                       >            cmp_flag ~fnz
2420 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2422 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2424 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
2425 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2427 : 48              >            pha         ;use stack to load status
2428 : a97f            >            lda #$7f     ;precharge accu
242a : 28              >            plp
                        
242b : c97f                     cmp #$7f
                                tst_a $7f,~fn
242d : 08              >            php         ;save flags
242e : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2430 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2432 : 68              >            pla         ;load status
2433 : 48              >            pha
                       >            cmp_flag ~fn
2434 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2436 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2438 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2439 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
243b : 48              >            pha         ;use stack to load status
243c : a97e            >            lda #$7e     ;precharge accu
243e : 28              >            plp
                        
243f : c97f                     cmp #$7f
                                tst_a $7e,~fzc
2441 : 08              >            php         ;save flags
2442 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2444 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2446 : 68              >            pla         ;load status
2447 : 48              >            pha
                       >            cmp_flag ~fzc
2448 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
244a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
244c : 28              >            plp         ;restore status
                        
                        
244d : a204                     ldx #4          ;with indexing by X
                                set_a $80,0
                       >            load_flag 0
244f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2451 : 48              >            pha         ;use stack to load status
2452 : a980            >            lda #$80     ;precharge accu
2454 : 28              >            plp
                        
2455 : d509                     cmp zp1,x
                                tst_a $80,fc
2457 : 08              >            php         ;save flags
2458 : c980            >            cmp #$80     ;test result
                       >            trap_ne
245a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
245c : 68              >            pla         ;load status
245d : 48              >            pha
                       >            cmp_flag fc
245e : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2460 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2462 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2463 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2465 : 48              >            pha         ;use stack to load status
2466 : a97f            >            lda #$7f     ;precharge accu
2468 : 28              >            plp
                        
2469 : d509                     cmp zp1,x
                                tst_a $7f,fzc
246b : 08              >            php         ;save flags
246c : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
246e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2470 : 68              >            pla         ;load status
2471 : 48              >            pha
                       >            cmp_flag fzc
2472 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2474 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2476 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2477 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2479 : 48              >            pha         ;use stack to load status
247a : a97e            >            lda #$7e     ;precharge accu
247c : 28              >            plp
                        
247d : d509                     cmp zp1,x
                                tst_a $7e,fn
247f : 08              >            php         ;save flags
2480 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2482 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2484 : 68              >            pla         ;load status
2485 : 48              >            pha
                       >            cmp_flag fn
2486 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2488 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
248a : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
248b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
248d : 48              >            pha         ;use stack to load status
248e : a980            >            lda #$80     ;precharge accu
2490 : 28              >            plp
                        
2491 : d509                     cmp zp1,x
                                tst_a $80,~fnz
2493 : 08              >            php         ;save flags
2494 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2496 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2498 : 68              >            pla         ;load status
2499 : 48              >            pha
                       >            cmp_flag ~fnz
249a : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
249c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
249e : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
249f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
24a1 : 48              >            pha         ;use stack to load status
24a2 : a97f            >            lda #$7f     ;precharge accu
24a4 : 28              >            plp
                        
24a5 : d509                     cmp zp1,x
                                tst_a $7f,~fn
24a7 : 08              >            php         ;save flags
24a8 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
24aa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24ac : 68              >            pla         ;load status
24ad : 48              >            pha
                       >            cmp_flag ~fn
24ae : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
24b0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24b2 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
24b3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
24b5 : 48              >            pha         ;use stack to load status
24b6 : a97e            >            lda #$7e     ;precharge accu
24b8 : 28              >            plp
                        
24b9 : d509                     cmp zp1,x
                                tst_a $7e,~fzc
24bb : 08              >            php         ;save flags
24bc : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
24be : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24c0 : 68              >            pla         ;load status
24c1 : 48              >            pha
                       >            cmp_flag ~fzc
24c2 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
24c4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24c6 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
24c7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
24c9 : 48              >            pha         ;use stack to load status
24ca : a980            >            lda #$80     ;precharge accu
24cc : 28              >            plp
                        
24cd : dd1702                   cmp abs1,x
                                tst_a $80,fc
24d0 : 08              >            php         ;save flags
24d1 : c980            >            cmp #$80     ;test result
                       >            trap_ne
24d3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24d5 : 68              >            pla         ;load status
24d6 : 48              >            pha
                       >            cmp_flag fc
24d7 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
24d9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24db : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
24dc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
24de : 48              >            pha         ;use stack to load status
24df : a97f            >            lda #$7f     ;precharge accu
24e1 : 28              >            plp
                        
24e2 : dd1702                   cmp abs1,x
                                tst_a $7f,fzc
24e5 : 08              >            php         ;save flags
24e6 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
24e8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24ea : 68              >            pla         ;load status
24eb : 48              >            pha
                       >            cmp_flag fzc
24ec : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
24ee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24f0 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
24f1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
24f3 : 48              >            pha         ;use stack to load status
24f4 : a97e            >            lda #$7e     ;precharge accu
24f6 : 28              >            plp
                        
24f7 : dd1702                   cmp abs1,x
                                tst_a $7e,fn
24fa : 08              >            php         ;save flags
24fb : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
24fd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24ff : 68              >            pla         ;load status
2500 : 48              >            pha
                       >            cmp_flag fn
2501 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2503 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2505 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2506 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2508 : 48              >            pha         ;use stack to load status
2509 : a980            >            lda #$80     ;precharge accu
250b : 28              >            plp
                        
250c : dd1702                   cmp abs1,x
                                tst_a $80,~fnz
250f : 08              >            php         ;save flags
2510 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2512 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2514 : 68              >            pla         ;load status
2515 : 48              >            pha
                       >            cmp_flag ~fnz
2516 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2518 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
251a : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
251b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
251d : 48              >            pha         ;use stack to load status
251e : a97f            >            lda #$7f     ;precharge accu
2520 : 28              >            plp
                        
2521 : dd1702                   cmp abs1,x
                                tst_a $7f,~fn
2524 : 08              >            php         ;save flags
2525 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2527 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2529 : 68              >            pla         ;load status
252a : 48              >            pha
                       >            cmp_flag ~fn
252b : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
252d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
252f : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2530 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2532 : 48              >            pha         ;use stack to load status
2533 : a97e            >            lda #$7e     ;precharge accu
2535 : 28              >            plp
                        
2536 : dd1702                   cmp abs1,x
                                tst_a $7e,~fzc
2539 : 08              >            php         ;save flags
253a : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
253c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
253e : 68              >            pla         ;load status
253f : 48              >            pha
                       >            cmp_flag ~fzc
2540 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2542 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2544 : 28              >            plp         ;restore status
                        
                        
2545 : a004                     ldy #4          ;with indexing by Y
2547 : a208                     ldx #8          ;with indexed indirect
                                set_a $80,0
                       >            load_flag 0
2549 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
254b : 48              >            pha         ;use stack to load status
254c : a980            >            lda #$80     ;precharge accu
254e : 28              >            plp
                        
254f : d91702                   cmp abs1,y
                                tst_a $80,fc
2552 : 08              >            php         ;save flags
2553 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2555 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2557 : 68              >            pla         ;load status
2558 : 48              >            pha
                       >            cmp_flag fc
2559 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
255b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
255d : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
255e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2560 : 48              >            pha         ;use stack to load status
2561 : a97f            >            lda #$7f     ;precharge accu
2563 : 28              >            plp
                        
2564 : d91702                   cmp abs1,y
                                tst_a $7f,fzc
2567 : 08              >            php         ;save flags
2568 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
256a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
256c : 68              >            pla         ;load status
256d : 48              >            pha
                       >            cmp_flag fzc
256e : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2570 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2572 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2573 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2575 : 48              >            pha         ;use stack to load status
2576 : a97e            >            lda #$7e     ;precharge accu
2578 : 28              >            plp
                        
2579 : d91702                   cmp abs1,y
                                tst_a $7e,fn
257c : 08              >            php         ;save flags
257d : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
257f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2581 : 68              >            pla         ;load status
2582 : 48              >            pha
                       >            cmp_flag fn
2583 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2585 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2587 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2588 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
258a : 48              >            pha         ;use stack to load status
258b : a980            >            lda #$80     ;precharge accu
258d : 28              >            plp
                        
258e : d91702                   cmp abs1,y
                                tst_a $80,~fnz
2591 : 08              >            php         ;save flags
2592 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2594 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2596 : 68              >            pla         ;load status
2597 : 48              >            pha
                       >            cmp_flag ~fnz
2598 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
259a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
259c : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
259d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
259f : 48              >            pha         ;use stack to load status
25a0 : a97f            >            lda #$7f     ;precharge accu
25a2 : 28              >            plp
                        
25a3 : d91702                   cmp abs1,y
                                tst_a $7f,~fn
25a6 : 08              >            php         ;save flags
25a7 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
25a9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25ab : 68              >            pla         ;load status
25ac : 48              >            pha
                       >            cmp_flag ~fn
25ad : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
25af : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25b1 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
25b2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
25b4 : 48              >            pha         ;use stack to load status
25b5 : a97e            >            lda #$7e     ;precharge accu
25b7 : 28              >            plp
                        
25b8 : d91702                   cmp abs1,y
                                tst_a $7e,~fzc
25bb : 08              >            php         ;save flags
25bc : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
25be : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25c0 : 68              >            pla         ;load status
25c1 : 48              >            pha
                       >            cmp_flag ~fzc
25c2 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
25c4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25c6 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
25c7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
25c9 : 48              >            pha         ;use stack to load status
25ca : a980            >            lda #$80     ;precharge accu
25cc : 28              >            plp
                        
25cd : c11a                     cmp (ind1,x)
                                tst_a $80,fc
25cf : 08              >            php         ;save flags
25d0 : c980            >            cmp #$80     ;test result
                       >            trap_ne
25d2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25d4 : 68              >            pla         ;load status
25d5 : 48              >            pha
                       >            cmp_flag fc
25d6 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
25d8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25da : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
25db : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
25dd : 48              >            pha         ;use stack to load status
25de : a97f            >            lda #$7f     ;precharge accu
25e0 : 28              >            plp
                        
25e1 : c11a                     cmp (ind1,x)
                                tst_a $7f,fzc
25e3 : 08              >            php         ;save flags
25e4 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
25e6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25e8 : 68              >            pla         ;load status
25e9 : 48              >            pha
                       >            cmp_flag fzc
25ea : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
25ec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25ee : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
25ef : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
25f1 : 48              >            pha         ;use stack to load status
25f2 : a97e            >            lda #$7e     ;precharge accu
25f4 : 28              >            plp
                        
25f5 : c11a                     cmp (ind1,x)
                                tst_a $7e,fn
25f7 : 08              >            php         ;save flags
25f8 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
25fa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25fc : 68              >            pla         ;load status
25fd : 48              >            pha
                       >            cmp_flag fn
25fe : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2600 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2602 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2603 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2605 : 48              >            pha         ;use stack to load status
2606 : a980            >            lda #$80     ;precharge accu
2608 : 28              >            plp
                        
2609 : c11a                     cmp (ind1,x)
                                tst_a $80,~fnz
260b : 08              >            php         ;save flags
260c : c980            >            cmp #$80     ;test result
                       >            trap_ne
260e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2610 : 68              >            pla         ;load status
2611 : 48              >            pha
                       >            cmp_flag ~fnz
2612 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2614 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2616 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
2617 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2619 : 48              >            pha         ;use stack to load status
261a : a97f            >            lda #$7f     ;precharge accu
261c : 28              >            plp
                        
261d : c11a                     cmp (ind1,x)
                                tst_a $7f,~fn
261f : 08              >            php         ;save flags
2620 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2622 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2624 : 68              >            pla         ;load status
2625 : 48              >            pha
                       >            cmp_flag ~fn
2626 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2628 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
262a : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
262b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
262d : 48              >            pha         ;use stack to load status
262e : a97e            >            lda #$7e     ;precharge accu
2630 : 28              >            plp
                        
2631 : c11a                     cmp (ind1,x)
                                tst_a $7e,~fzc
2633 : 08              >            php         ;save flags
2634 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2636 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2638 : 68              >            pla         ;load status
2639 : 48              >            pha
                       >            cmp_flag ~fzc
263a : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
263c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
263e : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
263f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2641 : 48              >            pha         ;use stack to load status
2642 : a980            >            lda #$80     ;precharge accu
2644 : 28              >            plp
                        
2645 : d11a                     cmp (ind1),y
                                tst_a $80,fc
2647 : 08              >            php         ;save flags
2648 : c980            >            cmp #$80     ;test result
                       >            trap_ne
264a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
264c : 68              >            pla         ;load status
264d : 48              >            pha
                       >            cmp_flag fc
264e : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2650 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2652 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2653 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2655 : 48              >            pha         ;use stack to load status
2656 : a97f            >            lda #$7f     ;precharge accu
2658 : 28              >            plp
                        
2659 : d11a                     cmp (ind1),y
                                tst_a $7f,fzc
265b : 08              >            php         ;save flags
265c : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
265e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2660 : 68              >            pla         ;load status
2661 : 48              >            pha
                       >            cmp_flag fzc
2662 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2664 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2666 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2667 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2669 : 48              >            pha         ;use stack to load status
266a : a97e            >            lda #$7e     ;precharge accu
266c : 28              >            plp
                        
266d : d11a                     cmp (ind1),y
                                tst_a $7e,fn
266f : 08              >            php         ;save flags
2670 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2672 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2674 : 68              >            pla         ;load status
2675 : 48              >            pha
                       >            cmp_flag fn
2676 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2678 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
267a : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
267b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
267d : 48              >            pha         ;use stack to load status
267e : a980            >            lda #$80     ;precharge accu
2680 : 28              >            plp
                        
2681 : d11a                     cmp (ind1),y
                                tst_a $80,~fnz
2683 : 08              >            php         ;save flags
2684 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2686 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2688 : 68              >            pla         ;load status
2689 : 48              >            pha
                       >            cmp_flag ~fnz
268a : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
268c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
268e : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
268f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2691 : 48              >            pha         ;use stack to load status
2692 : a97f            >            lda #$7f     ;precharge accu
2694 : 28              >            plp
                        
2695 : d11a                     cmp (ind1),y
                                tst_a $7f,~fn
2697 : 08              >            php         ;save flags
2698 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
269a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
269c : 68              >            pla         ;load status
269d : 48              >            pha
                       >            cmp_flag ~fn
269e : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
26a0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26a2 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
26a3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
26a5 : 48              >            pha         ;use stack to load status
26a6 : a97e            >            lda #$7e     ;precharge accu
26a8 : 28              >            plp
                        
26a9 : d11a                     cmp (ind1),y
                                tst_a $7e,~fzc
26ab : 08              >            php         ;save flags
26ac : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
26ae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26b0 : 68              >            pla         ;load status
26b1 : 48              >            pha
                       >            cmp_flag ~fzc
26b2 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
26b4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26b6 : 28              >            plp         ;restore status
                        
                                next_test
26b7 : ad0002          >            lda test_case   ;previous test
26ba : c91c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
26bc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001d =                 >test_num = test_num + 1
26be : a91d            >            lda #test_num   ;*** next tests' number
26c0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing shifts - ASL LSR ROL ROR all addressing modes
                        ; shifts - accumulator
26c3 : a203                     ldx #3
26c5 :                  tasl
                                set_ax zp1,0
                       >            load_flag 0
26c5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
26c7 : 48              >            pha         ;use stack to load status
26c8 : b509            >            lda zp1,x    ;precharge accu
26ca : 28              >            plp
                        
26cb : 0a                       asl a
                                tst_ax rASL,fASL,0
26cc : 08              >            php         ;save flags
26cd : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
26d0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26d2 : 68              >            pla         ;load status
                       >            eor_flag 0
26d3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
26d5 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
26d8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26da : ca                       dex
26db : 10e8                     bpl tasl
26dd : a203                     ldx #3
26df :                  tasl1
                                set_ax zp1,$ff
                       >            load_flag $ff
26df : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
26e1 : 48              >            pha         ;use stack to load status
26e2 : b509            >            lda zp1,x    ;precharge accu
26e4 : 28              >            plp
                        
26e5 : 0a                       asl a
                                tst_ax rASL,fASL,$ff-fnzc
26e6 : 08              >            php         ;save flags
26e7 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
26ea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26ec : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
26ed : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
26ef : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
26f2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26f4 : ca                       dex
26f5 : 10e8                     bpl tasl1
                        
26f7 : a203                     ldx #3
26f9 :                  tlsr
                                set_ax zp1,0
                       >            load_flag 0
26f9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
26fb : 48              >            pha         ;use stack to load status
26fc : b509            >            lda zp1,x    ;precharge accu
26fe : 28              >            plp
                        
26ff : 4a                       lsr a
                                tst_ax rLSR,fLSR,0
2700 : 08              >            php         ;save flags
2701 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2704 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2706 : 68              >            pla         ;load status
                       >            eor_flag 0
2707 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2709 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
270c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
270e : ca                       dex
270f : 10e8                     bpl tlsr
2711 : a203                     ldx #3
2713 :                  tlsr1
                                set_ax zp1,$ff
                       >            load_flag $ff
2713 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2715 : 48              >            pha         ;use stack to load status
2716 : b509            >            lda zp1,x    ;precharge accu
2718 : 28              >            plp
                        
2719 : 4a                       lsr a
                                tst_ax rLSR,fLSR,$ff-fnzc
271a : 08              >            php         ;save flags
271b : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
271e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2720 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2721 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2723 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
2726 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2728 : ca                       dex
2729 : 10e8                     bpl tlsr1
                        
272b : a203                     ldx #3
272d :                  trol
                                set_ax zp1,0
                       >            load_flag 0
272d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
272f : 48              >            pha         ;use stack to load status
2730 : b509            >            lda zp1,x    ;precharge accu
2732 : 28              >            plp
                        
2733 : 2a                       rol a
                                tst_ax rROL,fROL,0
2734 : 08              >            php         ;save flags
2735 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2738 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
273a : 68              >            pla         ;load status
                       >            eor_flag 0
273b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
273d : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
2740 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2742 : ca                       dex
2743 : 10e8                     bpl trol
2745 : a203                     ldx #3
2747 :                  trol1
                                set_ax zp1,$ff-fc
                       >            load_flag $ff-fc
2747 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2749 : 48              >            pha         ;use stack to load status
274a : b509            >            lda zp1,x    ;precharge accu
274c : 28              >            plp
                        
274d : 2a                       rol a
                                tst_ax rROL,fROL,$ff-fnzc
274e : 08              >            php         ;save flags
274f : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2752 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2754 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2755 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2757 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
275a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
275c : ca                       dex
275d : 10e8                     bpl trol1
                        
275f : a203                     ldx #3
2761 :                  trolc
                                set_ax zp1,fc
                       >            load_flag fc
2761 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2763 : 48              >            pha         ;use stack to load status
2764 : b509            >            lda zp1,x    ;precharge accu
2766 : 28              >            plp
                        
2767 : 2a                       rol a
                                tst_ax rROLc,fROLc,0
2768 : 08              >            php         ;save flags
2769 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
276c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
276e : 68              >            pla         ;load status
                       >            eor_flag 0
276f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2771 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
2774 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2776 : ca                       dex
2777 : 10e8                     bpl trolc
2779 : a203                     ldx #3
277b :                  trolc1
                                set_ax zp1,$ff
                       >            load_flag $ff
277b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
277d : 48              >            pha         ;use stack to load status
277e : b509            >            lda zp1,x    ;precharge accu
2780 : 28              >            plp
                        
2781 : 2a                       rol a
                                tst_ax rROLc,fROLc,$ff-fnzc
2782 : 08              >            php         ;save flags
2783 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2786 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2788 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2789 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
278b : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
278e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2790 : ca                       dex
2791 : 10e8                     bpl trolc1
                        
2793 : a203                     ldx #3
2795 :                  tror
                                set_ax zp1,0
                       >            load_flag 0
2795 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2797 : 48              >            pha         ;use stack to load status
2798 : b509            >            lda zp1,x    ;precharge accu
279a : 28              >            plp
                        
279b : 6a                       ror a
                                tst_ax rROR,fROR,0
279c : 08              >            php         ;save flags
279d : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
27a0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27a2 : 68              >            pla         ;load status
                       >            eor_flag 0
27a3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
27a5 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
27a8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27aa : ca                       dex
27ab : 10e8                     bpl tror
27ad : a203                     ldx #3
27af :                  tror1
                                set_ax zp1,$ff-fc
                       >            load_flag $ff-fc
27af : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
27b1 : 48              >            pha         ;use stack to load status
27b2 : b509            >            lda zp1,x    ;precharge accu
27b4 : 28              >            plp
                        
27b5 : 6a                       ror a
                                tst_ax rROR,fROR,$ff-fnzc
27b6 : 08              >            php         ;save flags
27b7 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
27ba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27bc : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
27bd : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
27bf : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
27c2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27c4 : ca                       dex
27c5 : 10e8                     bpl tror1
                        
27c7 : a203                     ldx #3
27c9 :                  trorc
                                set_ax zp1,fc
                       >            load_flag fc
27c9 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
27cb : 48              >            pha         ;use stack to load status
27cc : b509            >            lda zp1,x    ;precharge accu
27ce : 28              >            plp
                        
27cf : 6a                       ror a
                                tst_ax rRORc,fRORc,0
27d0 : 08              >            php         ;save flags
27d1 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
27d4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27d6 : 68              >            pla         ;load status
                       >            eor_flag 0
27d7 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
27d9 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
27dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27de : ca                       dex
27df : 10e8                     bpl trorc
27e1 : a203                     ldx #3
27e3 :                  trorc1
                                set_ax zp1,$ff
                       >            load_flag $ff
27e3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
27e5 : 48              >            pha         ;use stack to load status
27e6 : b509            >            lda zp1,x    ;precharge accu
27e8 : 28              >            plp
                        
27e9 : 6a                       ror a
                                tst_ax rRORc,fRORc,$ff-fnzc
27ea : 08              >            php         ;save flags
27eb : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
27ee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27f0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
27f1 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
27f3 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
27f6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27f8 : ca                       dex
27f9 : 10e8                     bpl trorc1
                                next_test
27fb : ad0002          >            lda test_case   ;previous test
27fe : c91d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2800 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001e =                 >test_num = test_num + 1
2802 : a91e            >            lda #test_num   ;*** next tests' number
2804 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zeropage
2807 : a203                     ldx #3
2809 :                  tasl2
                                set_z zp1,0
                       >            load_flag 0
2809 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
280b : 48              >            pha         ;use stack to load status
280c : b509            >            lda zp1,x    ;load to zeropage
280e : 8502            >            sta zpt
2810 : 28              >            plp
                        
2811 : 0602                     asl zpt
                                tst_z rASL,fASL,0
2813 : 08              >            php         ;save flags
2814 : a502            >            lda zpt
2816 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2819 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
281b : 68              >            pla         ;load status
                       >            eor_flag 0
281c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
281e : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
2821 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2823 : ca                       dex
2824 : 10e3                     bpl tasl2
2826 : a203                     ldx #3
2828 :                  tasl3
                                set_z zp1,$ff
                       >            load_flag $ff
2828 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
282a : 48              >            pha         ;use stack to load status
282b : b509            >            lda zp1,x    ;load to zeropage
282d : 8502            >            sta zpt
282f : 28              >            plp
                        
2830 : 0602                     asl zpt
                                tst_z rASL,fASL,$ff-fnzc
2832 : 08              >            php         ;save flags
2833 : a502            >            lda zpt
2835 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2838 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
283a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
283b : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
283d : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
2840 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2842 : ca                       dex
2843 : 10e3                     bpl tasl3
                        
2845 : a203                     ldx #3
2847 :                  tlsr2
                                set_z zp1,0
                       >            load_flag 0
2847 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2849 : 48              >            pha         ;use stack to load status
284a : b509            >            lda zp1,x    ;load to zeropage
284c : 8502            >            sta zpt
284e : 28              >            plp
                        
284f : 4602                     lsr zpt
                                tst_z rLSR,fLSR,0
2851 : 08              >            php         ;save flags
2852 : a502            >            lda zpt
2854 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2857 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2859 : 68              >            pla         ;load status
                       >            eor_flag 0
285a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
285c : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
285f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2861 : ca                       dex
2862 : 10e3                     bpl tlsr2
2864 : a203                     ldx #3
2866 :                  tlsr3
                                set_z zp1,$ff
                       >            load_flag $ff
2866 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2868 : 48              >            pha         ;use stack to load status
2869 : b509            >            lda zp1,x    ;load to zeropage
286b : 8502            >            sta zpt
286d : 28              >            plp
                        
286e : 4602                     lsr zpt
                                tst_z rLSR,fLSR,$ff-fnzc
2870 : 08              >            php         ;save flags
2871 : a502            >            lda zpt
2873 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2876 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2878 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2879 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
287b : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
287e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2880 : ca                       dex
2881 : 10e3                     bpl tlsr3
                        
2883 : a203                     ldx #3
2885 :                  trol2
                                set_z zp1,0
                       >            load_flag 0
2885 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2887 : 48              >            pha         ;use stack to load status
2888 : b509            >            lda zp1,x    ;load to zeropage
288a : 8502            >            sta zpt
288c : 28              >            plp
                        
288d : 2602                     rol zpt
                                tst_z rROL,fROL,0
288f : 08              >            php         ;save flags
2890 : a502            >            lda zpt
2892 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2895 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2897 : 68              >            pla         ;load status
                       >            eor_flag 0
2898 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
289a : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
289d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
289f : ca                       dex
28a0 : 10e3                     bpl trol2
28a2 : a203                     ldx #3
28a4 :                  trol3
                                set_z zp1,$ff-fc
                       >            load_flag $ff-fc
28a4 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
28a6 : 48              >            pha         ;use stack to load status
28a7 : b509            >            lda zp1,x    ;load to zeropage
28a9 : 8502            >            sta zpt
28ab : 28              >            plp
                        
28ac : 2602                     rol zpt
                                tst_z rROL,fROL,$ff-fnzc
28ae : 08              >            php         ;save flags
28af : a502            >            lda zpt
28b1 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
28b4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28b6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
28b7 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
28b9 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
28bc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28be : ca                       dex
28bf : 10e3                     bpl trol3
                        
28c1 : a203                     ldx #3
28c3 :                  trolc2
                                set_z zp1,fc
                       >            load_flag fc
28c3 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
28c5 : 48              >            pha         ;use stack to load status
28c6 : b509            >            lda zp1,x    ;load to zeropage
28c8 : 8502            >            sta zpt
28ca : 28              >            plp
                        
28cb : 2602                     rol zpt
                                tst_z rROLc,fROLc,0
28cd : 08              >            php         ;save flags
28ce : a502            >            lda zpt
28d0 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
28d3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28d5 : 68              >            pla         ;load status
                       >            eor_flag 0
28d6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
28d8 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
28db : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28dd : ca                       dex
28de : 10e3                     bpl trolc2
28e0 : a203                     ldx #3
28e2 :                  trolc3
                                set_z zp1,$ff
                       >            load_flag $ff
28e2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
28e4 : 48              >            pha         ;use stack to load status
28e5 : b509            >            lda zp1,x    ;load to zeropage
28e7 : 8502            >            sta zpt
28e9 : 28              >            plp
                        
28ea : 2602                     rol zpt
                                tst_z rROLc,fROLc,$ff-fnzc
28ec : 08              >            php         ;save flags
28ed : a502            >            lda zpt
28ef : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
28f2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28f4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
28f5 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
28f7 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
28fa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28fc : ca                       dex
28fd : 10e3                     bpl trolc3
                        
28ff : a203                     ldx #3
2901 :                  tror2
                                set_z zp1,0
                       >            load_flag 0
2901 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2903 : 48              >            pha         ;use stack to load status
2904 : b509            >            lda zp1,x    ;load to zeropage
2906 : 8502            >            sta zpt
2908 : 28              >            plp
                        
2909 : 6602                     ror zpt
                                tst_z rROR,fROR,0
290b : 08              >            php         ;save flags
290c : a502            >            lda zpt
290e : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2911 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2913 : 68              >            pla         ;load status
                       >            eor_flag 0
2914 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2916 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
2919 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
291b : ca                       dex
291c : 10e3                     bpl tror2
291e : a203                     ldx #3
2920 :                  tror3
                                set_z zp1,$ff-fc
                       >            load_flag $ff-fc
2920 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2922 : 48              >            pha         ;use stack to load status
2923 : b509            >            lda zp1,x    ;load to zeropage
2925 : 8502            >            sta zpt
2927 : 28              >            plp
                        
2928 : 6602                     ror zpt
                                tst_z rROR,fROR,$ff-fnzc
292a : 08              >            php         ;save flags
292b : a502            >            lda zpt
292d : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2930 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2932 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2933 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2935 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
2938 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
293a : ca                       dex
293b : 10e3                     bpl tror3
                        
293d : a203                     ldx #3
293f :                  trorc2
                                set_z zp1,fc
                       >            load_flag fc
293f : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2941 : 48              >            pha         ;use stack to load status
2942 : b509            >            lda zp1,x    ;load to zeropage
2944 : 8502            >            sta zpt
2946 : 28              >            plp
                        
2947 : 6602                     ror zpt
                                tst_z rRORc,fRORc,0
2949 : 08              >            php         ;save flags
294a : a502            >            lda zpt
294c : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
294f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2951 : 68              >            pla         ;load status
                       >            eor_flag 0
2952 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2954 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2957 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2959 : ca                       dex
295a : 10e3                     bpl trorc2
295c : a203                     ldx #3
295e :                  trorc3
                                set_z zp1,$ff
                       >            load_flag $ff
295e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2960 : 48              >            pha         ;use stack to load status
2961 : b509            >            lda zp1,x    ;load to zeropage
2963 : 8502            >            sta zpt
2965 : 28              >            plp
                        
2966 : 6602                     ror zpt
                                tst_z rRORc,fRORc,$ff-fnzc
2968 : 08              >            php         ;save flags
2969 : a502            >            lda zpt
296b : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
296e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2970 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2971 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2973 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2976 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2978 : ca                       dex
2979 : 10e3                     bpl trorc3
                                next_test
297b : ad0002          >            lda test_case   ;previous test
297e : c91e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2980 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001f =                 >test_num = test_num + 1
2982 : a91f            >            lda #test_num   ;*** next tests' number
2984 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - absolute
2987 : a203                     ldx #3
2989 :                  tasl4
                                set_abs zp1,0
                       >            load_flag 0
2989 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
298b : 48              >            pha         ;use stack to load status
298c : b509            >            lda zp1,x    ;load to memory
298e : 8d0302          >            sta abst
2991 : 28              >            plp
                        
2992 : 0e0302                   asl abst
                                tst_abs rASL,fASL,0
2995 : 08              >            php         ;save flags
2996 : ad0302          >            lda abst
2999 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
299c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
299e : 68              >            pla         ;load status
                       >            eor_flag 0
299f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
29a1 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
29a4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29a6 : ca                       dex
29a7 : 10e0                     bpl tasl4
29a9 : a203                     ldx #3
29ab :                  tasl5
                                set_abs zp1,$ff
                       >            load_flag $ff
29ab : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
29ad : 48              >            pha         ;use stack to load status
29ae : b509            >            lda zp1,x    ;load to memory
29b0 : 8d0302          >            sta abst
29b3 : 28              >            plp
                        
29b4 : 0e0302                   asl abst
                                tst_abs rASL,fASL,$ff-fnzc
29b7 : 08              >            php         ;save flags
29b8 : ad0302          >            lda abst
29bb : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
29be : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29c0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
29c1 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
29c3 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
29c6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29c8 : ca                       dex
29c9 : 10e0                     bpl tasl5
                        
29cb : a203                     ldx #3
29cd :                  tlsr4
                                set_abs zp1,0
                       >            load_flag 0
29cd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
29cf : 48              >            pha         ;use stack to load status
29d0 : b509            >            lda zp1,x    ;load to memory
29d2 : 8d0302          >            sta abst
29d5 : 28              >            plp
                        
29d6 : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,0
29d9 : 08              >            php         ;save flags
29da : ad0302          >            lda abst
29dd : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
29e0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29e2 : 68              >            pla         ;load status
                       >            eor_flag 0
29e3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
29e5 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
29e8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29ea : ca                       dex
29eb : 10e0                     bpl tlsr4
29ed : a203                     ldx #3
29ef :                  tlsr5
                                set_abs zp1,$ff
                       >            load_flag $ff
29ef : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
29f1 : 48              >            pha         ;use stack to load status
29f2 : b509            >            lda zp1,x    ;load to memory
29f4 : 8d0302          >            sta abst
29f7 : 28              >            plp
                        
29f8 : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,$ff-fnzc
29fb : 08              >            php         ;save flags
29fc : ad0302          >            lda abst
29ff : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2a02 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a04 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2a05 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2a07 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2a0a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a0c : ca                       dex
2a0d : 10e0                     bpl tlsr5
                        
2a0f : a203                     ldx #3
2a11 :                  trol4
                                set_abs zp1,0
                       >            load_flag 0
2a11 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2a13 : 48              >            pha         ;use stack to load status
2a14 : b509            >            lda zp1,x    ;load to memory
2a16 : 8d0302          >            sta abst
2a19 : 28              >            plp
                        
2a1a : 2e0302                   rol abst
                                tst_abs rROL,fROL,0
2a1d : 08              >            php         ;save flags
2a1e : ad0302          >            lda abst
2a21 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2a24 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a26 : 68              >            pla         ;load status
                       >            eor_flag 0
2a27 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2a29 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2a2c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a2e : ca                       dex
2a2f : 10e0                     bpl trol4
2a31 : a203                     ldx #3
2a33 :                  trol5
                                set_abs zp1,$ff-fc
                       >            load_flag $ff-fc
2a33 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2a35 : 48              >            pha         ;use stack to load status
2a36 : b509            >            lda zp1,x    ;load to memory
2a38 : 8d0302          >            sta abst
2a3b : 28              >            plp
                        
2a3c : 2e0302                   rol abst
                                tst_abs rROL,fROL,$ff-fnzc
2a3f : 08              >            php         ;save flags
2a40 : ad0302          >            lda abst
2a43 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2a46 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a48 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2a49 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2a4b : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2a4e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a50 : ca                       dex
2a51 : 10e0                     bpl trol5
                        
2a53 : a203                     ldx #3
2a55 :                  trolc4
                                set_abs zp1,fc
                       >            load_flag fc
2a55 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2a57 : 48              >            pha         ;use stack to load status
2a58 : b509            >            lda zp1,x    ;load to memory
2a5a : 8d0302          >            sta abst
2a5d : 28              >            plp
                        
2a5e : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,0
2a61 : 08              >            php         ;save flags
2a62 : ad0302          >            lda abst
2a65 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2a68 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a6a : 68              >            pla         ;load status
                       >            eor_flag 0
2a6b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2a6d : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2a70 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a72 : ca                       dex
2a73 : 10e0                     bpl trolc4
2a75 : a203                     ldx #3
2a77 :                  trolc5
                                set_abs zp1,$ff
                       >            load_flag $ff
2a77 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2a79 : 48              >            pha         ;use stack to load status
2a7a : b509            >            lda zp1,x    ;load to memory
2a7c : 8d0302          >            sta abst
2a7f : 28              >            plp
                        
2a80 : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,$ff-fnzc
2a83 : 08              >            php         ;save flags
2a84 : ad0302          >            lda abst
2a87 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2a8a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a8c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2a8d : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2a8f : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2a92 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a94 : ca                       dex
2a95 : 10e0                     bpl trolc5
                        
2a97 : a203                     ldx #3
2a99 :                  tror4
                                set_abs zp1,0
                       >            load_flag 0
2a99 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2a9b : 48              >            pha         ;use stack to load status
2a9c : b509            >            lda zp1,x    ;load to memory
2a9e : 8d0302          >            sta abst
2aa1 : 28              >            plp
                        
2aa2 : 6e0302                   ror abst
                                tst_abs rROR,fROR,0
2aa5 : 08              >            php         ;save flags
2aa6 : ad0302          >            lda abst
2aa9 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2aac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2aae : 68              >            pla         ;load status
                       >            eor_flag 0
2aaf : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2ab1 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
2ab4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ab6 : ca                       dex
2ab7 : 10e0                     bpl tror4
2ab9 : a203                     ldx #3
2abb :                  tror5
                                set_abs zp1,$ff-fc
                       >            load_flag $ff-fc
2abb : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2abd : 48              >            pha         ;use stack to load status
2abe : b509            >            lda zp1,x    ;load to memory
2ac0 : 8d0302          >            sta abst
2ac3 : 28              >            plp
                        
2ac4 : 6e0302                   ror abst
                                tst_abs rROR,fROR,$ff-fnzc
2ac7 : 08              >            php         ;save flags
2ac8 : ad0302          >            lda abst
2acb : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2ace : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ad0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2ad1 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2ad3 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
2ad6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ad8 : ca                       dex
2ad9 : 10e0                     bpl tror5
                        
2adb : a203                     ldx #3
2add :                  trorc4
                                set_abs zp1,fc
                       >            load_flag fc
2add : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2adf : 48              >            pha         ;use stack to load status
2ae0 : b509            >            lda zp1,x    ;load to memory
2ae2 : 8d0302          >            sta abst
2ae5 : 28              >            plp
                        
2ae6 : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,0
2ae9 : 08              >            php         ;save flags
2aea : ad0302          >            lda abst
2aed : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2af0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2af2 : 68              >            pla         ;load status
                       >            eor_flag 0
2af3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2af5 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2af8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2afa : ca                       dex
2afb : 10e0                     bpl trorc4
2afd : a203                     ldx #3
2aff :                  trorc5
                                set_abs zp1,$ff
                       >            load_flag $ff
2aff : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2b01 : 48              >            pha         ;use stack to load status
2b02 : b509            >            lda zp1,x    ;load to memory
2b04 : 8d0302          >            sta abst
2b07 : 28              >            plp
                        
2b08 : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,$ff-fnzc
2b0b : 08              >            php         ;save flags
2b0c : ad0302          >            lda abst
2b0f : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2b12 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b14 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2b15 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2b17 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2b1a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b1c : ca                       dex
2b1d : 10e0                     bpl trorc5
                                next_test
2b1f : ad0002          >            lda test_case   ;previous test
2b22 : c91f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2b24 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0020 =                 >test_num = test_num + 1
2b26 : a920            >            lda #test_num   ;*** next tests' number
2b28 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zp indexed
2b2b : a203                     ldx #3
2b2d :                  tasl6
                                set_zx zp1,0
                       >            load_flag 0
2b2d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2b2f : 48              >            pha         ;use stack to load status
2b30 : b509            >            lda zp1,x    ;load to indexed zeropage
2b32 : 9502            >            sta zpt,x
2b34 : 28              >            plp
                        
2b35 : 1602                     asl zpt,x
                                tst_zx rASL,fASL,0
2b37 : 08              >            php         ;save flags
2b38 : b502            >            lda zpt,x
2b3a : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2b3d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b3f : 68              >            pla         ;load status
                       >            eor_flag 0
2b40 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2b42 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
2b45 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b47 : ca                       dex
2b48 : 10e3                     bpl tasl6
2b4a : a203                     ldx #3
2b4c :                  tasl7
                                set_zx zp1,$ff
                       >            load_flag $ff
2b4c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2b4e : 48              >            pha         ;use stack to load status
2b4f : b509            >            lda zp1,x    ;load to indexed zeropage
2b51 : 9502            >            sta zpt,x
2b53 : 28              >            plp
                        
2b54 : 1602                     asl zpt,x
                                tst_zx rASL,fASL,$ff-fnzc
2b56 : 08              >            php         ;save flags
2b57 : b502            >            lda zpt,x
2b59 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2b5c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b5e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2b5f : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2b61 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
2b64 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b66 : ca                       dex
2b67 : 10e3                     bpl tasl7
                        
2b69 : a203                     ldx #3
2b6b :                  tlsr6
                                set_zx zp1,0
                       >            load_flag 0
2b6b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2b6d : 48              >            pha         ;use stack to load status
2b6e : b509            >            lda zp1,x    ;load to indexed zeropage
2b70 : 9502            >            sta zpt,x
2b72 : 28              >            plp
                        
2b73 : 5602                     lsr zpt,x
                                tst_zx rLSR,fLSR,0
2b75 : 08              >            php         ;save flags
2b76 : b502            >            lda zpt,x
2b78 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2b7b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b7d : 68              >            pla         ;load status
                       >            eor_flag 0
2b7e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2b80 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2b83 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b85 : ca                       dex
2b86 : 10e3                     bpl tlsr6
2b88 : a203                     ldx #3
2b8a :                  tlsr7
                                set_zx zp1,$ff
                       >            load_flag $ff
2b8a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2b8c : 48              >            pha         ;use stack to load status
2b8d : b509            >            lda zp1,x    ;load to indexed zeropage
2b8f : 9502            >            sta zpt,x
2b91 : 28              >            plp
                        
2b92 : 5602                     lsr zpt,x
                                tst_zx rLSR,fLSR,$ff-fnzc
2b94 : 08              >            php         ;save flags
2b95 : b502            >            lda zpt,x
2b97 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2b9a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b9c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2b9d : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2b9f : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2ba2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ba4 : ca                       dex
2ba5 : 10e3                     bpl tlsr7
                        
2ba7 : a203                     ldx #3
2ba9 :                  trol6
                                set_zx zp1,0
                       >            load_flag 0
2ba9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2bab : 48              >            pha         ;use stack to load status
2bac : b509            >            lda zp1,x    ;load to indexed zeropage
2bae : 9502            >            sta zpt,x
2bb0 : 28              >            plp
                        
2bb1 : 3602                     rol zpt,x
                                tst_zx rROL,fROL,0
2bb3 : 08              >            php         ;save flags
2bb4 : b502            >            lda zpt,x
2bb6 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2bb9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2bbb : 68              >            pla         ;load status
                       >            eor_flag 0
2bbc : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2bbe : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2bc1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2bc3 : ca                       dex
2bc4 : 10e3                     bpl trol6
2bc6 : a203                     ldx #3
2bc8 :                  trol7
                                set_zx zp1,$ff-fc
                       >            load_flag $ff-fc
2bc8 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2bca : 48              >            pha         ;use stack to load status
2bcb : b509            >            lda zp1,x    ;load to indexed zeropage
2bcd : 9502            >            sta zpt,x
2bcf : 28              >            plp
                        
2bd0 : 3602                     rol zpt,x
                                tst_zx rROL,fROL,$ff-fnzc
2bd2 : 08              >            php         ;save flags
2bd3 : b502            >            lda zpt,x
2bd5 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2bd8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2bda : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2bdb : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2bdd : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2be0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2be2 : ca                       dex
2be3 : 10e3                     bpl trol7
                        
2be5 : a203                     ldx #3
2be7 :                  trolc6
                                set_zx zp1,fc
                       >            load_flag fc
2be7 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2be9 : 48              >            pha         ;use stack to load status
2bea : b509            >            lda zp1,x    ;load to indexed zeropage
2bec : 9502            >            sta zpt,x
2bee : 28              >            plp
                        
2bef : 3602                     rol zpt,x
                                tst_zx rROLc,fROLc,0
2bf1 : 08              >            php         ;save flags
2bf2 : b502            >            lda zpt,x
2bf4 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2bf7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2bf9 : 68              >            pla         ;load status
                       >            eor_flag 0
2bfa : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2bfc : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2bff : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c01 : ca                       dex
2c02 : 10e3                     bpl trolc6
2c04 : a203                     ldx #3
2c06 :                  trolc7
                                set_zx zp1,$ff
                       >            load_flag $ff
2c06 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2c08 : 48              >            pha         ;use stack to load status
2c09 : b509            >            lda zp1,x    ;load to indexed zeropage
2c0b : 9502            >            sta zpt,x
2c0d : 28              >            plp
                        
2c0e : 3602                     rol zpt,x
                                tst_zx rROLc,fROLc,$ff-fnzc
2c10 : 08              >            php         ;save flags
2c11 : b502            >            lda zpt,x
2c13 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2c16 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c18 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2c19 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2c1b : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2c1e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c20 : ca                       dex
2c21 : 10e3                     bpl trolc7
                        
2c23 : a203                     ldx #3
2c25 :                  tror6
                                set_zx zp1,0
                       >            load_flag 0
2c25 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2c27 : 48              >            pha         ;use stack to load status
2c28 : b509            >            lda zp1,x    ;load to indexed zeropage
2c2a : 9502            >            sta zpt,x
2c2c : 28              >            plp
                        
2c2d : 7602                     ror zpt,x
                                tst_zx rROR,fROR,0
2c2f : 08              >            php         ;save flags
2c30 : b502            >            lda zpt,x
2c32 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2c35 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c37 : 68              >            pla         ;load status
                       >            eor_flag 0
2c38 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2c3a : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
2c3d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c3f : ca                       dex
2c40 : 10e3                     bpl tror6
2c42 : a203                     ldx #3
2c44 :                  tror7
                                set_zx zp1,$ff-fc
                       >            load_flag $ff-fc
2c44 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2c46 : 48              >            pha         ;use stack to load status
2c47 : b509            >            lda zp1,x    ;load to indexed zeropage
2c49 : 9502            >            sta zpt,x
2c4b : 28              >            plp
                        
2c4c : 7602                     ror zpt,x
                                tst_zx rROR,fROR,$ff-fnzc
2c4e : 08              >            php         ;save flags
2c4f : b502            >            lda zpt,x
2c51 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2c54 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c56 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2c57 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2c59 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
2c5c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c5e : ca                       dex
2c5f : 10e3                     bpl tror7
                        
2c61 : a203                     ldx #3
2c63 :                  trorc6
                                set_zx zp1,fc
                       >            load_flag fc
2c63 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2c65 : 48              >            pha         ;use stack to load status
2c66 : b509            >            lda zp1,x    ;load to indexed zeropage
2c68 : 9502            >            sta zpt,x
2c6a : 28              >            plp
                        
2c6b : 7602                     ror zpt,x
                                tst_zx rRORc,fRORc,0
2c6d : 08              >            php         ;save flags
2c6e : b502            >            lda zpt,x
2c70 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2c73 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c75 : 68              >            pla         ;load status
                       >            eor_flag 0
2c76 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2c78 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2c7b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c7d : ca                       dex
2c7e : 10e3                     bpl trorc6
2c80 : a203                     ldx #3
2c82 :                  trorc7
                                set_zx zp1,$ff
                       >            load_flag $ff
2c82 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2c84 : 48              >            pha         ;use stack to load status
2c85 : b509            >            lda zp1,x    ;load to indexed zeropage
2c87 : 9502            >            sta zpt,x
2c89 : 28              >            plp
                        
2c8a : 7602                     ror zpt,x
                                tst_zx rRORc,fRORc,$ff-fnzc
2c8c : 08              >            php         ;save flags
2c8d : b502            >            lda zpt,x
2c8f : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2c92 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c94 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2c95 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2c97 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2c9a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c9c : ca                       dex
2c9d : 10e3                     bpl trorc7
                                next_test
2c9f : ad0002          >            lda test_case   ;previous test
2ca2 : c920            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2ca4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0021 =                 >test_num = test_num + 1
2ca6 : a921            >            lda #test_num   ;*** next tests' number
2ca8 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - abs indexed
2cab : a203                     ldx #3
2cad :                  tasl8
                                set_absx zp1,0
                       >            load_flag 0
2cad : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2caf : 48              >            pha         ;use stack to load status
2cb0 : b509            >            lda zp1,x    ;load to indexed memory
2cb2 : 9d0302          >            sta abst,x
2cb5 : 28              >            plp
                        
2cb6 : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,0
2cb9 : 08              >            php         ;save flags
2cba : bd0302          >            lda abst,x
2cbd : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2cc0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2cc2 : 68              >            pla         ;load status
                       >            eor_flag 0
2cc3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2cc5 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
2cc8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2cca : ca                       dex
2ccb : 10e0                     bpl tasl8
2ccd : a203                     ldx #3
2ccf :                  tasl9
                                set_absx zp1,$ff
                       >            load_flag $ff
2ccf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2cd1 : 48              >            pha         ;use stack to load status
2cd2 : b509            >            lda zp1,x    ;load to indexed memory
2cd4 : 9d0302          >            sta abst,x
2cd7 : 28              >            plp
                        
2cd8 : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,$ff-fnzc
2cdb : 08              >            php         ;save flags
2cdc : bd0302          >            lda abst,x
2cdf : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2ce2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ce4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2ce5 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2ce7 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
2cea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2cec : ca                       dex
2ced : 10e0                     bpl tasl9
                        
2cef : a203                     ldx #3
2cf1 :                  tlsr8
                                set_absx zp1,0
                       >            load_flag 0
2cf1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2cf3 : 48              >            pha         ;use stack to load status
2cf4 : b509            >            lda zp1,x    ;load to indexed memory
2cf6 : 9d0302          >            sta abst,x
2cf9 : 28              >            plp
                        
2cfa : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,0
2cfd : 08              >            php         ;save flags
2cfe : bd0302          >            lda abst,x
2d01 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2d04 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d06 : 68              >            pla         ;load status
                       >            eor_flag 0
2d07 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2d09 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2d0c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d0e : ca                       dex
2d0f : 10e0                     bpl tlsr8
2d11 : a203                     ldx #3
2d13 :                  tlsr9
                                set_absx zp1,$ff
                       >            load_flag $ff
2d13 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2d15 : 48              >            pha         ;use stack to load status
2d16 : b509            >            lda zp1,x    ;load to indexed memory
2d18 : 9d0302          >            sta abst,x
2d1b : 28              >            plp
                        
2d1c : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,$ff-fnzc
2d1f : 08              >            php         ;save flags
2d20 : bd0302          >            lda abst,x
2d23 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2d26 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d28 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2d29 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2d2b : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2d2e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d30 : ca                       dex
2d31 : 10e0                     bpl tlsr9
                        
2d33 : a203                     ldx #3
2d35 :                  trol8
                                set_absx zp1,0
                       >            load_flag 0
2d35 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2d37 : 48              >            pha         ;use stack to load status
2d38 : b509            >            lda zp1,x    ;load to indexed memory
2d3a : 9d0302          >            sta abst,x
2d3d : 28              >            plp
                        
2d3e : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,0
2d41 : 08              >            php         ;save flags
2d42 : bd0302          >            lda abst,x
2d45 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2d48 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d4a : 68              >            pla         ;load status
                       >            eor_flag 0
2d4b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2d4d : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2d50 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d52 : ca                       dex
2d53 : 10e0                     bpl trol8
2d55 : a203                     ldx #3
2d57 :                  trol9
                                set_absx zp1,$ff-fc
                       >            load_flag $ff-fc
2d57 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2d59 : 48              >            pha         ;use stack to load status
2d5a : b509            >            lda zp1,x    ;load to indexed memory
2d5c : 9d0302          >            sta abst,x
2d5f : 28              >            plp
                        
2d60 : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,$ff-fnzc
2d63 : 08              >            php         ;save flags
2d64 : bd0302          >            lda abst,x
2d67 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2d6a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d6c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2d6d : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2d6f : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2d72 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d74 : ca                       dex
2d75 : 10e0                     bpl trol9
                        
2d77 : a203                     ldx #3
2d79 :                  trolc8
                                set_absx zp1,fc
                       >            load_flag fc
2d79 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2d7b : 48              >            pha         ;use stack to load status
2d7c : b509            >            lda zp1,x    ;load to indexed memory
2d7e : 9d0302          >            sta abst,x
2d81 : 28              >            plp
                        
2d82 : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,0
2d85 : 08              >            php         ;save flags
2d86 : bd0302          >            lda abst,x
2d89 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2d8c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d8e : 68              >            pla         ;load status
                       >            eor_flag 0
2d8f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2d91 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2d94 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d96 : ca                       dex
2d97 : 10e0                     bpl trolc8
2d99 : a203                     ldx #3
2d9b :                  trolc9
                                set_absx zp1,$ff
                       >            load_flag $ff
2d9b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2d9d : 48              >            pha         ;use stack to load status
2d9e : b509            >            lda zp1,x    ;load to indexed memory
2da0 : 9d0302          >            sta abst,x
2da3 : 28              >            plp
                        
2da4 : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,$ff-fnzc
2da7 : 08              >            php         ;save flags
2da8 : bd0302          >            lda abst,x
2dab : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2dae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2db0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2db1 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2db3 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2db6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2db8 : ca                       dex
2db9 : 10e0                     bpl trolc9
                        
2dbb : a203                     ldx #3
2dbd :                  tror8
                                set_absx zp1,0
                       >            load_flag 0
2dbd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2dbf : 48              >            pha         ;use stack to load status
2dc0 : b509            >            lda zp1,x    ;load to indexed memory
2dc2 : 9d0302          >            sta abst,x
2dc5 : 28              >            plp
                        
2dc6 : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,0
2dc9 : 08              >            php         ;save flags
2dca : bd0302          >            lda abst,x
2dcd : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2dd0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2dd2 : 68              >            pla         ;load status
                       >            eor_flag 0
2dd3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2dd5 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
2dd8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2dda : ca                       dex
2ddb : 10e0                     bpl tror8
2ddd : a203                     ldx #3
2ddf :                  tror9
                                set_absx zp1,$ff-fc
                       >            load_flag $ff-fc
2ddf : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2de1 : 48              >            pha         ;use stack to load status
2de2 : b509            >            lda zp1,x    ;load to indexed memory
2de4 : 9d0302          >            sta abst,x
2de7 : 28              >            plp
                        
2de8 : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,$ff-fnzc
2deb : 08              >            php         ;save flags
2dec : bd0302          >            lda abst,x
2def : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2df2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2df4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2df5 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2df7 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
2dfa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2dfc : ca                       dex
2dfd : 10e0                     bpl tror9
                        
2dff : a203                     ldx #3
2e01 :                  trorc8
                                set_absx zp1,fc
                       >            load_flag fc
2e01 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2e03 : 48              >            pha         ;use stack to load status
2e04 : b509            >            lda zp1,x    ;load to indexed memory
2e06 : 9d0302          >            sta abst,x
2e09 : 28              >            plp
                        
2e0a : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,0
2e0d : 08              >            php         ;save flags
2e0e : bd0302          >            lda abst,x
2e11 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2e14 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e16 : 68              >            pla         ;load status
                       >            eor_flag 0
2e17 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2e19 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2e1c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e1e : ca                       dex
2e1f : 10e0                     bpl trorc8
2e21 : a203                     ldx #3
2e23 :                  trorc9
                                set_absx zp1,$ff
                       >            load_flag $ff
2e23 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2e25 : 48              >            pha         ;use stack to load status
2e26 : b509            >            lda zp1,x    ;load to indexed memory
2e28 : 9d0302          >            sta abst,x
2e2b : 28              >            plp
                        
2e2c : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,$ff-fnzc
2e2f : 08              >            php         ;save flags
2e30 : bd0302          >            lda abst,x
2e33 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2e36 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e38 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2e39 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2e3b : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2e3e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e40 : ca                       dex
2e41 : 10e0                     bpl trorc9
                                next_test
2e43 : ad0002          >            lda test_case   ;previous test
2e46 : c921            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2e48 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0022 =                 >test_num = test_num + 1
2e4a : a922            >            lda #test_num   ;*** next tests' number
2e4c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing memory increment/decrement - INC DEC all addressing modes
                        ; zeropage
2e4f : a200                     ldx #0
2e51 : a97e                     lda #$7e
2e53 : 8502                     sta zpt
2e55 :                  tinc
                                set_stat 0
                       >            load_flag 0
2e55 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2e57 : 48              >            pha         ;use stack to load status
2e58 : 28              >            plp
                        
2e59 : e602                     inc zpt
                                tst_z rINC,fINC,0
2e5b : 08              >            php         ;save flags
2e5c : a502            >            lda zpt
2e5e : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2e61 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e63 : 68              >            pla         ;load status
                       >            eor_flag 0
2e64 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2e66 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2e69 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e6b : e8                       inx
2e6c : e002                     cpx #2
2e6e : d004                     bne tinc1
2e70 : a9fe                     lda #$fe
2e72 : 8502                     sta zpt
2e74 : e005             tinc1   cpx #5
2e76 : d0dd                     bne tinc
2e78 : ca                       dex
2e79 : e602                     inc zpt
2e7b :                  tdec
                                set_stat 0
                       >            load_flag 0
2e7b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2e7d : 48              >            pha         ;use stack to load status
2e7e : 28              >            plp
                        
2e7f : c602                     dec zpt
                                tst_z rINC,fINC,0
2e81 : 08              >            php         ;save flags
2e82 : a502            >            lda zpt
2e84 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2e87 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e89 : 68              >            pla         ;load status
                       >            eor_flag 0
2e8a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2e8c : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2e8f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e91 : ca                       dex
2e92 : 300a                     bmi tdec1
2e94 : e001                     cpx #1
2e96 : d0e3                     bne tdec
2e98 : a981                     lda #$81
2e9a : 8502                     sta zpt
2e9c : d0dd                     bne tdec
2e9e :                  tdec1
2e9e : a200                     ldx #0
2ea0 : a97e                     lda #$7e
2ea2 : 8502                     sta zpt
2ea4 :                  tinc10
                                set_stat $ff
                       >            load_flag $ff
2ea4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2ea6 : 48              >            pha         ;use stack to load status
2ea7 : 28              >            plp
                        
2ea8 : e602                     inc zpt
                                tst_z rINC,fINC,$ff-fnz
2eaa : 08              >            php         ;save flags
2eab : a502            >            lda zpt
2ead : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2eb0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2eb2 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2eb3 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2eb5 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2eb8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2eba : e8                       inx
2ebb : e002                     cpx #2
2ebd : d004                     bne tinc11
2ebf : a9fe                     lda #$fe
2ec1 : 8502                     sta zpt
2ec3 : e005             tinc11  cpx #5
2ec5 : d0dd                     bne tinc10
2ec7 : ca                       dex
2ec8 : e602                     inc zpt
2eca :                  tdec10
                                set_stat $ff
                       >            load_flag $ff
2eca : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2ecc : 48              >            pha         ;use stack to load status
2ecd : 28              >            plp
                        
2ece : c602                     dec zpt
                                tst_z rINC,fINC,$ff-fnz
2ed0 : 08              >            php         ;save flags
2ed1 : a502            >            lda zpt
2ed3 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2ed6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ed8 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2ed9 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2edb : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2ede : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ee0 : ca                       dex
2ee1 : 300a                     bmi tdec11
2ee3 : e001                     cpx #1
2ee5 : d0e3                     bne tdec10
2ee7 : a981                     lda #$81
2ee9 : 8502                     sta zpt
2eeb : d0dd                     bne tdec10
2eed :                  tdec11
                                next_test
2eed : ad0002          >            lda test_case   ;previous test
2ef0 : c922            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2ef2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0023 =                 >test_num = test_num + 1
2ef4 : a923            >            lda #test_num   ;*** next tests' number
2ef6 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; absolute memory
2ef9 : a200                     ldx #0
2efb : a97e                     lda #$7e
2efd : 8d0302                   sta abst
2f00 :                  tinc2
                                set_stat 0
                       >            load_flag 0
2f00 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2f02 : 48              >            pha         ;use stack to load status
2f03 : 28              >            plp
                        
2f04 : ee0302                   inc abst
                                tst_abs rINC,fINC,0
2f07 : 08              >            php         ;save flags
2f08 : ad0302          >            lda abst
2f0b : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2f0e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f10 : 68              >            pla         ;load status
                       >            eor_flag 0
2f11 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2f13 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2f16 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f18 : e8                       inx
2f19 : e002                     cpx #2
2f1b : d005                     bne tinc3
2f1d : a9fe                     lda #$fe
2f1f : 8d0302                   sta abst
2f22 : e005             tinc3   cpx #5
2f24 : d0da                     bne tinc2
2f26 : ca                       dex
2f27 : ee0302                   inc abst
2f2a :                  tdec2
                                set_stat 0
                       >            load_flag 0
2f2a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2f2c : 48              >            pha         ;use stack to load status
2f2d : 28              >            plp
                        
2f2e : ce0302                   dec abst
                                tst_abs rINC,fINC,0
2f31 : 08              >            php         ;save flags
2f32 : ad0302          >            lda abst
2f35 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2f38 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f3a : 68              >            pla         ;load status
                       >            eor_flag 0
2f3b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2f3d : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2f40 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f42 : ca                       dex
2f43 : 300b                     bmi tdec3
2f45 : e001                     cpx #1
2f47 : d0e1                     bne tdec2
2f49 : a981                     lda #$81
2f4b : 8d0302                   sta abst
2f4e : d0da                     bne tdec2
2f50 :                  tdec3
2f50 : a200                     ldx #0
2f52 : a97e                     lda #$7e
2f54 : 8d0302                   sta abst
2f57 :                  tinc12
                                set_stat $ff
                       >            load_flag $ff
2f57 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2f59 : 48              >            pha         ;use stack to load status
2f5a : 28              >            plp
                        
2f5b : ee0302                   inc abst
                                tst_abs rINC,fINC,$ff-fnz
2f5e : 08              >            php         ;save flags
2f5f : ad0302          >            lda abst
2f62 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2f65 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f67 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f68 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2f6a : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2f6d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f6f : e8                       inx
2f70 : e002                     cpx #2
2f72 : d005                     bne tinc13
2f74 : a9fe                     lda #$fe
2f76 : 8d0302                   sta abst
2f79 : e005             tinc13   cpx #5
2f7b : d0da                     bne tinc12
2f7d : ca                       dex
2f7e : ee0302                   inc abst
2f81 :                  tdec12
                                set_stat $ff
                       >            load_flag $ff
2f81 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2f83 : 48              >            pha         ;use stack to load status
2f84 : 28              >            plp
                        
2f85 : ce0302                   dec abst
                                tst_abs rINC,fINC,$ff-fnz
2f88 : 08              >            php         ;save flags
2f89 : ad0302          >            lda abst
2f8c : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2f8f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f91 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f92 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2f94 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2f97 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f99 : ca                       dex
2f9a : 300b                     bmi tdec13
2f9c : e001                     cpx #1
2f9e : d0e1                     bne tdec12
2fa0 : a981                     lda #$81
2fa2 : 8d0302                   sta abst
2fa5 : d0da                     bne tdec12
2fa7 :                  tdec13
                                next_test
2fa7 : ad0002          >            lda test_case   ;previous test
2faa : c923            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2fac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0024 =                 >test_num = test_num + 1
2fae : a924            >            lda #test_num   ;*** next tests' number
2fb0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; zeropage indexed
2fb3 : a200                     ldx #0
2fb5 : a97e                     lda #$7e
2fb7 : 9502             tinc4   sta zpt,x
                                set_stat 0
                       >            load_flag 0
2fb9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2fbb : 48              >            pha         ;use stack to load status
2fbc : 28              >            plp
                        
2fbd : f602                     inc zpt,x
                                tst_zx rINC,fINC,0
2fbf : 08              >            php         ;save flags
2fc0 : b502            >            lda zpt,x
2fc2 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2fc5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fc7 : 68              >            pla         ;load status
                       >            eor_flag 0
2fc8 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2fca : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2fcd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2fcf : b502                     lda zpt,x
2fd1 : e8                       inx
2fd2 : e002                     cpx #2
2fd4 : d002                     bne tinc5
2fd6 : a9fe                     lda #$fe
2fd8 : e005             tinc5   cpx #5
2fda : d0db                     bne tinc4
2fdc : ca                       dex
2fdd : a902                     lda #2
2fdf : 9502             tdec4   sta zpt,x
                                set_stat 0
                       >            load_flag 0
2fe1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2fe3 : 48              >            pha         ;use stack to load status
2fe4 : 28              >            plp
                        
2fe5 : d602                     dec zpt,x
                                tst_zx rINC,fINC,0
2fe7 : 08              >            php         ;save flags
2fe8 : b502            >            lda zpt,x
2fea : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2fed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fef : 68              >            pla         ;load status
                       >            eor_flag 0
2ff0 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2ff2 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2ff5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ff7 : b502                     lda zpt,x
2ff9 : ca                       dex
2ffa : 3008                     bmi tdec5
2ffc : e001                     cpx #1
2ffe : d0df                     bne tdec4
3000 : a981                     lda #$81
3002 : d0db                     bne tdec4
3004 :                  tdec5
3004 : a200                     ldx #0
3006 : a97e                     lda #$7e
3008 : 9502             tinc14  sta zpt,x
                                set_stat $ff
                       >            load_flag $ff
300a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
300c : 48              >            pha         ;use stack to load status
300d : 28              >            plp
                        
300e : f602                     inc zpt,x
                                tst_zx rINC,fINC,$ff-fnz
3010 : 08              >            php         ;save flags
3011 : b502            >            lda zpt,x
3013 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
3016 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3018 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3019 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
301b : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
301e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3020 : b502                     lda zpt,x
3022 : e8                       inx
3023 : e002                     cpx #2
3025 : d002                     bne tinc15
3027 : a9fe                     lda #$fe
3029 : e005             tinc15  cpx #5
302b : d0db                     bne tinc14
302d : ca                       dex
302e : a902                     lda #2
3030 : 9502             tdec14  sta zpt,x
                                set_stat $ff
                       >            load_flag $ff
3032 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3034 : 48              >            pha         ;use stack to load status
3035 : 28              >            plp
                        
3036 : d602                     dec zpt,x
                                tst_zx rINC,fINC,$ff-fnz
3038 : 08              >            php         ;save flags
3039 : b502            >            lda zpt,x
303b : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
303e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3040 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3041 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3043 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
3046 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3048 : b502                     lda zpt,x
304a : ca                       dex
304b : 3008                     bmi tdec15
304d : e001                     cpx #1
304f : d0df                     bne tdec14
3051 : a981                     lda #$81
3053 : d0db                     bne tdec14
3055 :                  tdec15
                                next_test
3055 : ad0002          >            lda test_case   ;previous test
3058 : c924            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
305a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0025 =                 >test_num = test_num + 1
305c : a925            >            lda #test_num   ;*** next tests' number
305e : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; memory indexed
3061 : a200                     ldx #0
3063 : a97e                     lda #$7e
3065 : 9d0302           tinc6   sta abst,x
                                set_stat 0
                       >            load_flag 0
3068 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
306a : 48              >            pha         ;use stack to load status
306b : 28              >            plp
                        
306c : fe0302                   inc abst,x
                                tst_absx rINC,fINC,0
306f : 08              >            php         ;save flags
3070 : bd0302          >            lda abst,x
3073 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
3076 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3078 : 68              >            pla         ;load status
                       >            eor_flag 0
3079 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
307b : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
307e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3080 : bd0302                   lda abst,x
3083 : e8                       inx
3084 : e002                     cpx #2
3086 : d002                     bne tinc7
3088 : a9fe                     lda #$fe
308a : e005             tinc7   cpx #5
308c : d0d7                     bne tinc6
308e : ca                       dex
308f : a902                     lda #2
3091 : 9d0302           tdec6   sta abst,x
                                set_stat 0
                       >            load_flag 0
3094 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3096 : 48              >            pha         ;use stack to load status
3097 : 28              >            plp
                        
3098 : de0302                   dec abst,x
                                tst_absx rINC,fINC,0
309b : 08              >            php         ;save flags
309c : bd0302          >            lda abst,x
309f : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
30a2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30a4 : 68              >            pla         ;load status
                       >            eor_flag 0
30a5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
30a7 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
30aa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30ac : bd0302                   lda abst,x
30af : ca                       dex
30b0 : 3008                     bmi tdec7
30b2 : e001                     cpx #1
30b4 : d0db                     bne tdec6
30b6 : a981                     lda #$81
30b8 : d0d7                     bne tdec6
30ba :                  tdec7
30ba : a200                     ldx #0
30bc : a97e                     lda #$7e
30be : 9d0302           tinc16  sta abst,x
                                set_stat $ff
                       >            load_flag $ff
30c1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
30c3 : 48              >            pha         ;use stack to load status
30c4 : 28              >            plp
                        
30c5 : fe0302                   inc abst,x
                                tst_absx rINC,fINC,$ff-fnz
30c8 : 08              >            php         ;save flags
30c9 : bd0302          >            lda abst,x
30cc : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
30cf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30d1 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
30d2 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
30d4 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
30d7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30d9 : bd0302                   lda abst,x
30dc : e8                       inx
30dd : e002                     cpx #2
30df : d002                     bne tinc17
30e1 : a9fe                     lda #$fe
30e3 : e005             tinc17  cpx #5
30e5 : d0d7                     bne tinc16
30e7 : ca                       dex
30e8 : a902                     lda #2
30ea : 9d0302           tdec16  sta abst,x
                                set_stat $ff
                       >            load_flag $ff
30ed : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
30ef : 48              >            pha         ;use stack to load status
30f0 : 28              >            plp
                        
30f1 : de0302                   dec abst,x
                                tst_absx rINC,fINC,$ff-fnz
30f4 : 08              >            php         ;save flags
30f5 : bd0302          >            lda abst,x
30f8 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
30fb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30fd : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
30fe : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3100 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
3103 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3105 : bd0302                   lda abst,x
3108 : ca                       dex
3109 : 3008                     bmi tdec17
310b : e001                     cpx #1
310d : d0db                     bne tdec16
310f : a981                     lda #$81
3111 : d0d7                     bne tdec16
3113 :                  tdec17
                                next_test
3113 : ad0002          >            lda test_case   ;previous test
3116 : c925            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
3118 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0026 =                 >test_num = test_num + 1
311a : a926            >            lda #test_num   ;*** next tests' number
311c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing logical instructions - AND EOR ORA all addressing modes
                        ; AND
311f : a203                     ldx #3          ;immediate
3121 : b512             tand    lda zpAN,x
3123 : 8d0902                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,0
                       >            load_flag 0
3126 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3128 : 48              >            pha         ;use stack to load status
3129 : bd5a02          >            lda absANa,x    ;precharge accu
312c : 28              >            plp
                        
312d : 200802                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,0
3130 : 08              >            php         ;save flags
3131 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3134 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3136 : 68              >            pla         ;load status
                       >            eor_flag 0
3137 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3139 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
313c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
313e : ca                       dex
313f : 10e0                     bpl tand
3141 : a203                     ldx #3
3143 : b512             tand1   lda zpAN,x
3145 : 8d0902                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,$ff
                       >            load_flag $ff
3148 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
314a : 48              >            pha         ;use stack to load status
314b : bd5a02          >            lda absANa,x    ;precharge accu
314e : 28              >            plp
                        
314f : 200802                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
3152 : 08              >            php         ;save flags
3153 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3156 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3158 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3159 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
315b : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
315e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3160 : ca                       dex
3161 : 10e0                     bpl tand1
                        
3163 : a203                     ldx #3      ;zp
3165 : b512             tand2   lda zpAN,x
3167 : 8502                     sta zpt
                                set_ax  absANa,0
                       >            load_flag 0
3169 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
316b : 48              >            pha         ;use stack to load status
316c : bd5a02          >            lda absANa,x    ;precharge accu
316f : 28              >            plp
                        
3170 : 2502                     and zpt
                                tst_ax  absrlo,absflo,0
3172 : 08              >            php         ;save flags
3173 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3176 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3178 : 68              >            pla         ;load status
                       >            eor_flag 0
3179 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
317b : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
317e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3180 : ca                       dex
3181 : 10e2                     bpl tand2
3183 : a203                     ldx #3
3185 : b512             tand3   lda zpAN,x
3187 : 8502                     sta zpt
                                set_ax  absANa,$ff
                       >            load_flag $ff
3189 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
318b : 48              >            pha         ;use stack to load status
318c : bd5a02          >            lda absANa,x    ;precharge accu
318f : 28              >            plp
                        
3190 : 2502                     and zpt
                                tst_ax  absrlo,absflo,$ff-fnz
3192 : 08              >            php         ;save flags
3193 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3196 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3198 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3199 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
319b : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
319e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31a0 : ca                       dex
31a1 : 10e2                     bpl tand3
                        
31a3 : a203                     ldx #3      ;abs
31a5 : b512             tand4   lda zpAN,x
31a7 : 8d0302                   sta abst
                                set_ax  absANa,0
                       >            load_flag 0
31aa : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
31ac : 48              >            pha         ;use stack to load status
31ad : bd5a02          >            lda absANa,x    ;precharge accu
31b0 : 28              >            plp
                        
31b1 : 2d0302                   and abst
                                tst_ax  absrlo,absflo,0
31b4 : 08              >            php         ;save flags
31b5 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
31b8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31ba : 68              >            pla         ;load status
                       >            eor_flag 0
31bb : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
31bd : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31c0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31c2 : ca                       dex
31c3 : 10e0                     bpl tand4
31c5 : a203                     ldx #3
31c7 : b512             tand5   lda zpAN,x
31c9 : 8d0302                   sta abst
                                set_ax  absANa,$ff
                       >            load_flag $ff
31cc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
31ce : 48              >            pha         ;use stack to load status
31cf : bd5a02          >            lda absANa,x    ;precharge accu
31d2 : 28              >            plp
                        
31d3 : 2d0302                   and abst
                                tst_ax  absrlo,absflo,$ff-fnz
31d6 : 08              >            php         ;save flags
31d7 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
31da : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31dc : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
31dd : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
31df : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31e2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31e4 : ca                       dex
31e5 : 1002                     bpl tand6
                        
31e7 : a203                     ldx #3      ;zp,x
31e9 :                  tand6
                                set_ax  absANa,0
                       >            load_flag 0
31e9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
31eb : 48              >            pha         ;use stack to load status
31ec : bd5a02          >            lda absANa,x    ;precharge accu
31ef : 28              >            plp
                        
31f0 : 3512                     and zpAN,x
                                tst_ax  absrlo,absflo,0
31f2 : 08              >            php         ;save flags
31f3 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
31f6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31f8 : 68              >            pla         ;load status
                       >            eor_flag 0
31f9 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
31fb : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31fe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3200 : ca                       dex
3201 : 10e6                     bpl tand6
3203 : a203                     ldx #3
3205 :                  tand7
                                set_ax  absANa,$ff
                       >            load_flag $ff
3205 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3207 : 48              >            pha         ;use stack to load status
3208 : bd5a02          >            lda absANa,x    ;precharge accu
320b : 28              >            plp
                        
320c : 3512                     and zpAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
320e : 08              >            php         ;save flags
320f : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3212 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3214 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3215 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3217 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
321a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
321c : ca                       dex
321d : 10e6                     bpl tand7
                        
321f : a203                     ldx #3      ;abs,x
3221 :                  tand8
                                set_ax  absANa,0
                       >            load_flag 0
3221 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3223 : 48              >            pha         ;use stack to load status
3224 : bd5a02          >            lda absANa,x    ;precharge accu
3227 : 28              >            plp
                        
3228 : 3d4e02                   and absAN,x
                                tst_ax  absrlo,absflo,0
322b : 08              >            php         ;save flags
322c : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
322f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3231 : 68              >            pla         ;load status
                       >            eor_flag 0
3232 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3234 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3237 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3239 : ca                       dex
323a : 10e5                     bpl tand8
323c : a203                     ldx #3
323e :                  tand9
                                set_ax  absANa,$ff
                       >            load_flag $ff
323e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3240 : 48              >            pha         ;use stack to load status
3241 : bd5a02          >            lda absANa,x    ;precharge accu
3244 : 28              >            plp
                        
3245 : 3d4e02                   and absAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
3248 : 08              >            php         ;save flags
3249 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
324c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
324e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
324f : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3251 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3254 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3256 : ca                       dex
3257 : 10e5                     bpl tand9
                        
3259 : a003                     ldy #3      ;abs,y
325b :                  tand10
                                set_ay  absANa,0
                       >            load_flag 0
325b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
325d : 48              >            pha         ;use stack to load status
325e : b95a02          >            lda absANa,y    ;precharge accu
3261 : 28              >            plp
                        
3262 : 394e02                   and absAN,y
                                tst_ay  absrlo,absflo,0
3265 : 08              >            php         ;save flags
3266 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3269 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
326b : 68              >            pla         ;load status
                       >            eor_flag 0
326c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
326e : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3271 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3273 : 88                       dey
3274 : 10e5                     bpl tand10
3276 : a003                     ldy #3
3278 :                  tand11
                                set_ay  absANa,$ff
                       >            load_flag $ff
3278 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
327a : 48              >            pha         ;use stack to load status
327b : b95a02          >            lda absANa,y    ;precharge accu
327e : 28              >            plp
                        
327f : 394e02                   and absAN,y
                                tst_ay  absrlo,absflo,$ff-fnz
3282 : 08              >            php         ;save flags
3283 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3286 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3288 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3289 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
328b : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
328e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3290 : 88                       dey
3291 : 10e5                     bpl tand11
                        
3293 : a206                     ldx #6      ;(zp,x)
3295 : a003                     ldy #3
3297 :                  tand12
                                set_ay  absANa,0
                       >            load_flag 0
3297 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3299 : 48              >            pha         ;use stack to load status
329a : b95a02          >            lda absANa,y    ;precharge accu
329d : 28              >            plp
                        
329e : 2130                     and (indAN,x)
                                tst_ay  absrlo,absflo,0
32a0 : 08              >            php         ;save flags
32a1 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
32a4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
32a6 : 68              >            pla         ;load status
                       >            eor_flag 0
32a7 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
32a9 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
32ac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
32ae : ca                       dex
32af : ca                       dex
32b0 : 88                       dey
32b1 : 10e4                     bpl tand12
32b3 : a206                     ldx #6
32b5 : a003                     ldy #3
32b7 :                  tand13
                                set_ay  absANa,$ff
                       >            load_flag $ff
32b7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
32b9 : 48              >            pha         ;use stack to load status
32ba : b95a02          >            lda absANa,y    ;precharge accu
32bd : 28              >            plp
                        
32be : 2130                     and (indAN,x)
                                tst_ay  absrlo,absflo,$ff-fnz
32c0 : 08              >            php         ;save flags
32c1 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
32c4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
32c6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
32c7 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
32c9 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
32cc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
32ce : ca                       dex
32cf : ca                       dex
32d0 : 88                       dey
32d1 : 10e4                     bpl tand13
                        
32d3 : a003                     ldy #3      ;(zp),y
32d5 :                  tand14
                                set_ay  absANa,0
                       >            load_flag 0
32d5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
32d7 : 48              >            pha         ;use stack to load status
32d8 : b95a02          >            lda absANa,y    ;precharge accu
32db : 28              >            plp
                        
32dc : 3130                     and (indAN),y
                                tst_ay  absrlo,absflo,0
32de : 08              >            php         ;save flags
32df : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
32e2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
32e4 : 68              >            pla         ;load status
                       >            eor_flag 0
32e5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
32e7 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
32ea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
32ec : 88                       dey
32ed : 10e6                     bpl tand14
32ef : a003                     ldy #3
32f1 :                  tand15
                                set_ay  absANa,$ff
                       >            load_flag $ff
32f1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
32f3 : 48              >            pha         ;use stack to load status
32f4 : b95a02          >            lda absANa,y    ;precharge accu
32f7 : 28              >            plp
                        
32f8 : 3130                     and (indAN),y
                                tst_ay  absrlo,absflo,$ff-fnz
32fa : 08              >            php         ;save flags
32fb : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
32fe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3300 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3301 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3303 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3306 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3308 : 88                       dey
3309 : 10e6                     bpl tand15
                                next_test
330b : ad0002          >            lda test_case   ;previous test
330e : c926            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
3310 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0027 =                 >test_num = test_num + 1
3312 : a927            >            lda #test_num   ;*** next tests' number
3314 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; EOR
3317 : a203                     ldx #3          ;immediate - self modifying code
3319 : b516             teor    lda zpEO,x
331b : 8d0c02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,0
                       >            load_flag 0
331e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3320 : 48              >            pha         ;use stack to load status
3321 : bd5e02          >            lda absEOa,x    ;precharge accu
3324 : 28              >            plp
                        
3325 : 200b02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,0
3328 : 08              >            php         ;save flags
3329 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
332c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
332e : 68              >            pla         ;load status
                       >            eor_flag 0
332f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3331 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3334 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3336 : ca                       dex
3337 : 10e0                     bpl teor
3339 : a203                     ldx #3
333b : b516             teor1   lda zpEO,x
333d : 8d0c02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,$ff
                       >            load_flag $ff
3340 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3342 : 48              >            pha         ;use stack to load status
3343 : bd5e02          >            lda absEOa,x    ;precharge accu
3346 : 28              >            plp
                        
3347 : 200b02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
334a : 08              >            php         ;save flags
334b : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
334e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3350 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3351 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3353 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3356 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3358 : ca                       dex
3359 : 10e0                     bpl teor1
                        
335b : a203                     ldx #3      ;zp
335d : b516             teor2    lda zpEO,x
335f : 8502                     sta zpt
                                set_ax  absEOa,0
                       >            load_flag 0
3361 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3363 : 48              >            pha         ;use stack to load status
3364 : bd5e02          >            lda absEOa,x    ;precharge accu
3367 : 28              >            plp
                        
3368 : 4502                     eor zpt
                                tst_ax  absrlo,absflo,0
336a : 08              >            php         ;save flags
336b : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
336e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3370 : 68              >            pla         ;load status
                       >            eor_flag 0
3371 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3373 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3376 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3378 : ca                       dex
3379 : 10e2                     bpl teor2
337b : a203                     ldx #3
337d : b516             teor3   lda zpEO,x
337f : 8502                     sta zpt
                                set_ax  absEOa,$ff
                       >            load_flag $ff
3381 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3383 : 48              >            pha         ;use stack to load status
3384 : bd5e02          >            lda absEOa,x    ;precharge accu
3387 : 28              >            plp
                        
3388 : 4502                     eor zpt
                                tst_ax  absrlo,absflo,$ff-fnz
338a : 08              >            php         ;save flags
338b : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
338e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3390 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3391 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3393 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3396 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3398 : ca                       dex
3399 : 10e2                     bpl teor3
                        
339b : a203                     ldx #3      ;abs
339d : b516             teor4   lda zpEO,x
339f : 8d0302                   sta abst
                                set_ax  absEOa,0
                       >            load_flag 0
33a2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
33a4 : 48              >            pha         ;use stack to load status
33a5 : bd5e02          >            lda absEOa,x    ;precharge accu
33a8 : 28              >            plp
                        
33a9 : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,0
33ac : 08              >            php         ;save flags
33ad : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
33b0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
33b2 : 68              >            pla         ;load status
                       >            eor_flag 0
33b3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
33b5 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
33b8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
33ba : ca                       dex
33bb : 10e0                     bpl teor4
33bd : a203                     ldx #3
33bf : b516             teor5   lda zpEO,x
33c1 : 8d0302                   sta abst
                                set_ax  absEOa,$ff
                       >            load_flag $ff
33c4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
33c6 : 48              >            pha         ;use stack to load status
33c7 : bd5e02          >            lda absEOa,x    ;precharge accu
33ca : 28              >            plp
                        
33cb : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,$ff-fnz
33ce : 08              >            php         ;save flags
33cf : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
33d2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
33d4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
33d5 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
33d7 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
33da : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
33dc : ca                       dex
33dd : 1002                     bpl teor6
                        
33df : a203                     ldx #3      ;zp,x
33e1 :                  teor6
                                set_ax  absEOa,0
                       >            load_flag 0
33e1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
33e3 : 48              >            pha         ;use stack to load status
33e4 : bd5e02          >            lda absEOa,x    ;precharge accu
33e7 : 28              >            plp
                        
33e8 : 5516                     eor zpEO,x
                                tst_ax  absrlo,absflo,0
33ea : 08              >            php         ;save flags
33eb : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
33ee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
33f0 : 68              >            pla         ;load status
                       >            eor_flag 0
33f1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
33f3 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
33f6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
33f8 : ca                       dex
33f9 : 10e6                     bpl teor6
33fb : a203                     ldx #3
33fd :                  teor7
                                set_ax  absEOa,$ff
                       >            load_flag $ff
33fd : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
33ff : 48              >            pha         ;use stack to load status
3400 : bd5e02          >            lda absEOa,x    ;precharge accu
3403 : 28              >            plp
                        
3404 : 5516                     eor zpEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
3406 : 08              >            php         ;save flags
3407 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
340a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
340c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
340d : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
340f : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3412 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3414 : ca                       dex
3415 : 10e6                     bpl teor7
                        
3417 : a203                     ldx #3      ;abs,x
3419 :                  teor8
                                set_ax  absEOa,0
                       >            load_flag 0
3419 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
341b : 48              >            pha         ;use stack to load status
341c : bd5e02          >            lda absEOa,x    ;precharge accu
341f : 28              >            plp
                        
3420 : 5d5202                   eor absEO,x
                                tst_ax  absrlo,absflo,0
3423 : 08              >            php         ;save flags
3424 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3427 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3429 : 68              >            pla         ;load status
                       >            eor_flag 0
342a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
342c : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
342f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3431 : ca                       dex
3432 : 10e5                     bpl teor8
3434 : a203                     ldx #3
3436 :                  teor9
                                set_ax  absEOa,$ff
                       >            load_flag $ff
3436 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3438 : 48              >            pha         ;use stack to load status
3439 : bd5e02          >            lda absEOa,x    ;precharge accu
343c : 28              >            plp
                        
343d : 5d5202                   eor absEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
3440 : 08              >            php         ;save flags
3441 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3444 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3446 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3447 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3449 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
344c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
344e : ca                       dex
344f : 10e5                     bpl teor9
                        
3451 : a003                     ldy #3      ;abs,y
3453 :                  teor10
                                set_ay  absEOa,0
                       >            load_flag 0
3453 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3455 : 48              >            pha         ;use stack to load status
3456 : b95e02          >            lda absEOa,y    ;precharge accu
3459 : 28              >            plp
                        
345a : 595202                   eor absEO,y
                                tst_ay  absrlo,absflo,0
345d : 08              >            php         ;save flags
345e : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3461 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3463 : 68              >            pla         ;load status
                       >            eor_flag 0
3464 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3466 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3469 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
346b : 88                       dey
346c : 10e5                     bpl teor10
346e : a003                     ldy #3
3470 :                  teor11
                                set_ay  absEOa,$ff
                       >            load_flag $ff
3470 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3472 : 48              >            pha         ;use stack to load status
3473 : b95e02          >            lda absEOa,y    ;precharge accu
3476 : 28              >            plp
                        
3477 : 595202                   eor absEO,y
                                tst_ay  absrlo,absflo,$ff-fnz
347a : 08              >            php         ;save flags
347b : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
347e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3480 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3481 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3483 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3486 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3488 : 88                       dey
3489 : 10e5                     bpl teor11
                        
348b : a206                     ldx #6      ;(zp,x)
348d : a003                     ldy #3
348f :                  teor12
                                set_ay  absEOa,0
                       >            load_flag 0
348f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3491 : 48              >            pha         ;use stack to load status
3492 : b95e02          >            lda absEOa,y    ;precharge accu
3495 : 28              >            plp
                        
3496 : 4138                     eor (indEO,x)
                                tst_ay  absrlo,absflo,0
3498 : 08              >            php         ;save flags
3499 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
349c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
349e : 68              >            pla         ;load status
                       >            eor_flag 0
349f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
34a1 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
34a4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
34a6 : ca                       dex
34a7 : ca                       dex
34a8 : 88                       dey
34a9 : 10e4                     bpl teor12
34ab : a206                     ldx #6
34ad : a003                     ldy #3
34af :                  teor13
                                set_ay  absEOa,$ff
                       >            load_flag $ff
34af : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
34b1 : 48              >            pha         ;use stack to load status
34b2 : b95e02          >            lda absEOa,y    ;precharge accu
34b5 : 28              >            plp
                        
34b6 : 4138                     eor (indEO,x)
                                tst_ay  absrlo,absflo,$ff-fnz
34b8 : 08              >            php         ;save flags
34b9 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
34bc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
34be : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
34bf : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
34c1 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
34c4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
34c6 : ca                       dex
34c7 : ca                       dex
34c8 : 88                       dey
34c9 : 10e4                     bpl teor13
                        
34cb : a003                     ldy #3      ;(zp),y
34cd :                  teor14
                                set_ay  absEOa,0
                       >            load_flag 0
34cd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
34cf : 48              >            pha         ;use stack to load status
34d0 : b95e02          >            lda absEOa,y    ;precharge accu
34d3 : 28              >            plp
                        
34d4 : 5138                     eor (indEO),y
                                tst_ay  absrlo,absflo,0
34d6 : 08              >            php         ;save flags
34d7 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
34da : d0fe            >        bne *           ;failed not equal (non zero)
                       >
34dc : 68              >            pla         ;load status
                       >            eor_flag 0
34dd : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
34df : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
34e2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
34e4 : 88                       dey
34e5 : 10e6                     bpl teor14
34e7 : a003                     ldy #3
34e9 :                  teor15
                                set_ay  absEOa,$ff
                       >            load_flag $ff
34e9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
34eb : 48              >            pha         ;use stack to load status
34ec : b95e02          >            lda absEOa,y    ;precharge accu
34ef : 28              >            plp
                        
34f0 : 5138                     eor (indEO),y
                                tst_ay  absrlo,absflo,$ff-fnz
34f2 : 08              >            php         ;save flags
34f3 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
34f6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
34f8 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
34f9 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
34fb : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
34fe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3500 : 88                       dey
3501 : 10e6                     bpl teor15
                                next_test
3503 : ad0002          >            lda test_case   ;previous test
3506 : c927            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
3508 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0028 =                 >test_num = test_num + 1
350a : a928            >            lda #test_num   ;*** next tests' number
350c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; OR
350f : a203                     ldx #3          ;immediate - self modifying code
3511 : b50e             tora    lda zpOR,x
3513 : 8d0f02                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,0
                       >            load_flag 0
3516 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3518 : 48              >            pha         ;use stack to load status
3519 : bd5602          >            lda absORa,x    ;precharge accu
351c : 28              >            plp
                        
351d : 200e02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,0
3520 : 08              >            php         ;save flags
3521 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3524 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3526 : 68              >            pla         ;load status
                       >            eor_flag 0
3527 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3529 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
352c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
352e : ca                       dex
352f : 10e0                     bpl tora
3531 : a203                     ldx #3
3533 : b50e             tora1   lda zpOR,x
3535 : 8d0f02                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,$ff
                       >            load_flag $ff
3538 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
353a : 48              >            pha         ;use stack to load status
353b : bd5602          >            lda absORa,x    ;precharge accu
353e : 28              >            plp
                        
353f : 200e02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
3542 : 08              >            php         ;save flags
3543 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3546 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3548 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3549 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
354b : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
354e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3550 : ca                       dex
3551 : 10e0                     bpl tora1
                        
3553 : a203                     ldx #3      ;zp
3555 : b50e             tora2   lda zpOR,x
3557 : 8502                     sta zpt
                                set_ax  absORa,0
                       >            load_flag 0
3559 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
355b : 48              >            pha         ;use stack to load status
355c : bd5602          >            lda absORa,x    ;precharge accu
355f : 28              >            plp
                        
3560 : 0502                     ora zpt
                                tst_ax  absrlo,absflo,0
3562 : 08              >            php         ;save flags
3563 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3566 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3568 : 68              >            pla         ;load status
                       >            eor_flag 0
3569 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
356b : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
356e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3570 : ca                       dex
3571 : 10e2                     bpl tora2
3573 : a203                     ldx #3
3575 : b50e             tora3   lda zpOR,x
3577 : 8502                     sta zpt
                                set_ax  absORa,$ff
                       >            load_flag $ff
3579 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
357b : 48              >            pha         ;use stack to load status
357c : bd5602          >            lda absORa,x    ;precharge accu
357f : 28              >            plp
                        
3580 : 0502                     ora zpt
                                tst_ax  absrlo,absflo,$ff-fnz
3582 : 08              >            php         ;save flags
3583 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3586 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3588 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3589 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
358b : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
358e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3590 : ca                       dex
3591 : 10e2                     bpl tora3
                        
3593 : a203                     ldx #3      ;abs
3595 : b50e             tora4   lda zpOR,x
3597 : 8d0302                   sta abst
                                set_ax  absORa,0
                       >            load_flag 0
359a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
359c : 48              >            pha         ;use stack to load status
359d : bd5602          >            lda absORa,x    ;precharge accu
35a0 : 28              >            plp
                        
35a1 : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,0
35a4 : 08              >            php         ;save flags
35a5 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
35a8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
35aa : 68              >            pla         ;load status
                       >            eor_flag 0
35ab : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
35ad : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
35b0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
35b2 : ca                       dex
35b3 : 10e0                     bpl tora4
35b5 : a203                     ldx #3
35b7 : b50e             tora5   lda zpOR,x
35b9 : 8d0302                   sta abst
                                set_ax  absORa,$ff
                       >            load_flag $ff
35bc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
35be : 48              >            pha         ;use stack to load status
35bf : bd5602          >            lda absORa,x    ;precharge accu
35c2 : 28              >            plp
                        
35c3 : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,$ff-fnz
35c6 : 08              >            php         ;save flags
35c7 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
35ca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
35cc : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
35cd : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
35cf : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
35d2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
35d4 : ca                       dex
35d5 : 1002                     bpl tora6
                        
35d7 : a203                     ldx #3      ;zp,x
35d9 :                  tora6
                                set_ax  absORa,0
                       >            load_flag 0
35d9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
35db : 48              >            pha         ;use stack to load status
35dc : bd5602          >            lda absORa,x    ;precharge accu
35df : 28              >            plp
                        
35e0 : 150e                     ora zpOR,x
                                tst_ax  absrlo,absflo,0
35e2 : 08              >            php         ;save flags
35e3 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
35e6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
35e8 : 68              >            pla         ;load status
                       >            eor_flag 0
35e9 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
35eb : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
35ee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
35f0 : ca                       dex
35f1 : 10e6                     bpl tora6
35f3 : a203                     ldx #3
35f5 :                  tora7
                                set_ax  absORa,$ff
                       >            load_flag $ff
35f5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
35f7 : 48              >            pha         ;use stack to load status
35f8 : bd5602          >            lda absORa,x    ;precharge accu
35fb : 28              >            plp
                        
35fc : 150e                     ora zpOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
35fe : 08              >            php         ;save flags
35ff : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3602 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3604 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3605 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3607 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
360a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
360c : ca                       dex
360d : 10e6                     bpl tora7
                        
360f : a203                     ldx #3      ;abs,x
3611 :                  tora8
                                set_ax  absORa,0
                       >            load_flag 0
3611 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3613 : 48              >            pha         ;use stack to load status
3614 : bd5602          >            lda absORa,x    ;precharge accu
3617 : 28              >            plp
                        
3618 : 1d4a02                   ora absOR,x
                                tst_ax  absrlo,absflo,0
361b : 08              >            php         ;save flags
361c : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
361f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3621 : 68              >            pla         ;load status
                       >            eor_flag 0
3622 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3624 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3627 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3629 : ca                       dex
362a : 10e5                     bpl tora8
362c : a203                     ldx #3
362e :                  tora9
                                set_ax  absORa,$ff
                       >            load_flag $ff
362e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3630 : 48              >            pha         ;use stack to load status
3631 : bd5602          >            lda absORa,x    ;precharge accu
3634 : 28              >            plp
                        
3635 : 1d4a02                   ora absOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
3638 : 08              >            php         ;save flags
3639 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
363c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
363e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
363f : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3641 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3644 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3646 : ca                       dex
3647 : 10e5                     bpl tora9
                        
3649 : a003                     ldy #3      ;abs,y
364b :                  tora10
                                set_ay  absORa,0
                       >            load_flag 0
364b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
364d : 48              >            pha         ;use stack to load status
364e : b95602          >            lda absORa,y    ;precharge accu
3651 : 28              >            plp
                        
3652 : 194a02                   ora absOR,y
                                tst_ay  absrlo,absflo,0
3655 : 08              >            php         ;save flags
3656 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3659 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
365b : 68              >            pla         ;load status
                       >            eor_flag 0
365c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
365e : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3661 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3663 : 88                       dey
3664 : 10e5                     bpl tora10
3666 : a003                     ldy #3
3668 :                  tora11
                                set_ay  absORa,$ff
                       >            load_flag $ff
3668 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
366a : 48              >            pha         ;use stack to load status
366b : b95602          >            lda absORa,y    ;precharge accu
366e : 28              >            plp
                        
366f : 194a02                   ora absOR,y
                                tst_ay  absrlo,absflo,$ff-fnz
3672 : 08              >            php         ;save flags
3673 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3676 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3678 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3679 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
367b : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
367e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3680 : 88                       dey
3681 : 10e5                     bpl tora11
                        
3683 : a206                     ldx #6      ;(zp,x)
3685 : a003                     ldy #3
3687 :                  tora12
                                set_ay  absORa,0
                       >            load_flag 0
3687 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3689 : 48              >            pha         ;use stack to load status
368a : b95602          >            lda absORa,y    ;precharge accu
368d : 28              >            plp
                        
368e : 0140                     ora (indOR,x)
                                tst_ay  absrlo,absflo,0
3690 : 08              >            php         ;save flags
3691 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3694 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3696 : 68              >            pla         ;load status
                       >            eor_flag 0
3697 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3699 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
369c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
369e : ca                       dex
369f : ca                       dex
36a0 : 88                       dey
36a1 : 10e4                     bpl tora12
36a3 : a206                     ldx #6
36a5 : a003                     ldy #3
36a7 :                  tora13
                                set_ay  absORa,$ff
                       >            load_flag $ff
36a7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
36a9 : 48              >            pha         ;use stack to load status
36aa : b95602          >            lda absORa,y    ;precharge accu
36ad : 28              >            plp
                        
36ae : 0140                     ora (indOR,x)
                                tst_ay  absrlo,absflo,$ff-fnz
36b0 : 08              >            php         ;save flags
36b1 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
36b4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
36b6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
36b7 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
36b9 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
36bc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
36be : ca                       dex
36bf : ca                       dex
36c0 : 88                       dey
36c1 : 10e4                     bpl tora13
                        
36c3 : a003                     ldy #3      ;(zp),y
36c5 :                  tora14
                                set_ay  absORa,0
                       >            load_flag 0
36c5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
36c7 : 48              >            pha         ;use stack to load status
36c8 : b95602          >            lda absORa,y    ;precharge accu
36cb : 28              >            plp
                        
36cc : 1140                     ora (indOR),y
                                tst_ay  absrlo,absflo,0
36ce : 08              >            php         ;save flags
36cf : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
36d2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
36d4 : 68              >            pla         ;load status
                       >            eor_flag 0
36d5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
36d7 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
36da : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
36dc : 88                       dey
36dd : 10e6                     bpl tora14
36df : a003                     ldy #3
36e1 :                  tora15
                                set_ay  absORa,$ff
                       >            load_flag $ff
36e1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
36e3 : 48              >            pha         ;use stack to load status
36e4 : b95602          >            lda absORa,y    ;precharge accu
36e7 : 28              >            plp
                        
36e8 : 1140                     ora (indOR),y
                                tst_ay  absrlo,absflo,$ff-fnz
36ea : 08              >            php         ;save flags
36eb : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
36ee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
36f0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
36f1 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
36f3 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
36f6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
36f8 : 88                       dey
36f9 : 10e6                     bpl tora15
                            if I_flag = 3
36fb : 58                       cli
                            endif
                                next_test
36fc : ad0002          >            lda test_case   ;previous test
36ff : c928            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
3701 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0029 =                 >test_num = test_num + 1
3703 : a929            >            lda #test_num   ;*** next tests' number
3705 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
3708 : d8                       cld
3709 : a204                     ldx #ad2        ;for indexed test
370b : a0ff                     ldy #$ff        ;max range
370d : a900                     lda #0          ;start with adding zeroes & no carry
370f : 8502                     sta adfc        ;carry in - for diag
3711 : 8503                     sta ad1         ;operand 1 - accumulator
3713 : 8504                     sta ad2         ;operand 2 - memory or immediate
3715 : 8d0302                   sta ada2        ;non zp
3718 : 8505                     sta adrl        ;expected result bits 0-7
371a : 8506                     sta adrh        ;expected result bit 8 (carry out)
371c : a9ff                     lda #$ff        ;complemented operand 2 for subtract
371e : 8508                     sta sb2
3720 : 8d0402                   sta sba2        ;non zp
3723 : a902                     lda #2          ;expected Z-flag
3725 : 8507                     sta adrf
3727 : 18               tadd    clc             ;test with carry clear
3728 : 20a239                   jsr chkadd
372b : e602                     inc adfc        ;now with carry
372d : e605                     inc adrl        ;result +1
372f : 08                       php             ;save N & Z from low result
3730 : 08                       php
3731 : 68                       pla             ;accu holds expected flags
3732 : 2982                     and #$82        ;mask N & Z
3734 : 28                       plp
3735 : d002                     bne tadd1
3737 : e606                     inc adrh        ;result bit 8 - carry
3739 : 0506             tadd1   ora adrh        ;merge C to expected flags
373b : 8507                     sta adrf        ;save expected flags except overflow
373d : 38                       sec             ;test with carry set
373e : 20a239                   jsr chkadd
3741 : c602                     dec adfc        ;same for operand +1 but no carry
3743 : e603                     inc ad1
3745 : d0e0                     bne tadd        ;iterate op1
3747 : a900                     lda #0          ;preset result to op2 when op1 = 0
3749 : 8506                     sta adrh
374b : ee0302                   inc ada2
374e : e604                     inc ad2
3750 : 08                       php             ;save NZ as operand 2 becomes the new result
3751 : 68                       pla
3752 : 2982                     and #$82        ;mask N00000Z0
3754 : 8507                     sta adrf        ;no need to check carry as we are adding to 0
3756 : c608                     dec sb2         ;complement subtract operand 2
3758 : ce0402                   dec sba2
375b : a504                     lda ad2
375d : 8505                     sta adrl
375f : d0c6                     bne tadd        ;iterate op2
                            if disable_decimal < 1
                                next_test
3761 : ad0002          >            lda test_case   ;previous test
3764 : c929            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
3766 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
002a =                 >test_num = test_num + 1
3768 : a92a            >            lda #test_num   ;*** next tests' number
376a : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
376d : f8                       sed
376e : a204                     ldx #ad2        ;for indexed test
3770 : a0ff                     ldy #$ff        ;max range
3772 : a999                     lda #$99        ;start with adding 99 to 99 with carry
3774 : 8503                     sta ad1         ;operand 1 - accumulator
3776 : 8504                     sta ad2         ;operand 2 - memory or immediate
3778 : 8d0302                   sta ada2        ;non zp
377b : 8505                     sta adrl        ;expected result bits 0-7
377d : a901                     lda #1          ;set carry in & out
377f : 8502                     sta adfc        ;carry in - for diag
3781 : 8506                     sta adrh        ;expected result bit 8 (carry out)
3783 : a900                     lda #0          ;complemented operand 2 for subtract
3785 : 8508                     sta sb2
3787 : 8d0402                   sta sba2        ;non zp
378a : 38               tdad    sec             ;test with carry set
378b : 206f38                   jsr chkdad
378e : c602                     dec adfc        ;now with carry clear
3790 : a505                     lda adrl        ;decimal adjust result
3792 : d008                     bne tdad1       ;skip clear carry & preset result 99 (9A-1)
3794 : c606                     dec adrh
3796 : a999                     lda #$99
3798 : 8505                     sta adrl
379a : d012                     bne tdad3
379c : 290f             tdad1   and #$f         ;lower nibble mask
379e : d00c                     bne tdad2       ;no decimal adjust needed
37a0 : c605                     dec adrl        ;decimal adjust (?0-6)
37a2 : c605                     dec adrl
37a4 : c605                     dec adrl
37a6 : c605                     dec adrl
37a8 : c605                     dec adrl
37aa : c605                     dec adrl
37ac : c605             tdad2   dec adrl        ;result -1
37ae : 18               tdad3   clc             ;test with carry clear
37af : 206f38                   jsr chkdad
37b2 : e602                     inc adfc        ;same for operand -1 but with carry
37b4 : a503                     lda ad1         ;decimal adjust operand 1
37b6 : f015                     beq tdad5       ;iterate operand 2
37b8 : 290f                     and #$f         ;lower nibble mask
37ba : d00c                     bne tdad4       ;skip decimal adjust
37bc : c603                     dec ad1         ;decimal adjust (?0-6)
37be : c603                     dec ad1
37c0 : c603                     dec ad1
37c2 : c603                     dec ad1
37c4 : c603                     dec ad1
37c6 : c603                     dec ad1
37c8 : c603             tdad4   dec ad1         ;operand 1 -1
37ca : 4c8a37                   jmp tdad        ;iterate op1
                        
37cd : a999             tdad5   lda #$99        ;precharge op1 max
37cf : 8503                     sta ad1
37d1 : a504                     lda ad2         ;decimal adjust operand 2
37d3 : f030                     beq tdad7       ;end of iteration
37d5 : 290f                     and #$f         ;lower nibble mask
37d7 : d018                     bne tdad6       ;skip decimal adjust
37d9 : c604                     dec ad2         ;decimal adjust (?0-6)
37db : c604                     dec ad2
37dd : c604                     dec ad2
37df : c604                     dec ad2
37e1 : c604                     dec ad2
37e3 : c604                     dec ad2
37e5 : e608                     inc sb2         ;complemented decimal adjust for subtract (?9+6)
37e7 : e608                     inc sb2
37e9 : e608                     inc sb2
37eb : e608                     inc sb2
37ed : e608                     inc sb2
37ef : e608                     inc sb2
37f1 : c604             tdad6   dec ad2         ;operand 2 -1
37f3 : e608                     inc sb2         ;complemented operand for subtract
37f5 : a508                     lda sb2
37f7 : 8d0402                   sta sba2        ;copy as non zp operand
37fa : a504                     lda ad2
37fc : 8d0302                   sta ada2        ;copy as non zp operand
37ff : 8505                     sta adrl        ;new result since op1+carry=00+carry +op2=op2
3801 : e606                     inc adrh        ;result carry
3803 : d085                     bne tdad        ;iterate op2
3805 :                  tdad7
                                next_test
3805 : ad0002          >            lda test_case   ;previous test
3808 : c92a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
380a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
002b =                 >test_num = test_num + 1
380c : a92b            >            lda #test_num   ;*** next tests' number
380e : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; decimal/binary switch test
                        ; tests CLD, SED, PLP, RTI to properly switch between decimal & binary opcode
                        ;   tables
3811 : 18                       clc
3812 : d8                       cld
3813 : 08                       php
3814 : a955                     lda #$55
3816 : 6955                     adc #$55
3818 : c9aa                     cmp #$aa
                                trap_ne         ;expected binary result after cld
381a : d0fe            >        bne *           ;failed not equal (non zero)
                        
381c : 18                       clc
381d : f8                       sed
381e : 08                       php
381f : a955                     lda #$55
3821 : 6955                     adc #$55
3823 : c910                     cmp #$10
                                trap_ne         ;expected decimal result after sed
3825 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3827 : d8                       cld
3828 : 28                       plp
3829 : a955                     lda #$55
382b : 6955                     adc #$55
382d : c910                     cmp #$10
                                trap_ne         ;expected decimal result after plp D=1
382f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3831 : 28                       plp
3832 : a955                     lda #$55
3834 : 6955                     adc #$55
3836 : c9aa                     cmp #$aa
                                trap_ne         ;expected binary result after plp D=0
3838 : d0fe            >        bne *           ;failed not equal (non zero)
                        
383a : 18                       clc
383b : a938                     lda #hi bin_rti_ret ;emulated interrupt for rti
383d : 48                       pha
383e : a955                     lda #lo bin_rti_ret
3840 : 48                       pha
3841 : 08                       php
3842 : f8                       sed
3843 : a938                     lda #hi dec_rti_ret ;emulated interrupt for rti
3845 : 48                       pha
3846 : a94c                     lda #lo dec_rti_ret
3848 : 48                       pha
3849 : 08                       php
384a : d8                       cld
384b : 40                       rti
384c :                  dec_rti_ret
384c : a955                     lda #$55
384e : 6955                     adc #$55
3850 : c910                     cmp #$10
                                trap_ne         ;expected decimal result after rti D=1
3852 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3854 : 40                       rti
3855 :                  bin_rti_ret
3855 : a955                     lda #$55
3857 : 6955                     adc #$55
3859 : c9aa                     cmp #$aa
                                trap_ne         ;expected binary result after rti D=0
385b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                            endif
                        
385d : ad0002                   lda test_case
3860 : c92b                     cmp #test_num
                                trap_ne         ;previous test is out of sequence
3862 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3864 : a9f0                     lda #$f0        ;mark opcode testing complete
3866 : 8d0002                   sta test_case
                        
                        ; final RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                                check_ram
                       >            ;RAM check disabled - RAM size not set
                        
                        ; *** DEBUG INFO ***
                        ; to debug checksum errors uncomment check_ram in the next_test macro to
                        ; narrow down the responsible opcode.
                        ; may give false errors when monitor, OS or other background activity is
                        ; allowed during previous tests.
                        
                        
                        ; S U C C E S S ************************************************
                        ; -------------
                                success         ;if you get here everything went well
3869 : 4c6938          >        jmp *           ;test passed, no errors
                        
                        ; -------------
                        ; S U C C E S S ************************************************
386c : 4c0008                   jmp start       ;run again
                        
                            if disable_decimal < 1
                        ; core subroutine of the decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
386f :                  chkdad
                        ; decimal ADC / SBC zp
386f : 08                       php             ;save carry for subtract
3870 : a503                     lda ad1
3872 : 6504                     adc ad2         ;perform add
3874 : 08                       php
3875 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3877 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3879 : 68                       pla             ;check flags
387a : 2901                     and #1          ;mask carry
387c : c506                     cmp adrh
                                trap_ne         ;bad carry
387e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3880 : 28                       plp
3881 : 08                       php             ;save carry for next add
3882 : a503                     lda ad1
3884 : e508                     sbc sb2         ;perform subtract
3886 : 08                       php
3887 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3889 : d0fe            >        bne *           ;failed not equal (non zero)
                        
388b : 68                       pla             ;check flags
388c : 2901                     and #1          ;mask carry
388e : c506                     cmp adrh
                                trap_ne         ;bad flags
3890 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3892 : 28                       plp
                        ; decimal ADC / SBC abs
3893 : 08                       php             ;save carry for subtract
3894 : a503                     lda ad1
3896 : 6d0302                   adc ada2        ;perform add
3899 : 08                       php
389a : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
389c : d0fe            >        bne *           ;failed not equal (non zero)
                        
389e : 68                       pla             ;check flags
389f : 2901                     and #1          ;mask carry
38a1 : c506                     cmp adrh
                                trap_ne         ;bad carry
38a3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
38a5 : 28                       plp
38a6 : 08                       php             ;save carry for next add
38a7 : a503                     lda ad1
38a9 : ed0402                   sbc sba2        ;perform subtract
38ac : 08                       php
38ad : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
38af : d0fe            >        bne *           ;failed not equal (non zero)
                        
38b1 : 68                       pla             ;check flags
38b2 : 2901                     and #1          ;mask carry
38b4 : c506                     cmp adrh
                                trap_ne         ;bad carry
38b6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
38b8 : 28                       plp
                        ; decimal ADC / SBC #
38b9 : 08                       php             ;save carry for subtract
38ba : a504                     lda ad2
38bc : 8d1202                   sta ex_adci+1   ;set ADC # operand
38bf : a503                     lda ad1
38c1 : 201102                   jsr ex_adci     ;execute ADC # in RAM
38c4 : 08                       php
38c5 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
38c7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
38c9 : 68                       pla             ;check flags
38ca : 2901                     and #1          ;mask carry
38cc : c506                     cmp adrh
                                trap_ne         ;bad carry
38ce : d0fe            >        bne *           ;failed not equal (non zero)
                        
38d0 : 28                       plp
38d1 : 08                       php             ;save carry for next add
38d2 : a508                     lda sb2
38d4 : 8d1502                   sta ex_sbci+1   ;set SBC # operand
38d7 : a503                     lda ad1
38d9 : 201402                   jsr ex_sbci     ;execute SBC # in RAM
38dc : 08                       php
38dd : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
38df : d0fe            >        bne *           ;failed not equal (non zero)
                        
38e1 : 68                       pla             ;check flags
38e2 : 2901                     and #1          ;mask carry
38e4 : c506                     cmp adrh
                                trap_ne         ;bad carry
38e6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
38e8 : 28                       plp
                        ; decimal ADC / SBC zp,x
38e9 : 08                       php             ;save carry for subtract
38ea : a503                     lda ad1
38ec : 7500                     adc 0,x         ;perform add
38ee : 08                       php
38ef : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
38f1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
38f3 : 68                       pla             ;check flags
38f4 : 2901                     and #1          ;mask carry
38f6 : c506                     cmp adrh
                                trap_ne         ;bad carry
38f8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
38fa : 28                       plp
38fb : 08                       php             ;save carry for next add
38fc : a503                     lda ad1
38fe : f504                     sbc sb2-ad2,x   ;perform subtract
3900 : 08                       php
3901 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3903 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3905 : 68                       pla             ;check flags
3906 : 2901                     and #1          ;mask carry
3908 : c506                     cmp adrh
                                trap_ne         ;bad carry
390a : d0fe            >        bne *           ;failed not equal (non zero)
                        
390c : 28                       plp
                        ; decimal ADC / SBC abs,x
390d : 08                       php             ;save carry for subtract
390e : a503                     lda ad1
3910 : 7dff01                   adc ada2-ad2,x  ;perform add
3913 : 08                       php
3914 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3916 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3918 : 68                       pla             ;check flags
3919 : 2901                     and #1          ;mask carry
391b : c506                     cmp adrh
                                trap_ne         ;bad carry
391d : d0fe            >        bne *           ;failed not equal (non zero)
                        
391f : 28                       plp
3920 : 08                       php             ;save carry for next add
3921 : a503                     lda ad1
3923 : fd0002                   sbc sba2-ad2,x  ;perform subtract
3926 : 08                       php
3927 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3929 : d0fe            >        bne *           ;failed not equal (non zero)
                        
392b : 68                       pla             ;check flags
392c : 2901                     and #1          ;mask carry
392e : c506                     cmp adrh
                                trap_ne         ;bad carry
3930 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3932 : 28                       plp
                        ; decimal ADC / SBC abs,y
3933 : 08                       php             ;save carry for subtract
3934 : a503                     lda ad1
3936 : 790401                   adc ada2-$ff,y  ;perform add
3939 : 08                       php
393a : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
393c : d0fe            >        bne *           ;failed not equal (non zero)
                        
393e : 68                       pla             ;check flags
393f : 2901                     and #1          ;mask carry
3941 : c506                     cmp adrh
                                trap_ne         ;bad carry
3943 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3945 : 28                       plp
3946 : 08                       php             ;save carry for next add
3947 : a503                     lda ad1
3949 : f90501                   sbc sba2-$ff,y  ;perform subtract
394c : 08                       php
394d : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
394f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3951 : 68                       pla             ;check flags
3952 : 2901                     and #1          ;mask carry
3954 : c506                     cmp adrh
                                trap_ne         ;bad carry
3956 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3958 : 28                       plp
                        ; decimal ADC / SBC (zp,x)
3959 : 08                       php             ;save carry for subtract
395a : a503                     lda ad1
395c : 6144                     adc (lo adi2-ad2,x) ;perform add
395e : 08                       php
395f : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3961 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3963 : 68                       pla             ;check flags
3964 : 2901                     and #1          ;mask carry
3966 : c506                     cmp adrh
                                trap_ne         ;bad carry
3968 : d0fe            >        bne *           ;failed not equal (non zero)
                        
396a : 28                       plp
396b : 08                       php             ;save carry for next add
396c : a503                     lda ad1
396e : e146                     sbc (lo sbi2-ad2,x) ;perform subtract
3970 : 08                       php
3971 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3973 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3975 : 68                       pla             ;check flags
3976 : 2901                     and #1          ;mask carry
3978 : c506                     cmp adrh
                                trap_ne         ;bad carry
397a : d0fe            >        bne *           ;failed not equal (non zero)
                        
397c : 28                       plp
                        ; decimal ADC / SBC (abs),y
397d : 08                       php             ;save carry for subtract
397e : a503                     lda ad1
3980 : 714c                     adc (adiy2),y   ;perform add
3982 : 08                       php
3983 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3985 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3987 : 68                       pla             ;check flags
3988 : 2901                     and #1          ;mask carry
398a : c506                     cmp adrh
                                trap_ne         ;bad carry
398c : d0fe            >        bne *           ;failed not equal (non zero)
                        
398e : 28                       plp
398f : 08                       php             ;save carry for next add
3990 : a503                     lda ad1
3992 : f14e                     sbc (sbiy2),y   ;perform subtract
3994 : 08                       php
3995 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3997 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3999 : 68                       pla             ;check flags
399a : 2901                     and #1          ;mask carry
399c : c506                     cmp adrh
                                trap_ne         ;bad carry
399e : d0fe            >        bne *           ;failed not equal (non zero)
                        
39a0 : 28                       plp
39a1 : 60                       rts
                            endif
                        
                        ; core subroutine of the full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
39a2 : a507             chkadd  lda adrf        ;add V-flag if overflow
39a4 : 2983                     and #$83        ;keep N-----ZC / clear V
39a6 : 48                       pha
39a7 : a503                     lda ad1         ;test sign unequal between operands
39a9 : 4504                     eor ad2
39ab : 300a                     bmi ckad1       ;no overflow possible - operands have different sign
39ad : a503                     lda ad1         ;test sign equal between operands and result
39af : 4505                     eor adrl
39b1 : 1004                     bpl ckad1       ;no overflow occured - operand and result have same sign
39b3 : 68                       pla
39b4 : 0940                     ora #$40        ;set V
39b6 : 48                       pha
39b7 : 68               ckad1   pla
39b8 : 8507                     sta adrf        ;save expected flags
                        ; binary ADC / SBC zp
39ba : 08                       php             ;save carry for subtract
39bb : a503                     lda ad1
39bd : 6504                     adc ad2         ;perform add
39bf : 08                       php
39c0 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
39c2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
39c4 : 68                       pla             ;check flags
39c5 : 29c3                     and #$c3        ;mask NV----ZC
39c7 : c507                     cmp adrf
                                trap_ne         ;bad flags
39c9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
39cb : 28                       plp
39cc : 08                       php             ;save carry for next add
39cd : a503                     lda ad1
39cf : e508                     sbc sb2         ;perform subtract
39d1 : 08                       php
39d2 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
39d4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
39d6 : 68                       pla             ;check flags
39d7 : 29c3                     and #$c3        ;mask NV----ZC
39d9 : c507                     cmp adrf
                                trap_ne         ;bad flags
39db : d0fe            >        bne *           ;failed not equal (non zero)
                        
39dd : 28                       plp
                        ; binary ADC / SBC abs
39de : 08                       php             ;save carry for subtract
39df : a503                     lda ad1
39e1 : 6d0302                   adc ada2        ;perform add
39e4 : 08                       php
39e5 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
39e7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
39e9 : 68                       pla             ;check flags
39ea : 29c3                     and #$c3        ;mask NV----ZC
39ec : c507                     cmp adrf
                                trap_ne         ;bad flags
39ee : d0fe            >        bne *           ;failed not equal (non zero)
                        
39f0 : 28                       plp
39f1 : 08                       php             ;save carry for next add
39f2 : a503                     lda ad1
39f4 : ed0402                   sbc sba2        ;perform subtract
39f7 : 08                       php
39f8 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
39fa : d0fe            >        bne *           ;failed not equal (non zero)
                        
39fc : 68                       pla             ;check flags
39fd : 29c3                     and #$c3        ;mask NV----ZC
39ff : c507                     cmp adrf
                                trap_ne         ;bad flags
3a01 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3a03 : 28                       plp
                        ; binary ADC / SBC #
3a04 : 08                       php             ;save carry for subtract
3a05 : a504                     lda ad2
3a07 : 8d1202                   sta ex_adci+1   ;set ADC # operand
3a0a : a503                     lda ad1
3a0c : 201102                   jsr ex_adci     ;execute ADC # in RAM
3a0f : 08                       php
3a10 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3a12 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3a14 : 68                       pla             ;check flags
3a15 : 29c3                     and #$c3        ;mask NV----ZC
3a17 : c507                     cmp adrf
                                trap_ne         ;bad flags
3a19 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3a1b : 28                       plp
3a1c : 08                       php             ;save carry for next add
3a1d : a508                     lda sb2
3a1f : 8d1502                   sta ex_sbci+1   ;set SBC # operand
3a22 : a503                     lda ad1
3a24 : 201402                   jsr ex_sbci     ;execute SBC # in RAM
3a27 : 08                       php
3a28 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3a2a : d0fe            >        bne *           ;failed not equal (non zero)
                        
3a2c : 68                       pla             ;check flags
3a2d : 29c3                     and #$c3        ;mask NV----ZC
3a2f : c507                     cmp adrf
                                trap_ne         ;bad flags
3a31 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3a33 : 28                       plp
                        ; binary ADC / SBC zp,x
3a34 : 08                       php             ;save carry for subtract
3a35 : a503                     lda ad1
3a37 : 7500                     adc 0,x         ;perform add
3a39 : 08                       php
3a3a : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3a3c : d0fe            >        bne *           ;failed not equal (non zero)
                        
3a3e : 68                       pla             ;check flags
3a3f : 29c3                     and #$c3        ;mask NV----ZC
3a41 : c507                     cmp adrf
                                trap_ne         ;bad flags
3a43 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3a45 : 28                       plp
3a46 : 08                       php             ;save carry for next add
3a47 : a503                     lda ad1
3a49 : f504                     sbc sb2-ad2,x   ;perform subtract
3a4b : 08                       php
3a4c : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3a4e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3a50 : 68                       pla             ;check flags
3a51 : 29c3                     and #$c3        ;mask NV----ZC
3a53 : c507                     cmp adrf
                                trap_ne         ;bad flags
3a55 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3a57 : 28                       plp
                        ; binary ADC / SBC abs,x
3a58 : 08                       php             ;save carry for subtract
3a59 : a503                     lda ad1
3a5b : 7dff01                   adc ada2-ad2,x  ;perform add
3a5e : 08                       php
3a5f : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3a61 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3a63 : 68                       pla             ;check flags
3a64 : 29c3                     and #$c3        ;mask NV----ZC
3a66 : c507                     cmp adrf
                                trap_ne         ;bad flags
3a68 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3a6a : 28                       plp
3a6b : 08                       php             ;save carry for next add
3a6c : a503                     lda ad1
3a6e : fd0002                   sbc sba2-ad2,x  ;perform subtract
3a71 : 08                       php
3a72 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3a74 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3a76 : 68                       pla             ;check flags
3a77 : 29c3                     and #$c3        ;mask NV----ZC
3a79 : c507                     cmp adrf
                                trap_ne         ;bad flags
3a7b : d0fe            >        bne *           ;failed not equal (non zero)
                        
3a7d : 28                       plp
                        ; binary ADC / SBC abs,y
3a7e : 08                       php             ;save carry for subtract
3a7f : a503                     lda ad1
3a81 : 790401                   adc ada2-$ff,y  ;perform add
3a84 : 08                       php
3a85 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3a87 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3a89 : 68                       pla             ;check flags
3a8a : 29c3                     and #$c3        ;mask NV----ZC
3a8c : c507                     cmp adrf
                                trap_ne         ;bad flags
3a8e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3a90 : 28                       plp
3a91 : 08                       php             ;save carry for next add
3a92 : a503                     lda ad1
3a94 : f90501                   sbc sba2-$ff,y  ;perform subtract
3a97 : 08                       php
3a98 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3a9a : d0fe            >        bne *           ;failed not equal (non zero)
                        
3a9c : 68                       pla             ;check flags
3a9d : 29c3                     and #$c3        ;mask NV----ZC
3a9f : c507                     cmp adrf
                                trap_ne         ;bad flags
3aa1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3aa3 : 28                       plp
                        ; binary ADC / SBC (zp,x)
3aa4 : 08                       php             ;save carry for subtract
3aa5 : a503                     lda ad1
3aa7 : 6144                     adc (lo adi2-ad2,x) ;perform add
3aa9 : 08                       php
3aaa : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3aac : d0fe            >        bne *           ;failed not equal (non zero)
                        
3aae : 68                       pla             ;check flags
3aaf : 29c3                     and #$c3        ;mask NV----ZC
3ab1 : c507                     cmp adrf
                                trap_ne         ;bad flags
3ab3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3ab5 : 28                       plp
3ab6 : 08                       php             ;save carry for next add
3ab7 : a503                     lda ad1
3ab9 : e146                     sbc (lo sbi2-ad2,x) ;perform subtract
3abb : 08                       php
3abc : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3abe : d0fe            >        bne *           ;failed not equal (non zero)
                        
3ac0 : 68                       pla             ;check flags
3ac1 : 29c3                     and #$c3        ;mask NV----ZC
3ac3 : c507                     cmp adrf
                                trap_ne         ;bad flags
3ac5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3ac7 : 28                       plp
                        ; binary ADC / SBC (abs),y
3ac8 : 08                       php             ;save carry for subtract
3ac9 : a503                     lda ad1
3acb : 714c                     adc (adiy2),y   ;perform add
3acd : 08                       php
3ace : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3ad0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3ad2 : 68                       pla             ;check flags
3ad3 : 29c3                     and #$c3        ;mask NV----ZC
3ad5 : c507                     cmp adrf
                                trap_ne         ;bad flags
3ad7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3ad9 : 28                       plp
3ada : 08                       php             ;save carry for next add
3adb : a503                     lda ad1
3add : f14e                     sbc (sbiy2),y   ;perform subtract
3adf : 08                       php
3ae0 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3ae2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3ae4 : 68                       pla             ;check flags
3ae5 : 29c3                     and #$c3        ;mask NV----ZC
3ae7 : c507                     cmp adrf
                                trap_ne         ;bad flags
3ae9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3aeb : 28                       plp
3aec : 60                       rts
                        
                        ; target for the jump absolute test
3aed : 88                       dey
3aee : 88                       dey
3aef :                  test_far
3aef : 08                       php             ;either SP or Y count will fail, if we do not hit
3af0 : 88                       dey
3af1 : 88                       dey
3af2 : 88                       dey
3af3 : 28                       plp
                                trap_cs         ;flags loaded?
3af4 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
3af6 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
3af8 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq
3afa : f0fe            >        beq *           ;failed equal (zero)
                        
3afc : c946                     cmp #'F'        ;registers loaded?
                                trap_ne
3afe : d0fe            >        bne *           ;failed not equal (non zero)
                        
3b00 : e041                     cpx #'A'
                                trap_ne
3b02 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3b04 : c04f                     cpy #('R'-3)
                                trap_ne
3b06 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3b08 : 48                       pha             ;save a,x
3b09 : 8a                       txa
3b0a : 48                       pha
3b0b : ba                       tsx
3b0c : e0fd                     cpx #$fd        ;check SP
                                trap_ne
3b0e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3b10 : 68                       pla             ;restore x
3b11 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
3b12 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3b14 : 48              >            pha         ;use stack to load status
3b15 : 28              >            plp
                        
3b16 : 68                       pla             ;restore a
3b17 : e8                       inx             ;return registers with modifications
3b18 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
3b1a : 4c0f0d                   jmp far_ret
                        
                        ; target for the jump indirect test
3b1d : 00                       align
3b1e : 273b             ptr_tst_ind dw test_ind
3b20 : 640d             ptr_ind_ret dw ind_ret
                                trap            ;runover protection
3b22 : 4c223b          >        jmp *           ;failed anyway
                        
3b25 : 88                       dey
3b26 : 88                       dey
3b27 :                  test_ind
3b27 : 08                       php             ;either SP or Y count will fail, if we do not hit
3b28 : 88                       dey
3b29 : 88                       dey
3b2a : 88                       dey
3b2b : 28                       plp
                                trap_cs         ;flags loaded?
3b2c : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
3b2e : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
3b30 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq
3b32 : f0fe            >        beq *           ;failed equal (zero)
                        
3b34 : c949                     cmp #'I'        ;registers loaded?
                                trap_ne
3b36 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3b38 : e04e                     cpx #'N'
                                trap_ne
3b3a : d0fe            >        bne *           ;failed not equal (non zero)
                        
3b3c : c041                     cpy #('D'-3)
                                trap_ne
3b3e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3b40 : 48                       pha             ;save a,x
3b41 : 8a                       txa
3b42 : 48                       pha
3b43 : ba                       tsx
3b44 : e0fd                     cpx #$fd        ;check SP
                                trap_ne
3b46 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3b48 : 68                       pla             ;restore x
3b49 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
3b4a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3b4c : 48              >            pha         ;use stack to load status
3b4d : 28              >            plp
                        
3b4e : 68                       pla             ;restore a
3b4f : e8                       inx             ;return registers with modifications
3b50 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
3b52 : 6c203b                   jmp (ptr_ind_ret)
                                trap            ;runover protection
3b55 : 4c553b          >        jmp *           ;failed anyway
                        
3b58 : 4c0008                   jmp start       ;catastrophic error - cannot continue
                        
                        ; target for the jump subroutine test
3b5b : 88                       dey
3b5c : 88                       dey
3b5d :                  test_jsr
3b5d : 08                       php             ;either SP or Y count will fail, if we do not hit
3b5e : 88                       dey
3b5f : 88                       dey
3b60 : 88                       dey
3b61 : 28                       plp
                                trap_cs         ;flags loaded?
3b62 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
3b64 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
3b66 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq
3b68 : f0fe            >        beq *           ;failed equal (zero)
                        
3b6a : c94a                     cmp #'J'        ;registers loaded?
                                trap_ne
3b6c : d0fe            >        bne *           ;failed not equal (non zero)
                        
3b6e : e053                     cpx #'S'
                                trap_ne
3b70 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3b72 : c04f                     cpy #('R'-3)
                                trap_ne
3b74 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3b76 : 48                       pha             ;save a,x
3b77 : 8a                       txa
3b78 : 48                       pha
3b79 : ba                       tsx             ;sp -4? (return addr,a,x)
3b7a : e0fb                     cpx #$fb
                                trap_ne
3b7c : d0fe            >        bne *           ;failed not equal (non zero)
                        
3b7e : adff01                   lda $1ff        ;propper return on stack
3b81 : c90d                     cmp #hi(jsr_ret)
                                trap_ne
3b83 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3b85 : adfe01                   lda $1fe
3b88 : c99a                     cmp #lo(jsr_ret)
                                trap_ne
3b8a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
3b8c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3b8e : 48              >            pha         ;use stack to load status
3b8f : 28              >            plp
                        
3b90 : 68                       pla             ;pull x,a
3b91 : aa                       tax
3b92 : 68                       pla
3b93 : e8                       inx             ;return registers with modifications
3b94 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
3b96 : 60                       rts
                                trap            ;runover protection
3b97 : 4c973b          >        jmp *           ;failed anyway
                        
3b9a : 4c0008                   jmp start       ;catastrophic error - cannot continue
                        
                        ;trap in case of unexpected IRQ, NMI, BRK, RESET - BRK test target
3b9d :                  nmi_trap
                                trap            ;check stack for conditions at NMI
3b9d : 4c9d3b          >        jmp *           ;failed anyway
                        
3ba0 : 4c0008                   jmp start       ;catastrophic error - cannot continue
3ba3 :                  res_trap
                                trap            ;unexpected RESET
3ba3 : 4ca33b          >        jmp *           ;failed anyway
                        
3ba6 : 4c0008                   jmp start       ;catastrophic error - cannot continue
                        
3ba9 : 88                       dey
3baa : 88                       dey
3bab :                  irq_trap                ;BRK test or unextpected BRK or IRQ
3bab : 08                       php             ;either SP or Y count will fail, if we do not hit
3bac : 88                       dey
3bad : 88                       dey
3bae : 88                       dey
                                ;next traps could be caused by unexpected BRK or IRQ
                                ;check stack for BREAK and originating location
                                ;possible jump/branch into weeds (uninitialized space)
3baf : c9bd                     cmp #$ff-'B'    ;BRK pass 2 registers loaded?
3bb1 : f042                     beq break2
3bb3 : c942                     cmp #'B'        ;BRK pass 1 registers loaded?
                                trap_ne
3bb5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3bb7 : e052                     cpx #'R'
                                trap_ne
3bb9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3bbb : c048                     cpy #'K'-3
                                trap_ne
3bbd : d0fe            >        bne *           ;failed not equal (non zero)
                        
3bbf : 8500                     sta irq_a       ;save registers during break test
3bc1 : 8601                     stx irq_x
3bc3 : ba                       tsx             ;test break on stack
3bc4 : bd0201                   lda $102,x
                                cmp_flag 0      ;break test should have B=1 & unused=1 on stack
3bc7 : c930            >            cmp #(0      |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne         ; - no break flag on stack
3bc9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3bcb : 68                       pla
                                cmp_flag intdis ;should have added interrupt disable
3bcc : c934            >            cmp #(intdis |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
3bce : d0fe            >        bne *           ;failed not equal (non zero)
                        
3bd0 : ba                       tsx
3bd1 : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
3bd3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3bd5 : adff01                   lda $1ff        ;propper return on stack
3bd8 : c90d                     cmp #hi(brk_ret0)
                                trap_ne
3bda : d0fe            >        bne *           ;failed not equal (non zero)
                        
3bdc : adfe01                   lda $1fe
3bdf : c9d1                     cmp #lo(brk_ret0)
                                trap_ne
3be1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                load_flag $ff
3be3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
3be5 : 48                       pha
3be6 : a601                     ldx irq_x
3be8 : e8                       inx             ;return registers with modifications
3be9 : a500                     lda irq_a
3beb : 49aa                     eor #$aa
3bed : 28                       plp             ;N=1, V=1, Z=1, C=1 but original flags should be restored
3bee : 40                       rti
                                trap            ;runover protection
3bef : 4cef3b          >        jmp *           ;failed anyway
                        
3bf2 : 4c0008                   jmp start       ;catastrophic error - cannot continue
                        
3bf5 :                  break2                  ;BRK pass 2
3bf5 : e0ad                     cpx #$ff-'R'
                                trap_ne
3bf7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3bf9 : c0b1                     cpy #$ff-'K'-3
                                trap_ne
3bfb : d0fe            >        bne *           ;failed not equal (non zero)
                        
3bfd : 8500                     sta irq_a       ;save registers during break test
3bff : 8601                     stx irq_x
3c01 : ba                       tsx             ;test break on stack
3c02 : bd0201                   lda $102,x
                                cmp_flag $ff    ;break test should have B=1
3c05 : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne         ; - no break flag on stack
3c07 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3c09 : 68                       pla
3c0a : 0908                     ora #decmode    ;ignore decmode cleared if 65c02
                                cmp_flag $ff    ;actual passed flags
3c0c : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
3c0e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3c10 : ba                       tsx
3c11 : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
3c13 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3c15 : adff01                   lda $1ff        ;propper return on stack
3c18 : c90d                     cmp #hi(brk_ret1)
                                trap_ne
3c1a : d0fe            >        bne *           ;failed not equal (non zero)
                        
3c1c : adfe01                   lda $1fe
3c1f : c9f7                     cmp #lo(brk_ret1)
                                trap_ne
3c21 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                load_flag intdis
3c23 : a904            >            lda #intdis             ;allow test to change I-flag (no mask)
                        
3c25 : 48                       pha
3c26 : a601                     ldx irq_x
3c28 : e8                       inx             ;return registers with modifications
3c29 : a500                     lda irq_a
3c2b : 49aa                     eor #$aa
3c2d : 28                       plp             ;N=0, V=0, Z=0, C=0 but original flags should be restored
3c2e : 40                       rti
                                trap            ;runover protection
3c2f : 4c2f3c          >        jmp *           ;failed anyway
                        
3c32 : 4c0008                   jmp start       ;catastrophic error - cannot continue
                        
                            if report = 1
                                include "report.i65"
                            endif
                        
                        ;copy of data to initialize BSS segment
                            if load_data_direct != 1
                        zp_init
                        zp1_    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
                        zp7f_   db  $7f             ;test pattern for compare
                        ;logical zeropage operands
                        zpOR_   db  0,$1f,$71,$80   ;test pattern for OR
                        zpAN_   db  $0f,$ff,$7f,$80 ;test pattern for AND
                        zpEO_   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
                        ind1_   dw  abs1            ;indirect pointer to pattern in absolute memory
                                dw  abs1+1
                                dw  abs1+2
                                dw  abs1+3
                                dw  abs7f
                        inw1_   dw  abs1-$f8        ;indirect pointer for wrap-test pattern
                        indt_   dw  abst            ;indirect pointer to store area in absolute memory
                                dw  abst+1
                                dw  abst+2
                                dw  abst+3
                        inwt_   dw  abst-$f8        ;indirect pointer for wrap-test store
                        indAN_  dw  absAN           ;indirect pointer to AND pattern in absolute memory
                                dw  absAN+1
                                dw  absAN+2
                                dw  absAN+3
                        indEO_  dw  absEO           ;indirect pointer to EOR pattern in absolute memory
                                dw  absEO+1
                                dw  absEO+2
                                dw  absEO+3
                        indOR_  dw  absOR           ;indirect pointer to OR pattern in absolute memory
                                dw  absOR+1
                                dw  absOR+2
                                dw  absOR+3
                        ;add/subtract indirect pointers
                        adi2_   dw  ada2            ;indirect pointer to operand 2 in absolute memory
                        sbi2_   dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
                        adiy2_  dw  ada2-$ff        ;with offset for indirect indexed
                        sbiy2_  dw  sba2-$ff
                        zp_end
                            if (zp_end - zp_init) != (zp_bss_end - zp_bss)
                                ;force assembler error if size is different
                                ERROR ERROR ERROR   ;mismatch between bss and zeropage data
                            endif
                        data_init
                        ex_and_ and #0              ;execute immediate opcodes
                                rts
                        ex_eor_ eor #0              ;execute immediate opcodes
                                rts
                        ex_ora_ ora #0              ;execute immediate opcodes
                                rts
                        ex_adc_ adc #0              ;execute immediate opcodes
                                rts
                        ex_sbc_ sbc #0              ;execute immediate opcodes
                                rts
                        abs1_   db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
                        abs7f_  db  $7f             ;test pattern for compare
                        ;loads
                        fLDx_   db  fn,fn,0,fz      ;expected flags for load
                        ;shifts
                        rASL_                       ;expected result ASL & ROL -carry
                        rROL_   db  $86,$04,$82,0   ; "
                        rROLc_  db  $87,$05,$83,1   ;expected result ROL +carry
                        rLSR_                       ;expected result LSR & ROR -carry
                        rROR_   db  $61,$41,$20,0   ; "
                        rRORc_  db  $e1,$c1,$a0,$80 ;expected result ROR +carry
                        fASL_                       ;expected flags for shifts
                        fROL_   db  fnc,fc,fn,fz    ;no carry in
                        fROLc_  db  fnc,fc,fn,0     ;carry in
                        fLSR_
                        fROR_   db  fc,0,fc,fz      ;no carry in
                        fRORc_  db  fnc,fn,fnc,fn   ;carry in
                        ;increments (decrements)
                        rINC_   db  $7f,$80,$ff,0,1 ;expected result for INC/DEC
                        fINC_   db  0,fn,fn,fz,0    ;expected flags for INC/DEC
                        ;logical memory operand
                        absOR_  db  0,$1f,$71,$80   ;test pattern for OR
                        absAN_  db  $0f,$ff,$7f,$80 ;test pattern for AND
                        absEO_  db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;logical accu operand
                        absORa_ db  0,$f1,$1f,0     ;test pattern for OR
                        absANa_ db  $f0,$ff,$ff,$ff ;test pattern for AND
                        absEOa_ db  $ff,$f0,$f0,$0f ;test pattern for EOR
                        ;logical results
                        absrlo_ db  0,$ff,$7f,$80
                        absflo_ db  fz,fn,0,fn
                        data_end
                            if (data_end - data_init) != (data_bss_end - data_bss)
                                ;force assembler error if size is different
                                ERROR ERROR ERROR   ;mismatch between bss and data
                            endif
                        
                        vec_init
                                dw  nmi_trap
                                dw  res_trap
                                dw  irq_trap
                        vec_bss equ $fffa
                            endif                   ;end of RAM init data
                        
                            if (load_data_direct = 1) & (ROM_vectors = 1)
fffa =                          org $fffa       ;vectors
fffa : 9d3b                     dw  nmi_trap
fffc : a33b                     dw  res_trap
fffe : ab3b                     dw  irq_trap
                            endif
                        
fffa =                          end start
                        
No errors in pass 2.
Wrote binary from address $0000 through $ffff.
Total size 65536 bytes.
Program start address is at $0800 (2048).
